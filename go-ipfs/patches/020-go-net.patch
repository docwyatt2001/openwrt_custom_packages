--- /dev/null
+++ b/gx-patches/go-net.patch
@@ -0,0 +1,14896 @@
+diff -uNr go-net.old/ipv4/batch.go go-net/ipv4/batch.go
+--- go-net.old/ipv4/batch.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/batch.go	2018-05-30 21:01:01.910196139 +0200
+@@ -0,0 +1,191 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++
++package ipv4
++
++import (
++	"net"
++	"runtime"
++	"syscall"
++
++	"golang.org/x/net/internal/socket"
++)
++
++// BUG(mikio): On Windows, the ReadBatch and WriteBatch methods of
++// PacketConn are not implemented.
++
++// BUG(mikio): On Windows, the ReadBatch and WriteBatch methods of
++// RawConn are not implemented.
++
++// A Message represents an IO message.
++//
++//	type Message struct {
++//		Buffers [][]byte
++//		OOB     []byte
++//		Addr    net.Addr
++//		N       int
++//		NN      int
++//		Flags   int
++//	}
++//
++// The Buffers fields represents a list of contiguous buffers, which
++// can be used for vectored IO, for example, putting a header and a
++// payload in each slice.
++// When writing, the Buffers field must contain at least one byte to
++// write.
++// When reading, the Buffers field will always contain a byte to read.
++//
++// The OOB field contains protocol-specific control or miscellaneous
++// ancillary data known as out-of-band data.
++// It can be nil when not required.
++//
++// The Addr field specifies a destination address when writing.
++// It can be nil when the underlying protocol of the endpoint uses
++// connection-oriented communication.
++// After a successful read, it may contain the source address on the
++// received packet.
++//
++// The N field indicates the number of bytes read or written from/to
++// Buffers.
++//
++// The NN field indicates the number of bytes read or written from/to
++// OOB.
++//
++// The Flags field contains protocol-specific information on the
++// received message.
++type Message = socket.Message
++
++// ReadBatch reads a batch of messages.
++//
++// The provided flags is a set of platform-dependent flags, such as
++// syscall.MSG_PEEK.
++//
++// On a successful read it returns the number of messages received, up
++// to len(ms).
++//
++// On Linux, a batch read will be optimized.
++// On other platforms, this method will read only a single message.
++//
++// Unlike the ReadFrom method, it doesn't strip the IPv4 header
++// followed by option headers from the received IPv4 datagram when the
++// underlying transport is net.IPConn. Each Buffers field of Message
++// must be large enough to accommodate an IPv4 header and option
++// headers.
++func (c *payloadHandler) ReadBatch(ms []Message, flags int) (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	switch runtime.GOOS {
++	case "linux":
++		n, err := c.RecvMsgs([]socket.Message(ms), flags)
++		if err != nil {
++			err = &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	default:
++		n := 1
++		err := c.RecvMsg(&ms[0], flags)
++		if err != nil {
++			n = 0
++			err = &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	}
++}
++
++// WriteBatch writes a batch of messages.
++//
++// The provided flags is a set of platform-dependent flags, such as
++// syscall.MSG_DONTROUTE.
++//
++// It returns the number of messages written on a successful write.
++//
++// On Linux, a batch write will be optimized.
++// On other platforms, this method will write only a single message.
++func (c *payloadHandler) WriteBatch(ms []Message, flags int) (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	switch runtime.GOOS {
++	case "linux":
++		n, err := c.SendMsgs([]socket.Message(ms), flags)
++		if err != nil {
++			err = &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	default:
++		n := 1
++		err := c.SendMsg(&ms[0], flags)
++		if err != nil {
++			n = 0
++			err = &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	}
++}
++
++// ReadBatch reads a batch of messages.
++//
++// The provided flags is a set of platform-dependent flags, such as
++// syscall.MSG_PEEK.
++//
++// On a successful read it returns the number of messages received, up
++// to len(ms).
++//
++// On Linux, a batch read will be optimized.
++// On other platforms, this method will read only a single message.
++func (c *packetHandler) ReadBatch(ms []Message, flags int) (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	switch runtime.GOOS {
++	case "linux":
++		n, err := c.RecvMsgs([]socket.Message(ms), flags)
++		if err != nil {
++			err = &net.OpError{Op: "read", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	default:
++		n := 1
++		err := c.RecvMsg(&ms[0], flags)
++		if err != nil {
++			n = 0
++			err = &net.OpError{Op: "read", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	}
++}
++
++// WriteBatch writes a batch of messages.
++//
++// The provided flags is a set of platform-dependent flags, such as
++// syscall.MSG_DONTROUTE.
++//
++// It returns the number of messages written on a successful write.
++//
++// On Linux, a batch write will be optimized.
++// On other platforms, this method will write only a single message.
++func (c *packetHandler) WriteBatch(ms []Message, flags int) (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	switch runtime.GOOS {
++	case "linux":
++		n, err := c.SendMsgs([]socket.Message(ms), flags)
++		if err != nil {
++			err = &net.OpError{Op: "write", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	default:
++		n := 1
++		err := c.SendMsg(&ms[0], flags)
++		if err != nil {
++			n = 0
++			err = &net.OpError{Op: "write", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	}
++}
+diff -uNr go-net.old/ipv4/bpf_test.go go-net/ipv4/bpf_test.go
+--- go-net.old/ipv4/bpf_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/bpf_test.go	2018-05-30 21:01:01.910196139 +0200
+@@ -0,0 +1,93 @@
++// Copyright 2016 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv4_test
++
++import (
++	"net"
++	"runtime"
++	"testing"
++	"time"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/ipv4"
++)
++
++func TestBPF(t *testing.T) {
++	if runtime.GOOS != "linux" {
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	l, err := net.ListenPacket("udp4", "127.0.0.1:0")
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer l.Close()
++
++	p := ipv4.NewPacketConn(l)
++
++	// This filter accepts UDP packets whose first payload byte is
++	// even.
++	prog, err := bpf.Assemble([]bpf.Instruction{
++		// Load the first byte of the payload (skipping UDP header).
++		bpf.LoadAbsolute{Off: 8, Size: 1},
++		// Select LSB of the byte.
++		bpf.ALUOpConstant{Op: bpf.ALUOpAnd, Val: 1},
++		// Byte is even?
++		bpf.JumpIf{Cond: bpf.JumpEqual, Val: 0, SkipFalse: 1},
++		// Accept.
++		bpf.RetConstant{Val: 4096},
++		// Ignore.
++		bpf.RetConstant{Val: 0},
++	})
++	if err != nil {
++		t.Fatalf("compiling BPF: %s", err)
++	}
++
++	if err = p.SetBPF(prog); err != nil {
++		t.Fatalf("attaching filter to Conn: %s", err)
++	}
++
++	s, err := net.Dial("udp4", l.LocalAddr().String())
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer s.Close()
++	go func() {
++		for i := byte(0); i < 10; i++ {
++			s.Write([]byte{i})
++		}
++	}()
++
++	l.SetDeadline(time.Now().Add(2 * time.Second))
++	seen := make([]bool, 5)
++	for {
++		var b [512]byte
++		n, _, err := l.ReadFrom(b[:])
++		if err != nil {
++			t.Fatalf("reading from listener: %s", err)
++		}
++		if n != 1 {
++			t.Fatalf("unexpected packet length, want 1, got %d", n)
++		}
++		if b[0] >= 10 {
++			t.Fatalf("unexpected byte, want 0-9, got %d", b[0])
++		}
++		if b[0]%2 != 0 {
++			t.Fatalf("got odd byte %d, wanted only even bytes", b[0])
++		}
++		seen[b[0]/2] = true
++
++		seenAll := true
++		for _, v := range seen {
++			if !v {
++				seenAll = false
++				break
++			}
++		}
++		if seenAll {
++			break
++		}
++	}
++}
+diff -uNr go-net.old/ipv4/control_bsd.go go-net/ipv4/control_bsd.go
+--- go-net.old/ipv4/control_bsd.go	2018-05-31 12:15:35.363676294 +0200
++++ go-net/ipv4/control_bsd.go	2018-05-30 21:01:01.910196139 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -11,27 +11,27 @@
+ 	"syscall"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ func marshalDst(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIP
+-	m.Type = sysIP_RECVDSTADDR
+-	m.SetLen(syscall.CmsgLen(net.IPv4len))
+-	return b[syscall.CmsgSpace(net.IPv4len):]
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIP, sysIP_RECVDSTADDR, net.IPv4len)
++	return m.Next(net.IPv4len)
+ }
+ 
+ func parseDst(cm *ControlMessage, b []byte) {
+-	cm.Dst = b[:net.IPv4len]
++	if len(cm.Dst) < net.IPv4len {
++		cm.Dst = make(net.IP, net.IPv4len)
++	}
++	copy(cm.Dst, b[:net.IPv4len])
+ }
+ 
+ func marshalInterface(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIP
+-	m.Type = sysIP_RECVIF
+-	m.SetLen(syscall.CmsgLen(syscall.SizeofSockaddrDatalink))
+-	return b[syscall.CmsgSpace(syscall.SizeofSockaddrDatalink):]
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIP, sysIP_RECVIF, syscall.SizeofSockaddrDatalink)
++	return m.Next(syscall.SizeofSockaddrDatalink)
+ }
+ 
+ func parseInterface(cm *ControlMessage, b []byte) {
+diff -uNr go-net.old/ipv4/control.go go-net/ipv4/control.go
+--- go-net.old/ipv4/control.go	2018-05-31 12:15:09.588224577 +0200
++++ go-net/ipv4/control.go	2018-05-30 21:01:01.910196139 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -8,6 +8,9 @@
+ 	"fmt"
+ 	"net"
+ 	"sync"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ type rawOpt struct {
+@@ -51,6 +54,77 @@
+ 	return fmt.Sprintf("ttl=%d src=%v dst=%v ifindex=%d", cm.TTL, cm.Src, cm.Dst, cm.IfIndex)
+ }
+ 
++// Marshal returns the binary encoding of cm.
++func (cm *ControlMessage) Marshal() []byte {
++	if cm == nil {
++		return nil
++	}
++	var m socket.ControlMessage
++	if ctlOpts[ctlPacketInfo].name > 0 && (cm.Src.To4() != nil || cm.IfIndex > 0) {
++		m = socket.NewControlMessage([]int{ctlOpts[ctlPacketInfo].length})
++	}
++	if len(m) > 0 {
++		ctlOpts[ctlPacketInfo].marshal(m, cm)
++	}
++	return m
++}
++
++// Parse parses b as a control message and stores the result in cm.
++func (cm *ControlMessage) Parse(b []byte) error {
++	ms, err := socket.ControlMessage(b).Parse()
++	if err != nil {
++		return err
++	}
++	for _, m := range ms {
++		lvl, typ, l, err := m.ParseHeader()
++		if err != nil {
++			return err
++		}
++		if lvl != iana.ProtocolIP {
++			continue
++		}
++		switch {
++		case typ == ctlOpts[ctlTTL].name && l >= ctlOpts[ctlTTL].length:
++			ctlOpts[ctlTTL].parse(cm, m.Data(l))
++		case typ == ctlOpts[ctlDst].name && l >= ctlOpts[ctlDst].length:
++			ctlOpts[ctlDst].parse(cm, m.Data(l))
++		case typ == ctlOpts[ctlInterface].name && l >= ctlOpts[ctlInterface].length:
++			ctlOpts[ctlInterface].parse(cm, m.Data(l))
++		case typ == ctlOpts[ctlPacketInfo].name && l >= ctlOpts[ctlPacketInfo].length:
++			ctlOpts[ctlPacketInfo].parse(cm, m.Data(l))
++		}
++	}
++	return nil
++}
++
++// NewControlMessage returns a new control message.
++//
++// The returned message is large enough for options specified by cf.
++func NewControlMessage(cf ControlFlags) []byte {
++	opt := rawOpt{cflags: cf}
++	var l int
++	if opt.isset(FlagTTL) && ctlOpts[ctlTTL].name > 0 {
++		l += socket.ControlMessageSpace(ctlOpts[ctlTTL].length)
++	}
++	if ctlOpts[ctlPacketInfo].name > 0 {
++		if opt.isset(FlagSrc | FlagDst | FlagInterface) {
++			l += socket.ControlMessageSpace(ctlOpts[ctlPacketInfo].length)
++		}
++	} else {
++		if opt.isset(FlagDst) && ctlOpts[ctlDst].name > 0 {
++			l += socket.ControlMessageSpace(ctlOpts[ctlDst].length)
++		}
++		if opt.isset(FlagInterface) && ctlOpts[ctlInterface].name > 0 {
++			l += socket.ControlMessageSpace(ctlOpts[ctlInterface].length)
++		}
++	}
++	var b []byte
++	if l > 0 {
++		b = make([]byte, l)
++	}
++	return b
++}
++
+ // Ancillary data socket options
+ const (
+ 	ctlTTL        = iota // header field
+diff -uNr go-net.old/ipv4/control_pktinfo.go go-net/ipv4/control_pktinfo.go
+--- go-net.old/ipv4/control_pktinfo.go	2018-05-31 12:15:35.363676294 +0200
++++ go-net/ipv4/control_pktinfo.go	2018-05-30 21:01:01.910196139 +0200
+@@ -2,24 +2,23 @@
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build darwin linux
++// +build darwin linux solaris
+ 
+ package ipv4
+ 
+ import (
+-	"syscall"
++	"net"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ func marshalPacketInfo(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIP
+-	m.Type = sysIP_PKTINFO
+-	m.SetLen(syscall.CmsgLen(sysSizeofInetPktinfo))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIP, sysIP_PKTINFO, sizeofInetPktinfo)
+ 	if cm != nil {
+-		pi := (*sysInetPktinfo)(unsafe.Pointer(&b[syscall.CmsgLen(0)]))
++		pi := (*inetPktinfo)(unsafe.Pointer(&m.Data(sizeofInetPktinfo)[0]))
+ 		if ip := cm.Src.To4(); ip != nil {
+ 			copy(pi.Spec_dst[:], ip)
+ 		}
+@@ -27,11 +26,14 @@
+ 			pi.setIfindex(cm.IfIndex)
+ 		}
+ 	}
+-	return b[syscall.CmsgSpace(sysSizeofInetPktinfo):]
++	return m.Next(sizeofInetPktinfo)
+ }
+ 
+ func parsePacketInfo(cm *ControlMessage, b []byte) {
+-	pi := (*sysInetPktinfo)(unsafe.Pointer(&b[0]))
++	pi := (*inetPktinfo)(unsafe.Pointer(&b[0]))
+ 	cm.IfIndex = int(pi.Ifindex)
+-	cm.Dst = pi.Addr[:]
++	if len(cm.Dst) < net.IPv4len {
++		cm.Dst = make(net.IP, net.IPv4len)
++	}
++	copy(cm.Dst, pi.Addr[:])
+ }
+diff -uNr go-net.old/ipv4/control_rfc2292_unix.go go-net/ipv4/control_rfc2292_unix.go
+--- go-net.old/ipv4/control_rfc2292_unix.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/control_rfc2292_unix.go	2018-05-30 21:00:38.874684823 +0200
+@@ -0,0 +1,48 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin
++
++package ipv6
++
++import (
++	"unsafe"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
++
++func marshal2292HopLimit(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_2292HOPLIMIT, 4)
++	if cm != nil {
++		socket.NativeEndian.PutUint32(m.Data(4), uint32(cm.HopLimit))
++	}
++	return m.Next(4)
++}
++
++func marshal2292PacketInfo(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_2292PKTINFO, sizeofInet6Pktinfo)
++	if cm != nil {
++		pi := (*inet6Pktinfo)(unsafe.Pointer(&m.Data(sizeofInet6Pktinfo)[0]))
++		if ip := cm.Src.To16(); ip != nil && ip.To4() == nil {
++			copy(pi.Addr[:], ip)
++		}
++		if cm.IfIndex > 0 {
++			pi.setIfindex(cm.IfIndex)
++		}
++	}
++	return m.Next(sizeofInet6Pktinfo)
++}
++
++func marshal2292NextHop(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_2292NEXTHOP, sizeofSockaddrInet6)
++	if cm != nil {
++		sa := (*sockaddrInet6)(unsafe.Pointer(&m.Data(sizeofSockaddrInet6)[0]))
++		sa.setSockaddr(cm.NextHop, cm.IfIndex)
++	}
++	return m.Next(sizeofSockaddrInet6)
++}
+diff -uNr go-net.old/ipv4/control_rfc3542_unix.go go-net/ipv4/control_rfc3542_unix.go
+--- go-net.old/ipv4/control_rfc3542_unix.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/control_rfc3542_unix.go	2018-05-30 21:00:38.874684823 +0200
+@@ -0,0 +1,94 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris
++
++package ipv6
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
++
++func marshalTrafficClass(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_TCLASS, 4)
++	if cm != nil {
++		socket.NativeEndian.PutUint32(m.Data(4), uint32(cm.TrafficClass))
++	}
++	return m.Next(4)
++}
++
++func parseTrafficClass(cm *ControlMessage, b []byte) {
++	cm.TrafficClass = int(socket.NativeEndian.Uint32(b[:4]))
++}
++
++func marshalHopLimit(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_HOPLIMIT, 4)
++	if cm != nil {
++		socket.NativeEndian.PutUint32(m.Data(4), uint32(cm.HopLimit))
++	}
++	return m.Next(4)
++}
++
++func parseHopLimit(cm *ControlMessage, b []byte) {
++	cm.HopLimit = int(socket.NativeEndian.Uint32(b[:4]))
++}
++
++func marshalPacketInfo(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_PKTINFO, sizeofInet6Pktinfo)
++	if cm != nil {
++		pi := (*inet6Pktinfo)(unsafe.Pointer(&m.Data(sizeofInet6Pktinfo)[0]))
++		if ip := cm.Src.To16(); ip != nil && ip.To4() == nil {
++			copy(pi.Addr[:], ip)
++		}
++		if cm.IfIndex > 0 {
++			pi.setIfindex(cm.IfIndex)
++		}
++	}
++	return m.Next(sizeofInet6Pktinfo)
++}
++
++func parsePacketInfo(cm *ControlMessage, b []byte) {
++	pi := (*inet6Pktinfo)(unsafe.Pointer(&b[0]))
++	if len(cm.Dst) < net.IPv6len {
++		cm.Dst = make(net.IP, net.IPv6len)
++	}
++	copy(cm.Dst, pi.Addr[:])
++	cm.IfIndex = int(pi.Ifindex)
++}
++
++func marshalNextHop(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_NEXTHOP, sizeofSockaddrInet6)
++	if cm != nil {
++		sa := (*sockaddrInet6)(unsafe.Pointer(&m.Data(sizeofSockaddrInet6)[0]))
++		sa.setSockaddr(cm.NextHop, cm.IfIndex)
++	}
++	return m.Next(sizeofSockaddrInet6)
++}
++
++func parseNextHop(cm *ControlMessage, b []byte) {
++}
++
++func marshalPathMTU(b []byte, cm *ControlMessage) []byte {
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_PATHMTU, sizeofIPv6Mtuinfo)
++	return m.Next(sizeofIPv6Mtuinfo)
++}
++
++func parsePathMTU(cm *ControlMessage, b []byte) {
++	mi := (*ipv6Mtuinfo)(unsafe.Pointer(&b[0]))
++	if len(cm.Dst) < net.IPv6len {
++		cm.Dst = make(net.IP, net.IPv6len)
++	}
++	copy(cm.Dst, mi.Addr.Addr[:])
++	cm.IfIndex = int(mi.Addr.Scope_id)
++	cm.MTU = int(mi.Mtu)
++}
+diff -uNr go-net.old/ipv4/control_stub.go go-net/ipv4/control_stub.go
+--- go-net.old/ipv4/control_stub.go	2018-05-31 12:15:09.588224577 +0200
++++ go-net/ipv4/control_stub.go	2018-05-30 21:01:01.910196139 +0200
+@@ -1,23 +1,13 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9 solaris
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv4
+ 
+-func setControlMessage(fd int, opt *rawOpt, cf ControlFlags, on bool) error {
+-	return errOpNoSupport
+-}
+-
+-func newControlMessage(opt *rawOpt) []byte {
+-	return nil
+-}
++import "golang.org/x/net/internal/socket"
+ 
+-func parseControlMessage(b []byte) (*ControlMessage, error) {
+-	return nil, errOpNoSupport
+-}
+-
+-func marshalControlMessage(cm *ControlMessage) []byte {
+-	return nil
++func setControlMessage(c *socket.Conn, opt *rawOpt, cf ControlFlags, on bool) error {
++	return errOpNoSupport
+ }
+diff -uNr go-net.old/ipv4/control_test.go go-net/ipv4/control_test.go
+--- go-net.old/ipv4/control_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/control_test.go	2018-05-30 21:01:01.910196139 +0200
+@@ -0,0 +1,21 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv4_test
++
++import (
++	"testing"
++
++	"golang.org/x/net/ipv4"
++)
++
++func TestControlMessageParseWithFuzz(t *testing.T) {
++	var cm ipv4.ControlMessage
++	for _, fuzz := range []string{
++		"\f\x00\x00\x00\x00\x00\x00\x00\x14\x00\x00\x00",
++		"\f\x00\x00\x00\x00\x00\x00\x00\x1a\x00\x00\x00",
++	} {
++		cm.Parse([]byte(fuzz))
++	}
++}
+diff -uNr go-net.old/ipv4/control_unix.go go-net/ipv4/control_unix.go
+--- go-net.old/ipv4/control_unix.go	2018-05-31 12:15:35.371676126 +0200
++++ go-net/ipv4/control_unix.go	2018-05-30 21:01:01.910196139 +0200
+@@ -1,24 +1,23 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build darwin dragonfly freebsd linux netbsd openbsd
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris
+ 
+ package ipv4
+ 
+ import (
+-	"os"
+-	"syscall"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+-func setControlMessage(fd int, opt *rawOpt, cf ControlFlags, on bool) error {
++func setControlMessage(c *socket.Conn, opt *rawOpt, cf ControlFlags, on bool) error {
+ 	opt.Lock()
+ 	defer opt.Unlock()
+-	if cf&FlagTTL != 0 && sockOpts[ssoReceiveTTL].name > 0 {
+-		if err := setInt(fd, &sockOpts[ssoReceiveTTL], boolint(on)); err != nil {
++	if so, ok := sockOpts[ssoReceiveTTL]; ok && cf&FlagTTL != 0 {
++		if err := so.SetInt(c, boolint(on)); err != nil {
+ 			return err
+ 		}
+ 		if on {
+@@ -27,9 +26,9 @@
+ 			opt.clear(FlagTTL)
+ 		}
+ 	}
+-	if sockOpts[ssoPacketInfo].name > 0 {
++	if so, ok := sockOpts[ssoPacketInfo]; ok {
+ 		if cf&(FlagSrc|FlagDst|FlagInterface) != 0 {
+-			if err := setInt(fd, &sockOpts[ssoPacketInfo], boolint(on)); err != nil {
++			if err := so.SetInt(c, boolint(on)); err != nil {
+ 				return err
+ 			}
+ 			if on {
+@@ -39,8 +38,8 @@
+ 			}
+ 		}
+ 	} else {
+-		if cf&FlagDst != 0 && sockOpts[ssoReceiveDst].name > 0 {
+-			if err := setInt(fd, &sockOpts[ssoReceiveDst], boolint(on)); err != nil {
++		if so, ok := sockOpts[ssoReceiveDst]; ok && cf&FlagDst != 0 {
++			if err := so.SetInt(c, boolint(on)); err != nil {
+ 				return err
+ 			}
+ 			if on {
+@@ -49,8 +48,8 @@
+ 				opt.clear(FlagDst)
+ 			}
+ 		}
+-		if cf&FlagInterface != 0 && sockOpts[ssoReceiveInterface].name > 0 {
+-			if err := setInt(fd, &sockOpts[ssoReceiveInterface], boolint(on)); err != nil {
++		if so, ok := sockOpts[ssoReceiveInterface]; ok && cf&FlagInterface != 0 {
++			if err := so.SetInt(c, boolint(on)); err != nil {
+ 				return err
+ 			}
+ 			if on {
+@@ -63,100 +62,10 @@
+ 	return nil
+ }
+ 
+-func newControlMessage(opt *rawOpt) (oob []byte) {
+-	opt.RLock()
+-	var l int
+-	if opt.isset(FlagTTL) && ctlOpts[ctlTTL].name > 0 {
+-		l += syscall.CmsgSpace(ctlOpts[ctlTTL].length)
+-	}
+-	if ctlOpts[ctlPacketInfo].name > 0 {
+-		if opt.isset(FlagSrc | FlagDst | FlagInterface) {
+-			l += syscall.CmsgSpace(ctlOpts[ctlPacketInfo].length)
+-		}
+-	} else {
+-		if opt.isset(FlagDst) && ctlOpts[ctlDst].name > 0 {
+-			l += syscall.CmsgSpace(ctlOpts[ctlDst].length)
+-		}
+-		if opt.isset(FlagInterface) && ctlOpts[ctlInterface].name > 0 {
+-			l += syscall.CmsgSpace(ctlOpts[ctlInterface].length)
+-		}
+-	}
+-	if l > 0 {
+-		oob = make([]byte, l)
+-		b := oob
+-		if opt.isset(FlagTTL) && ctlOpts[ctlTTL].name > 0 {
+-			b = ctlOpts[ctlTTL].marshal(b, nil)
+-		}
+-		if ctlOpts[ctlPacketInfo].name > 0 {
+-			if opt.isset(FlagSrc | FlagDst | FlagInterface) {
+-				b = ctlOpts[ctlPacketInfo].marshal(b, nil)
+-			}
+-		} else {
+-			if opt.isset(FlagDst) && ctlOpts[ctlDst].name > 0 {
+-				b = ctlOpts[ctlDst].marshal(b, nil)
+-			}
+-			if opt.isset(FlagInterface) && ctlOpts[ctlInterface].name > 0 {
+-				b = ctlOpts[ctlInterface].marshal(b, nil)
+-			}
+-		}
+-	}
+-	opt.RUnlock()
+-	return
+-}
+-
+-func parseControlMessage(b []byte) (*ControlMessage, error) {
+-	if len(b) == 0 {
+-		return nil, nil
+-	}
+-	cmsgs, err := syscall.ParseSocketControlMessage(b)
+-	if err != nil {
+-		return nil, os.NewSyscallError("parse socket control message", err)
+-	}
+-	cm := &ControlMessage{}
+-	for _, m := range cmsgs {
+-		if m.Header.Level != iana.ProtocolIP {
+-			continue
+-		}
+-		switch int(m.Header.Type) {
+-		case ctlOpts[ctlTTL].name:
+-			ctlOpts[ctlTTL].parse(cm, m.Data[:])
+-		case ctlOpts[ctlDst].name:
+-			ctlOpts[ctlDst].parse(cm, m.Data[:])
+-		case ctlOpts[ctlInterface].name:
+-			ctlOpts[ctlInterface].parse(cm, m.Data[:])
+-		case ctlOpts[ctlPacketInfo].name:
+-			ctlOpts[ctlPacketInfo].parse(cm, m.Data[:])
+-		}
+-	}
+-	return cm, nil
+-}
+-
+-func marshalControlMessage(cm *ControlMessage) (oob []byte) {
+-	if cm == nil {
+-		return nil
+-	}
+-	var l int
+-	pktinfo := false
+-	if ctlOpts[ctlPacketInfo].name > 0 && (cm.Src.To4() != nil || cm.IfIndex > 0) {
+-		pktinfo = true
+-		l += syscall.CmsgSpace(ctlOpts[ctlPacketInfo].length)
+-	}
+-	if l > 0 {
+-		oob = make([]byte, l)
+-		b := oob
+-		if pktinfo {
+-			b = ctlOpts[ctlPacketInfo].marshal(b, cm)
+-		}
+-	}
+-	return
+-}
+-
+ func marshalTTL(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIP
+-	m.Type = sysIP_RECVTTL
+-	m.SetLen(syscall.CmsgLen(1))
+-	return b[syscall.CmsgSpace(1):]
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIP, sysIP_RECVTTL, 1)
++	return m.Next(1)
+ }
+ 
+ func parseTTL(cm *ControlMessage, b []byte) {
+diff -uNr go-net.old/ipv4/control_windows.go go-net/ipv4/control_windows.go
+--- go-net.old/ipv4/control_windows.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/control_windows.go	2018-05-30 21:01:01.910196139 +0200
+@@ -1,27 +1,16 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv4
+ 
+-import "syscall"
++import (
++	"syscall"
+ 
+-func setControlMessage(fd syscall.Handle, opt *rawOpt, cf ControlFlags, on bool) error {
+-	// TODO(mikio): implement this
+-	return syscall.EWINDOWS
+-}
+-
+-func newControlMessage(opt *rawOpt) []byte {
+-	// TODO(mikio): implement this
+-	return nil
+-}
++	"golang.org/x/net/internal/socket"
++)
+ 
+-func parseControlMessage(b []byte) (*ControlMessage, error) {
++func setControlMessage(c *socket.Conn, opt *rawOpt, cf ControlFlags, on bool) error {
+ 	// TODO(mikio): implement this
+-	return nil, syscall.EWINDOWS
+-}
+-
+-func marshalControlMessage(cm *ControlMessage) []byte {
+-	// TODO(mikio): implement this
+-	return nil
++	return syscall.EWINDOWS
+ }
+diff -uNr go-net.old/ipv4/defs_darwin.go go-net/ipv4/defs_darwin.go
+--- go-net.old/ipv4/defs_darwin.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/defs_darwin.go	2018-05-30 21:01:01.910196139 +0200
+@@ -49,29 +49,29 @@
+ 	sysMCAST_BLOCK_SOURCE        = C.MCAST_BLOCK_SOURCE
+ 	sysMCAST_UNBLOCK_SOURCE      = C.MCAST_UNBLOCK_SOURCE
+ 
+-	sysSizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
+-	sysSizeofSockaddrInet    = C.sizeof_struct_sockaddr_in
+-	sysSizeofInetPktinfo     = C.sizeof_struct_in_pktinfo
+-
+-	sysSizeofIPMreq         = C.sizeof_struct_ip_mreq
+-	sysSizeofIPMreqn        = C.sizeof_struct_ip_mreqn
+-	sysSizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
+-	sysSizeofGroupReq       = C.sizeof_struct_group_req
+-	sysSizeofGroupSourceReq = C.sizeof_struct_group_source_req
++	sizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
++	sizeofSockaddrInet    = C.sizeof_struct_sockaddr_in
++	sizeofInetPktinfo     = C.sizeof_struct_in_pktinfo
++
++	sizeofIPMreq         = C.sizeof_struct_ip_mreq
++	sizeofIPMreqn        = C.sizeof_struct_ip_mreqn
++	sizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
+ )
+ 
+-type sysSockaddrStorage C.struct_sockaddr_storage
++type sockaddrStorage C.struct_sockaddr_storage
+ 
+-type sysSockaddrInet C.struct_sockaddr_in
++type sockaddrInet C.struct_sockaddr_in
+ 
+-type sysInetPktinfo C.struct_in_pktinfo
++type inetPktinfo C.struct_in_pktinfo
+ 
+-type sysIPMreq C.struct_ip_mreq
++type ipMreq C.struct_ip_mreq
+ 
+-type sysIPMreqn C.struct_ip_mreqn
++type ipMreqn C.struct_ip_mreqn
+ 
+-type sysIPMreqSource C.struct_ip_mreq_source
++type ipMreqSource C.struct_ip_mreq_source
+ 
+-type sysGroupReq C.struct_group_req
++type groupReq C.struct_group_req
+ 
+-type sysGroupSourceReq C.struct_group_source_req
++type groupSourceReq C.struct_group_source_req
+diff -uNr go-net.old/ipv4/defs_dragonfly.go go-net/ipv4/defs_dragonfly.go
+--- go-net.old/ipv4/defs_dragonfly.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/defs_dragonfly.go	2018-05-30 21:01:01.910196139 +0200
+@@ -32,7 +32,7 @@
+ 	sysIP_ADD_MEMBERSHIP  = C.IP_ADD_MEMBERSHIP
+ 	sysIP_DROP_MEMBERSHIP = C.IP_DROP_MEMBERSHIP
+ 
+-	sysSizeofIPMreq = C.sizeof_struct_ip_mreq
++	sizeofIPMreq = C.sizeof_struct_ip_mreq
+ )
+ 
+-type sysIPMreq C.struct_ip_mreq
++type ipMreq C.struct_ip_mreq
+diff -uNr go-net.old/ipv4/defs_freebsd.go go-net/ipv4/defs_freebsd.go
+--- go-net.old/ipv4/defs_freebsd.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/defs_freebsd.go	2018-05-30 21:01:01.914196053 +0200
+@@ -50,26 +50,26 @@
+ 	sysMCAST_BLOCK_SOURCE        = C.MCAST_BLOCK_SOURCE
+ 	sysMCAST_UNBLOCK_SOURCE      = C.MCAST_UNBLOCK_SOURCE
+ 
+-	sysSizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
+-	sysSizeofSockaddrInet    = C.sizeof_struct_sockaddr_in
++	sizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
++	sizeofSockaddrInet    = C.sizeof_struct_sockaddr_in
+ 
+-	sysSizeofIPMreq         = C.sizeof_struct_ip_mreq
+-	sysSizeofIPMreqn        = C.sizeof_struct_ip_mreqn
+-	sysSizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
+-	sysSizeofGroupReq       = C.sizeof_struct_group_req
+-	sysSizeofGroupSourceReq = C.sizeof_struct_group_source_req
++	sizeofIPMreq         = C.sizeof_struct_ip_mreq
++	sizeofIPMreqn        = C.sizeof_struct_ip_mreqn
++	sizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
+ )
+ 
+-type sysSockaddrStorage C.struct_sockaddr_storage
++type sockaddrStorage C.struct_sockaddr_storage
+ 
+-type sysSockaddrInet C.struct_sockaddr_in
++type sockaddrInet C.struct_sockaddr_in
+ 
+-type sysIPMreq C.struct_ip_mreq
++type ipMreq C.struct_ip_mreq
+ 
+-type sysIPMreqn C.struct_ip_mreqn
++type ipMreqn C.struct_ip_mreqn
+ 
+-type sysIPMreqSource C.struct_ip_mreq_source
++type ipMreqSource C.struct_ip_mreq_source
+ 
+-type sysGroupReq C.struct_group_req
++type groupReq C.struct_group_req
+ 
+-type sysGroupSourceReq C.struct_group_source_req
++type groupSourceReq C.struct_group_source_req
+diff -uNr go-net.old/ipv4/defs_linux.go go-net/ipv4/defs_linux.go
+--- go-net.old/ipv4/defs_linux.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/defs_linux.go	2018-05-30 21:01:01.914196053 +0200
+@@ -14,6 +14,8 @@
+ #include <linux/errqueue.h>
+ #include <linux/icmp.h>
+ #include <linux/in.h>
++#include <linux/filter.h>
++#include <sys/socket.h>
+ */
+ import "C"
+ 
+@@ -76,36 +78,45 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = C.SO_EE_ORIGIN_TXSTATUS
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = C.SO_EE_ORIGIN_TIMESTAMPING
+ 
+-	sysSizeofKernelSockaddrStorage = C.sizeof_struct___kernel_sockaddr_storage
+-	sysSizeofSockaddrInet          = C.sizeof_struct_sockaddr_in
+-	sysSizeofInetPktinfo           = C.sizeof_struct_in_pktinfo
+-	sysSizeofSockExtendedErr       = C.sizeof_struct_sock_extended_err
+-
+-	sysSizeofIPMreq         = C.sizeof_struct_ip_mreq
+-	sysSizeofIPMreqn        = C.sizeof_struct_ip_mreqn
+-	sysSizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
+-	sysSizeofGroupReq       = C.sizeof_struct_group_req
+-	sysSizeofGroupSourceReq = C.sizeof_struct_group_source_req
++	sysSOL_SOCKET       = C.SOL_SOCKET
++	sysSO_ATTACH_FILTER = C.SO_ATTACH_FILTER
+ 
+-	sysSizeofICMPFilter = C.sizeof_struct_icmp_filter
++	sizeofKernelSockaddrStorage = C.sizeof_struct___kernel_sockaddr_storage
++	sizeofSockaddrInet          = C.sizeof_struct_sockaddr_in
++	sizeofInetPktinfo           = C.sizeof_struct_in_pktinfo
++	sizeofSockExtendedErr       = C.sizeof_struct_sock_extended_err
++
++	sizeofIPMreq         = C.sizeof_struct_ip_mreq
++	sizeofIPMreqn        = C.sizeof_struct_ip_mreqn
++	sizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
++
++	sizeofICMPFilter = C.sizeof_struct_icmp_filter
++
++	sizeofSockFprog = C.sizeof_struct_sock_fprog
+ )
+ 
+-type sysKernelSockaddrStorage C.struct___kernel_sockaddr_storage
++type kernelSockaddrStorage C.struct___kernel_sockaddr_storage
++
++type sockaddrInet C.struct_sockaddr_in
++
++type inetPktinfo C.struct_in_pktinfo
+ 
+-type sysSockaddrInet C.struct_sockaddr_in
++type sockExtendedErr C.struct_sock_extended_err
+ 
+-type sysInetPktinfo C.struct_in_pktinfo
++type ipMreq C.struct_ip_mreq
+ 
+-type sysSockExtendedErr C.struct_sock_extended_err
++type ipMreqn C.struct_ip_mreqn
+ 
+-type sysIPMreq C.struct_ip_mreq
++type ipMreqSource C.struct_ip_mreq_source
+ 
+-type sysIPMreqn C.struct_ip_mreqn
++type groupReq C.struct_group_req
+ 
+-type sysIPMreqSource C.struct_ip_mreq_source
++type groupSourceReq C.struct_group_source_req
+ 
+-type sysGroupReq C.struct_group_req
++type icmpFilter C.struct_icmp_filter
+ 
+-type sysGroupSourceReq C.struct_group_source_req
++type sockFProg C.struct_sock_fprog
+ 
+-type sysICMPFilter C.struct_icmp_filter
++type sockFilter C.struct_sock_filter
+diff -uNr go-net.old/ipv4/defs_netbsd.go go-net/ipv4/defs_netbsd.go
+--- go-net.old/ipv4/defs_netbsd.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/defs_netbsd.go	2018-05-30 21:01:01.914196053 +0200
+@@ -31,7 +31,7 @@
+ 	sysIP_ADD_MEMBERSHIP  = C.IP_ADD_MEMBERSHIP
+ 	sysIP_DROP_MEMBERSHIP = C.IP_DROP_MEMBERSHIP
+ 
+-	sysSizeofIPMreq = C.sizeof_struct_ip_mreq
++	sizeofIPMreq = C.sizeof_struct_ip_mreq
+ )
+ 
+-type sysIPMreq C.struct_ip_mreq
++type ipMreq C.struct_ip_mreq
+diff -uNr go-net.old/ipv4/defs_openbsd.go go-net/ipv4/defs_openbsd.go
+--- go-net.old/ipv4/defs_openbsd.go	2018-05-31 12:15:09.592224493 +0200
++++ go-net/ipv4/defs_openbsd.go	2018-05-30 21:01:01.914196053 +0200
+@@ -31,7 +31,7 @@
+ 	sysIP_ADD_MEMBERSHIP  = C.IP_ADD_MEMBERSHIP
+ 	sysIP_DROP_MEMBERSHIP = C.IP_DROP_MEMBERSHIP
+ 
+-	sysSizeofIPMreq = C.sizeof_struct_ip_mreq
++	sizeofIPMreq = C.sizeof_struct_ip_mreq
+ )
+ 
+-type sysIPMreq C.struct_ip_mreq
++type ipMreq C.struct_ip_mreq
+diff -uNr go-net.old/ipv4/defs_solaris.go go-net/ipv4/defs_solaris.go
+--- go-net.old/ipv4/defs_solaris.go	2018-05-31 12:15:22.167956990 +0200
++++ go-net/ipv4/defs_solaris.go	2018-05-30 21:01:01.914196053 +0200
+@@ -9,30 +9,24 @@
+ package ipv4
+ 
+ /*
++#include <sys/socket.h>
++
+ #include <netinet/in.h>
+ */
+ import "C"
+ 
+ const (
+-	sysIP_OPTIONS       = C.IP_OPTIONS
+-	sysIP_HDRINCL       = C.IP_HDRINCL
+-	sysIP_TOS           = C.IP_TOS
+-	sysIP_TTL           = C.IP_TTL
+-	sysIP_RECVOPTS      = C.IP_RECVOPTS
+-	sysIP_RECVRETOPTS   = C.IP_RECVRETOPTS
+-	sysIP_RECVDSTADDR   = C.IP_RECVDSTADDR
+-	sysIP_RETOPTS       = C.IP_RETOPTS
+-	sysIP_RECVIF        = C.IP_RECVIF
+-	sysIP_RECVSLLA      = C.IP_RECVSLLA
+-	sysIP_RECVTTL       = C.IP_RECVTTL
+-	sysIP_NEXTHOP       = C.IP_NEXTHOP
+-	sysIP_PKTINFO       = C.IP_PKTINFO
+-	sysIP_RECVPKTINFO   = C.IP_RECVPKTINFO
+-	sysIP_DONTFRAG      = C.IP_DONTFRAG
+-	sysIP_BOUND_IF      = C.IP_BOUND_IF
+-	sysIP_UNSPEC_SRC    = C.IP_UNSPEC_SRC
+-	sysIP_BROADCAST_TTL = C.IP_BROADCAST_TTL
+-	sysIP_DHCPINIT_IF   = C.IP_DHCPINIT_IF
++	sysIP_OPTIONS     = C.IP_OPTIONS
++	sysIP_HDRINCL     = C.IP_HDRINCL
++	sysIP_TOS         = C.IP_TOS
++	sysIP_TTL         = C.IP_TTL
++	sysIP_RECVOPTS    = C.IP_RECVOPTS
++	sysIP_RECVRETOPTS = C.IP_RECVRETOPTS
++	sysIP_RECVDSTADDR = C.IP_RECVDSTADDR
++	sysIP_RETOPTS     = C.IP_RETOPTS
++	sysIP_RECVIF      = C.IP_RECVIF
++	sysIP_RECVSLLA    = C.IP_RECVSLLA
++	sysIP_RECVTTL     = C.IP_RECVTTL
+ 
+ 	sysIP_MULTICAST_IF           = C.IP_MULTICAST_IF
+ 	sysIP_MULTICAST_TTL          = C.IP_MULTICAST_TTL
+@@ -43,15 +37,48 @@
+ 	sysIP_UNBLOCK_SOURCE         = C.IP_UNBLOCK_SOURCE
+ 	sysIP_ADD_SOURCE_MEMBERSHIP  = C.IP_ADD_SOURCE_MEMBERSHIP
+ 	sysIP_DROP_SOURCE_MEMBERSHIP = C.IP_DROP_SOURCE_MEMBERSHIP
++	sysIP_NEXTHOP                = C.IP_NEXTHOP
++
++	sysIP_PKTINFO     = C.IP_PKTINFO
++	sysIP_RECVPKTINFO = C.IP_RECVPKTINFO
++	sysIP_DONTFRAG    = C.IP_DONTFRAG
+ 
+-	sysSizeofInetPktinfo = C.sizeof_struct_in_pktinfo
++	sysIP_BOUND_IF      = C.IP_BOUND_IF
++	sysIP_UNSPEC_SRC    = C.IP_UNSPEC_SRC
++	sysIP_BROADCAST_TTL = C.IP_BROADCAST_TTL
++	sysIP_DHCPINIT_IF   = C.IP_DHCPINIT_IF
+ 
+-	sysSizeofIPMreq       = C.sizeof_struct_ip_mreq
+-	sysSizeofIPMreqSource = C.sizeof_struct_ip_mreq_source
++	sysIP_REUSEADDR = C.IP_REUSEADDR
++	sysIP_DONTROUTE = C.IP_DONTROUTE
++	sysIP_BROADCAST = C.IP_BROADCAST
++
++	sysMCAST_JOIN_GROUP         = C.MCAST_JOIN_GROUP
++	sysMCAST_LEAVE_GROUP        = C.MCAST_LEAVE_GROUP
++	sysMCAST_BLOCK_SOURCE       = C.MCAST_BLOCK_SOURCE
++	sysMCAST_UNBLOCK_SOURCE     = C.MCAST_UNBLOCK_SOURCE
++	sysMCAST_JOIN_SOURCE_GROUP  = C.MCAST_JOIN_SOURCE_GROUP
++	sysMCAST_LEAVE_SOURCE_GROUP = C.MCAST_LEAVE_SOURCE_GROUP
++
++	sizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
++	sizeofSockaddrInet    = C.sizeof_struct_sockaddr_in
++	sizeofInetPktinfo     = C.sizeof_struct_in_pktinfo
++
++	sizeofIPMreq         = C.sizeof_struct_ip_mreq
++	sizeofIPMreqSource   = C.sizeof_struct_ip_mreq_source
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
+ )
+ 
+-type sysInetPktinfo C.struct_in_pktinfo
++type sockaddrStorage C.struct_sockaddr_storage
++
++type sockaddrInet C.struct_sockaddr_in
++
++type inetPktinfo C.struct_in_pktinfo
++
++type ipMreq C.struct_ip_mreq
++
++type ipMreqSource C.struct_ip_mreq_source
+ 
+-type sysIPMreq C.struct_ip_mreq
++type groupReq C.struct_group_req
+ 
+-type sysIPMreqSource C.struct_ip_mreq_source
++type groupSourceReq C.struct_group_source_req
+diff -uNr go-net.old/ipv4/dgramopt.go go-net/ipv4/dgramopt.go
+--- go-net.old/ipv4/dgramopt.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/dgramopt.go	2018-05-30 21:01:01.914196053 +0200
+@@ -0,0 +1,265 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv4
++
++import (
++	"net"
++	"syscall"
++
++	"golang.org/x/net/bpf"
++)
++
++// MulticastTTL returns the time-to-live field value for outgoing
++// multicast packets.
++func (c *dgramOpt) MulticastTTL() (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastTTL]
++	if !ok {
++		return 0, errOpNoSupport
++	}
++	return so.GetInt(c.Conn)
++}
++
++// SetMulticastTTL sets the time-to-live field value for future
++// outgoing multicast packets.
++func (c *dgramOpt) SetMulticastTTL(ttl int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastTTL]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, ttl)
++}
++
++// MulticastInterface returns the default interface for multicast
++// packet transmissions.
++func (c *dgramOpt) MulticastInterface() (*net.Interface, error) {
++	if !c.ok() {
++		return nil, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastInterface]
++	if !ok {
++		return nil, errOpNoSupport
++	}
++	return so.getMulticastInterface(c.Conn)
++}
++
++// SetMulticastInterface sets the default interface for future
++// multicast packet transmissions.
++func (c *dgramOpt) SetMulticastInterface(ifi *net.Interface) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastInterface]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.setMulticastInterface(c.Conn, ifi)
++}
++
++// MulticastLoopback reports whether transmitted multicast packets
++// should be copied and send back to the originator.
++func (c *dgramOpt) MulticastLoopback() (bool, error) {
++	if !c.ok() {
++		return false, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastLoopback]
++	if !ok {
++		return false, errOpNoSupport
++	}
++	on, err := so.GetInt(c.Conn)
++	if err != nil {
++		return false, err
++	}
++	return on == 1, nil
++}
++
++// SetMulticastLoopback sets whether transmitted multicast packets
++// should be copied and send back to the originator.
++func (c *dgramOpt) SetMulticastLoopback(on bool) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastLoopback]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, boolint(on))
++}
++
++// JoinGroup joins the group address group on the interface ifi.
++// By default all sources that can cast data to group are accepted.
++// It's possible to mute and unmute data transmission from a specific
++// source by using ExcludeSourceSpecificGroup and
++// IncludeSourceSpecificGroup.
++// JoinGroup uses the system assigned multicast interface when ifi is
++// nil, although this is not recommended because the assignment
++// depends on platforms and sometimes it might require routing
++// configuration.
++func (c *dgramOpt) JoinGroup(ifi *net.Interface, group net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoJoinGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP4(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	return so.setGroup(c.Conn, ifi, grp)
++}
++
++// LeaveGroup leaves the group address group on the interface ifi
++// regardless of whether the group is any-source group or
++// source-specific group.
++func (c *dgramOpt) LeaveGroup(ifi *net.Interface, group net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoLeaveGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP4(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	return so.setGroup(c.Conn, ifi, grp)
++}
++
++// JoinSourceSpecificGroup joins the source-specific group comprising
++// group and source on the interface ifi.
++// JoinSourceSpecificGroup uses the system assigned multicast
++// interface when ifi is nil, although this is not recommended because
++// the assignment depends on platforms and sometimes it might require
++// routing configuration.
++func (c *dgramOpt) JoinSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoJoinSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP4(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP4(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// LeaveSourceSpecificGroup leaves the source-specific group on the
++// interface ifi.
++func (c *dgramOpt) LeaveSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoLeaveSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP4(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP4(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// ExcludeSourceSpecificGroup excludes the source-specific group from
++// the already joined any-source groups by JoinGroup on the interface
++// ifi.
++func (c *dgramOpt) ExcludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoBlockSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP4(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP4(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// IncludeSourceSpecificGroup includes the excluded source-specific
++// group by ExcludeSourceSpecificGroup again on the interface ifi.
++func (c *dgramOpt) IncludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoUnblockSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP4(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP4(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// ICMPFilter returns an ICMP filter.
++// Currently only Linux supports this.
++func (c *dgramOpt) ICMPFilter() (*ICMPFilter, error) {
++	if !c.ok() {
++		return nil, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoICMPFilter]
++	if !ok {
++		return nil, errOpNoSupport
++	}
++	return so.getICMPFilter(c.Conn)
++}
++
++// SetICMPFilter deploys the ICMP filter.
++// Currently only Linux supports this.
++func (c *dgramOpt) SetICMPFilter(f *ICMPFilter) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoICMPFilter]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.setICMPFilter(c.Conn, f)
++}
++
++// SetBPF attaches a BPF program to the connection.
++//
++// Only supported on Linux.
++func (c *dgramOpt) SetBPF(filter []bpf.RawInstruction) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoAttachFilter]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.setBPF(c.Conn, filter)
++}
+diff -uNr go-net.old/ipv4/doc.go go-net/ipv4/doc.go
+--- go-net.old/ipv4/doc.go	2018-05-31 12:15:22.171956905 +0200
++++ go-net/ipv4/doc.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -21,10 +21,10 @@
+ //
+ // The options for unicasting are available for net.TCPConn,
+ // net.UDPConn and net.IPConn which are created as network connections
+-// that use the IPv4 transport.  When a single TCP connection carrying
++// that use the IPv4 transport. When a single TCP connection carrying
+ // a data flow of multiple packets needs to indicate the flow is
+-// important, ipv4.Conn is used to set the type-of-service field on
+-// the IPv4 header for each packet.
++// important, Conn is used to set the type-of-service field on the
++// IPv4 header for each packet.
+ //
+ //	ln, err := net.Listen("tcp4", "0.0.0.0:1024")
+ //	if err != nil {
+@@ -56,7 +56,7 @@
+ //
+ // The options for multicasting are available for net.UDPConn and
+ // net.IPconn which are created as network connections that use the
+-// IPv4 transport.  A few network facilities must be prepared before
++// IPv4 transport. A few network facilities must be prepared before
+ // you begin multicasting, at a minimum joining network interfaces and
+ // multicast groups.
+ //
+@@ -80,7 +80,7 @@
+ //	defer c.Close()
+ //
+ // Second, the application joins multicast groups, starts listening to
+-// the groups on the specified network interfaces.  Note that the
++// the groups on the specified network interfaces. Note that the
+ // service port for transport layer protocol does not matter with this
+ // operation as joining groups affects only network and link layer
+ // protocols, such as IPv4 and Ethernet.
+@@ -94,10 +94,10 @@
+ //	}
+ //
+ // The application might set per packet control message transmissions
+-// between the protocol stack within the kernel.  When the application
++// between the protocol stack within the kernel. When the application
+ // needs a destination address on an incoming packet,
+-// SetControlMessage of ipv4.PacketConn is used to enable control
+-// message transmissons.
++// SetControlMessage of PacketConn is used to enable control message
++// transmissions.
+ //
+ //	if err := p.SetControlMessage(ipv4.FlagDst, true); err != nil {
+ //		// error handling
+@@ -145,7 +145,7 @@
+ // More multicasting
+ //
+ // An application that uses PacketConn or RawConn may join multiple
+-// multicast groups.  For example, a UDP listener with port 1024 might
++// multicast groups. For example, a UDP listener with port 1024 might
+ // join two different groups across over two different network
+ // interfaces by using:
+ //
+@@ -166,7 +166,7 @@
+ //	}
+ //
+ // It is possible for multiple UDP listeners that listen on the same
+-// UDP port to join the same multicast group.  The net package will
++// UDP port to join the same multicast group. The net package will
+ // provide a socket that listens to a wildcard address with reusable
+ // UDP port when an appropriate multicast address prefix is passed to
+ // the net.ListenPacket or net.ListenUDP.
+@@ -239,4 +239,6 @@
+ // IGMPv1 or IGMPv2 and starts to listen to multicast traffic.
+ // In the fallback case, ExcludeSourceSpecificGroup and
+ // IncludeSourceSpecificGroup may return an error.
+-package ipv4
++package ipv4 // import "golang.org/x/net/ipv4"
++
++// BUG(mikio): This package is not implemented on NaCl and Plan 9.
+diff -uNr go-net.old/ipv4/endpoint.go go-net/ipv4/endpoint.go
+--- go-net.old/ipv4/endpoint.go	2018-05-31 12:15:22.171956905 +0200
++++ go-net/ipv4/endpoint.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -8,8 +8,15 @@
+ 	"net"
+ 	"syscall"
+ 	"time"
++
++	"golang.org/x/net/internal/socket"
+ )
+ 
++// BUG(mikio): On Windows, the JoinSourceSpecificGroup,
++// LeaveSourceSpecificGroup, ExcludeSourceSpecificGroup and
++// IncludeSourceSpecificGroup methods of PacketConn and RawConn are
++// not implemented.
++
+ // A Conn represents a network endpoint that uses the IPv4 transport.
+ // It is used to control basic IP-level socket options such as TOS and
+ // TTL.
+@@ -18,21 +25,22 @@
+ }
+ 
+ type genericOpt struct {
+-	net.Conn
++	*socket.Conn
+ }
+ 
+ func (c *genericOpt) ok() bool { return c != nil && c.Conn != nil }
+ 
+ // NewConn returns a new Conn.
+ func NewConn(c net.Conn) *Conn {
++	cc, _ := socket.NewConn(c)
+ 	return &Conn{
+-		genericOpt: genericOpt{Conn: c},
++		genericOpt: genericOpt{Conn: cc},
+ 	}
+ }
+ 
+ // A PacketConn represents a packet network endpoint that uses the
+-// IPv4 transport.  It is used to control several IP-level socket
+-// options including multicasting.  It also provides datagram based
++// IPv4 transport. It is used to control several IP-level socket
++// options including multicasting. It also provides datagram based
+ // network I/O methods specific to the IPv4 and higher layer protocols
+ // such as UDP.
+ type PacketConn struct {
+@@ -42,21 +50,17 @@
+ }
+ 
+ type dgramOpt struct {
+-	net.PacketConn
++	*socket.Conn
+ }
+ 
+-func (c *dgramOpt) ok() bool { return c != nil && c.PacketConn != nil }
++func (c *dgramOpt) ok() bool { return c != nil && c.Conn != nil }
+ 
+ // SetControlMessage sets the per packet IP-level socket options.
+ func (c *PacketConn) SetControlMessage(cf ControlFlags, on bool) error {
+ 	if !c.payloadHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	fd, err := c.payloadHandler.sysfd()
+-	if err != nil {
+-		return err
+-	}
+-	return setControlMessage(fd, &c.payloadHandler.rawOpt, cf, on)
++	return setControlMessage(c.dgramOpt.Conn, &c.payloadHandler.rawOpt, cf, on)
+ }
+ 
+ // SetDeadline sets the read and write deadlines associated with the
+@@ -97,22 +101,18 @@
+ // NewPacketConn returns a new PacketConn using c as its underlying
+ // transport.
+ func NewPacketConn(c net.PacketConn) *PacketConn {
++	cc, _ := socket.NewConn(c.(net.Conn))
+ 	p := &PacketConn{
+-		genericOpt:     genericOpt{Conn: c.(net.Conn)},
+-		dgramOpt:       dgramOpt{PacketConn: c},
+-		payloadHandler: payloadHandler{PacketConn: c},
+-	}
+-	if _, ok := c.(*net.IPConn); ok && sockOpts[ssoStripHeader].name > 0 {
+-		if fd, err := p.payloadHandler.sysfd(); err == nil {
+-			setInt(fd, &sockOpts[ssoStripHeader], boolint(true))
+-		}
++		genericOpt:     genericOpt{Conn: cc},
++		dgramOpt:       dgramOpt{Conn: cc},
++		payloadHandler: payloadHandler{PacketConn: c, Conn: cc},
+ 	}
+ 	return p
+ }
+ 
+ // A RawConn represents a packet network endpoint that uses the IPv4
+-// transport.  It is used to control several IP-level socket options
+-// including IPv4 header manipulation.  It also provides datagram
++// transport. It is used to control several IP-level socket options
++// including IPv4 header manipulation. It also provides datagram
+ // based network I/O methods specific to the IPv4 and higher layer
+ // protocols that handle IPv4 datagram directly such as OSPF, GRE.
+ type RawConn struct {
+@@ -126,11 +126,7 @@
+ 	if !c.packetHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	fd, err := c.packetHandler.sysfd()
+-	if err != nil {
+-		return err
+-	}
+-	return setControlMessage(fd, &c.packetHandler.rawOpt, cf, on)
++	return setControlMessage(c.dgramOpt.Conn, &c.packetHandler.rawOpt, cf, on)
+ }
+ 
+ // SetDeadline sets the read and write deadlines associated with the
+@@ -139,7 +135,7 @@
+ 	if !c.packetHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	return c.packetHandler.c.SetDeadline(t)
++	return c.packetHandler.IPConn.SetDeadline(t)
+ }
+ 
+ // SetReadDeadline sets the read deadline associated with the
+@@ -148,7 +144,7 @@
+ 	if !c.packetHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	return c.packetHandler.c.SetReadDeadline(t)
++	return c.packetHandler.IPConn.SetReadDeadline(t)
+ }
+ 
+ // SetWriteDeadline sets the write deadline associated with the
+@@ -157,7 +153,7 @@
+ 	if !c.packetHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	return c.packetHandler.c.SetWriteDeadline(t)
++	return c.packetHandler.IPConn.SetWriteDeadline(t)
+ }
+ 
+ // Close closes the endpoint.
+@@ -165,22 +161,26 @@
+ 	if !c.packetHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	return c.packetHandler.c.Close()
++	return c.packetHandler.IPConn.Close()
+ }
+ 
+ // NewRawConn returns a new RawConn using c as its underlying
+ // transport.
+ func NewRawConn(c net.PacketConn) (*RawConn, error) {
+-	r := &RawConn{
+-		genericOpt:    genericOpt{Conn: c.(net.Conn)},
+-		dgramOpt:      dgramOpt{PacketConn: c},
+-		packetHandler: packetHandler{c: c.(*net.IPConn)},
+-	}
+-	fd, err := r.packetHandler.sysfd()
++	cc, err := socket.NewConn(c.(net.Conn))
+ 	if err != nil {
+ 		return nil, err
+ 	}
+-	if err := setInt(fd, &sockOpts[ssoHeaderPrepend], boolint(true)); err != nil {
++	r := &RawConn{
++		genericOpt:    genericOpt{Conn: cc},
++		dgramOpt:      dgramOpt{Conn: cc},
++		packetHandler: packetHandler{IPConn: c.(*net.IPConn), Conn: cc},
++	}
++	so, ok := sockOpts[ssoHeaderPrepend]
++	if !ok {
++		return nil, errOpNoSupport
++	}
++	if err := so.SetInt(r.dgramOpt.Conn, boolint(true)); err != nil {
+ 		return nil, err
+ 	}
+ 	return r, nil
+diff -uNr go-net.old/ipv4/example_test.go go-net/ipv4/example_test.go
+--- go-net.old/ipv4/example_test.go	2018-05-31 12:15:35.379675954 +0200
++++ go-net/ipv4/example_test.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,12 +12,12 @@
+ 	"runtime"
+ 	"time"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/icmp"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/icmp"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ func ExampleConn_markingTCP() {
+-	ln, err := net.Listen("tcp4", "0.0.0.0:1024")
++	ln, err := net.Listen("tcp", "0.0.0.0:1024")
+ 	if err != nil {
+ 		log.Fatal(err)
+ 	}
+@@ -30,12 +30,14 @@
+ 		}
+ 		go func(c net.Conn) {
+ 			defer c.Close()
+-			p := ipv4.NewConn(c)
+-			if err := p.SetTOS(0x28); err != nil { // DSCP AF11
+-				log.Fatal(err)
+-			}
+-			if err := p.SetTTL(128); err != nil {
+-				log.Fatal(err)
++			if c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {
++				p := ipv4.NewConn(c)
++				if err := p.SetTOS(0x28); err != nil { // DSCP AF11
++					log.Fatal(err)
++				}
++				if err := p.SetTTL(128); err != nil {
++					log.Fatal(err)
++				}
+ 			}
+ 			if _, err := c.Write([]byte("HELLO-R-U-THERE-ACK")); err != nil {
+ 				log.Fatal(err)
+diff -uNr go-net.old/ipv4/genericopt.go go-net/ipv4/genericopt.go
+--- go-net.old/ipv4/genericopt.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/genericopt.go	2018-05-30 21:01:01.914196053 +0200
+@@ -0,0 +1,57 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv4
++
++import "syscall"
++
++// TOS returns the type-of-service field value for outgoing packets.
++func (c *genericOpt) TOS() (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoTOS]
++	if !ok {
++		return 0, errOpNoSupport
++	}
++	return so.GetInt(c.Conn)
++}
++
++// SetTOS sets the type-of-service field value for future outgoing
++// packets.
++func (c *genericOpt) SetTOS(tos int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoTOS]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, tos)
++}
++
++// TTL returns the time-to-live field value for outgoing packets.
++func (c *genericOpt) TTL() (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoTTL]
++	if !ok {
++		return 0, errOpNoSupport
++	}
++	return so.GetInt(c.Conn)
++}
++
++// SetTTL sets the time-to-live field value for future outgoing
++// packets.
++func (c *genericOpt) SetTTL(ttl int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoTTL]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, ttl)
++}
+diff -uNr go-net.old/ipv4/gen.go go-net/ipv4/gen.go
+--- go-net.old/ipv4/gen.go	2018-05-31 12:15:22.195956395 +0200
++++ go-net/ipv4/gen.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -52,15 +52,6 @@
+ 	if err != nil {
+ 		return err
+ 	}
+-	// The ipv4 pacakge still supports go1.2, and so we need to
+-	// take care of additional platforms in go1.3 and above for
+-	// working with go1.2.
+-	switch {
+-	case runtime.GOOS == "dragonfly" || runtime.GOOS == "solaris":
+-		b = bytes.Replace(b, []byte("package ipv4\n"), []byte("// +build "+runtime.GOOS+"\n\npackage ipv4\n"), 1)
+-	case runtime.GOOS == "linux" && (runtime.GOARCH == "arm64" || runtime.GOARCH == "ppc64" || runtime.GOARCH == "ppc64le"):
+-		b = bytes.Replace(b, []byte("package ipv4\n"), []byte("// +build "+runtime.GOOS+","+runtime.GOARCH+"\n\npackage ipv4\n"), 1)
+-	}
+ 	b, err = format.Source(b)
+ 	if err != nil {
+ 		return err
+@@ -81,7 +72,7 @@
+ 	parse func(io.Writer, io.Reader) error
+ }{
+ 	{
+-		"http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xml",
++		"https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xml",
+ 		parseICMPv4Parameters,
+ 	},
+ }
+@@ -89,7 +80,7 @@
+ func geniana() error {
+ 	var bb bytes.Buffer
+ 	fmt.Fprintf(&bb, "// go generate gen.go\n")
+-	fmt.Fprintf(&bb, "// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n\n")
++	fmt.Fprintf(&bb, "// Code generated by the command above; DO NOT EDIT.\n\n")
+ 	fmt.Fprintf(&bb, "package ipv4\n\n")
+ 	for _, r := range registries {
+ 		resp, err := http.Get(r.url)
+diff -uNr go-net.old/ipv4/header.go go-net/ipv4/header.go
+--- go-net.old/ipv4/header.go	2018-05-31 12:15:22.195956395 +0200
++++ go-net/ipv4/header.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,15 +1,17 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv4
+ 
+ import (
++	"encoding/binary"
+ 	"fmt"
+ 	"net"
+ 	"runtime"
+ 	"syscall"
+-	"unsafe"
++
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ const (
+@@ -49,7 +51,7 @@
+ 	return fmt.Sprintf("ver=%d hdrlen=%d tos=%#x totallen=%d id=%#x flags=%#x fragoff=%#x ttl=%d proto=%d cksum=%#x src=%v dst=%v", h.Version, h.Len, h.TOS, h.TotalLen, h.ID, h.Flags, h.FragOff, h.TTL, h.Protocol, h.Checksum, h.Src, h.Dst)
+ }
+ 
+-// Marshal returns the binary encoding of the IPv4 header h.
++// Marshal returns the binary encoding of h.
+ func (h *Header) Marshal() ([]byte, error) {
+ 	if h == nil {
+ 		return nil, syscall.EINVAL
+@@ -63,18 +65,25 @@
+ 	b[1] = byte(h.TOS)
+ 	flagsAndFragOff := (h.FragOff & 0x1fff) | int(h.Flags<<13)
+ 	switch runtime.GOOS {
+-	case "darwin", "dragonfly", "freebsd", "netbsd":
+-		// TODO(mikio): fix potential misaligned memory access
+-		*(*uint16)(unsafe.Pointer(&b[2:3][0])) = uint16(h.TotalLen)
+-		*(*uint16)(unsafe.Pointer(&b[6:7][0])) = uint16(flagsAndFragOff)
++	case "darwin", "dragonfly", "netbsd":
++		socket.NativeEndian.PutUint16(b[2:4], uint16(h.TotalLen))
++		socket.NativeEndian.PutUint16(b[6:8], uint16(flagsAndFragOff))
++	case "freebsd":
++		if freebsdVersion < 1100000 {
++			socket.NativeEndian.PutUint16(b[2:4], uint16(h.TotalLen))
++			socket.NativeEndian.PutUint16(b[6:8], uint16(flagsAndFragOff))
++		} else {
++			binary.BigEndian.PutUint16(b[2:4], uint16(h.TotalLen))
++			binary.BigEndian.PutUint16(b[6:8], uint16(flagsAndFragOff))
++		}
+ 	default:
+-		b[2], b[3] = byte(h.TotalLen>>8), byte(h.TotalLen)
+-		b[6], b[7] = byte(flagsAndFragOff>>8), byte(flagsAndFragOff)
++		binary.BigEndian.PutUint16(b[2:4], uint16(h.TotalLen))
++		binary.BigEndian.PutUint16(b[6:8], uint16(flagsAndFragOff))
+ 	}
+-	b[4], b[5] = byte(h.ID>>8), byte(h.ID)
++	binary.BigEndian.PutUint16(b[4:6], uint16(h.ID))
+ 	b[8] = byte(h.TTL)
+ 	b[9] = byte(h.Protocol)
+-	b[10], b[11] = byte(h.Checksum>>8), byte(h.Checksum)
++	binary.BigEndian.PutUint16(b[10:12], uint16(h.Checksum))
+ 	if ip := h.Src.To4(); ip != nil {
+ 		copy(b[12:16], ip[:net.IPv4len])
+ 	}
+@@ -89,52 +98,62 @@
+ 	return b, nil
+ }
+ 
+-// See http://www.freebsd.org/doc/en/books/porters-handbook/freebsd-versions.html.
+-var freebsdVersion uint32
+-
+-// ParseHeader parses b as an IPv4 header.
+-func ParseHeader(b []byte) (*Header, error) {
+-	if len(b) < HeaderLen {
+-		return nil, errHeaderTooShort
++// Parse parses b as an IPv4 header and stores the result in h.
++func (h *Header) Parse(b []byte) error {
++	if h == nil || len(b) < HeaderLen {
++		return errHeaderTooShort
+ 	}
+ 	hdrlen := int(b[0]&0x0f) << 2
+ 	if hdrlen > len(b) {
+-		return nil, errBufferTooShort
+-	}
+-	h := &Header{
+-		Version:  int(b[0] >> 4),
+-		Len:      hdrlen,
+-		TOS:      int(b[1]),
+-		ID:       int(b[4])<<8 | int(b[5]),
+-		TTL:      int(b[8]),
+-		Protocol: int(b[9]),
+-		Checksum: int(b[10])<<8 | int(b[11]),
+-		Src:      net.IPv4(b[12], b[13], b[14], b[15]),
+-		Dst:      net.IPv4(b[16], b[17], b[18], b[19]),
++		return errBufferTooShort
+ 	}
++	h.Version = int(b[0] >> 4)
++	h.Len = hdrlen
++	h.TOS = int(b[1])
++	h.ID = int(binary.BigEndian.Uint16(b[4:6]))
++	h.TTL = int(b[8])
++	h.Protocol = int(b[9])
++	h.Checksum = int(binary.BigEndian.Uint16(b[10:12]))
++	h.Src = net.IPv4(b[12], b[13], b[14], b[15])
++	h.Dst = net.IPv4(b[16], b[17], b[18], b[19])
+ 	switch runtime.GOOS {
+ 	case "darwin", "dragonfly", "netbsd":
+-		// TODO(mikio): fix potential misaligned memory access
+-		h.TotalLen = int(*(*uint16)(unsafe.Pointer(&b[2:3][0]))) + hdrlen
+-		// TODO(mikio): fix potential misaligned memory access
+-		h.FragOff = int(*(*uint16)(unsafe.Pointer(&b[6:7][0])))
++		h.TotalLen = int(socket.NativeEndian.Uint16(b[2:4])) + hdrlen
++		h.FragOff = int(socket.NativeEndian.Uint16(b[6:8]))
+ 	case "freebsd":
+-		// TODO(mikio): fix potential misaligned memory access
+-		h.TotalLen = int(*(*uint16)(unsafe.Pointer(&b[2:3][0])))
+-		if freebsdVersion < 1000000 {
+-			h.TotalLen += hdrlen
++		if freebsdVersion < 1100000 {
++			h.TotalLen = int(socket.NativeEndian.Uint16(b[2:4]))
++			if freebsdVersion < 1000000 {
++				h.TotalLen += hdrlen
++			}
++			h.FragOff = int(socket.NativeEndian.Uint16(b[6:8]))
++		} else {
++			h.TotalLen = int(binary.BigEndian.Uint16(b[2:4]))
++			h.FragOff = int(binary.BigEndian.Uint16(b[6:8]))
+ 		}
+-		// TODO(mikio): fix potential misaligned memory access
+-		h.FragOff = int(*(*uint16)(unsafe.Pointer(&b[6:7][0])))
+ 	default:
+-		h.TotalLen = int(b[2])<<8 | int(b[3])
+-		h.FragOff = int(b[6])<<8 | int(b[7])
++		h.TotalLen = int(binary.BigEndian.Uint16(b[2:4]))
++		h.FragOff = int(binary.BigEndian.Uint16(b[6:8]))
+ 	}
+ 	h.Flags = HeaderFlags(h.FragOff&0xe000) >> 13
+ 	h.FragOff = h.FragOff & 0x1fff
+-	if hdrlen-HeaderLen > 0 {
+-		h.Options = make([]byte, hdrlen-HeaderLen)
+-		copy(h.Options, b[HeaderLen:])
++	optlen := hdrlen - HeaderLen
++	if optlen > 0 && len(b) >= hdrlen {
++		if cap(h.Options) < optlen {
++			h.Options = make([]byte, optlen)
++		} else {
++			h.Options = h.Options[:optlen]
++		}
++		copy(h.Options, b[HeaderLen:hdrlen])
++	}
++	return nil
++}
++
++// ParseHeader parses b as an IPv4 header.
++func ParseHeader(b []byte) (*Header, error) {
++	h := new(Header)
++	if err := h.Parse(b); err != nil {
++		return nil, err
+ 	}
+ 	return h, nil
+ }
+diff -uNr go-net.old/ipv4/header_test.go go-net/ipv4/header_test.go
+--- go-net.old/ipv4/header_test.go	2018-05-31 12:15:22.195956395 +0200
++++ go-net/ipv4/header_test.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -6,114 +6,223 @@
+ 
+ import (
+ 	"bytes"
++	"encoding/binary"
+ 	"net"
+ 	"reflect"
+ 	"runtime"
+ 	"strings"
+ 	"testing"
++
++	"golang.org/x/net/internal/socket"
+ )
+ 
+-var (
+-	wireHeaderFromKernel = [HeaderLen]byte{
+-		0x45, 0x01, 0xbe, 0xef,
+-		0xca, 0xfe, 0x45, 0xdc,
+-		0xff, 0x01, 0xde, 0xad,
+-		172, 16, 254, 254,
+-		192, 168, 0, 1,
+-	}
+-	wireHeaderToKernel = [HeaderLen]byte{
+-		0x45, 0x01, 0xbe, 0xef,
+-		0xca, 0xfe, 0x45, 0xdc,
+-		0xff, 0x01, 0xde, 0xad,
+-		172, 16, 254, 254,
+-		192, 168, 0, 1,
+-	}
+-	wireHeaderFromTradBSDKernel = [HeaderLen]byte{
+-		0x45, 0x01, 0xdb, 0xbe,
+-		0xca, 0xfe, 0xdc, 0x45,
+-		0xff, 0x01, 0xde, 0xad,
+-		172, 16, 254, 254,
+-		192, 168, 0, 1,
+-	}
+-	wireHeaderFromFreeBSD10Kernel = [HeaderLen]byte{
+-		0x45, 0x01, 0xef, 0xbe,
+-		0xca, 0xfe, 0xdc, 0x45,
+-		0xff, 0x01, 0xde, 0xad,
+-		172, 16, 254, 254,
+-		192, 168, 0, 1,
+-	}
+-	wireHeaderToTradBSDKernel = [HeaderLen]byte{
+-		0x45, 0x01, 0xef, 0xbe,
+-		0xca, 0xfe, 0xdc, 0x45,
+-		0xff, 0x01, 0xde, 0xad,
+-		172, 16, 254, 254,
+-		192, 168, 0, 1,
+-	}
++type headerTest struct {
++	wireHeaderFromKernel          []byte
++	wireHeaderToKernel            []byte
++	wireHeaderFromTradBSDKernel   []byte
++	wireHeaderToTradBSDKernel     []byte
++	wireHeaderFromFreeBSD10Kernel []byte
++	wireHeaderToFreeBSD10Kernel   []byte
++	*Header
++}
++
++var headerLittleEndianTests = []headerTest{
+ 	// TODO(mikio): Add platform dependent wire header formats when
+ 	// we support new platforms.
+-
+-	testHeader = &Header{
+-		Version:  Version,
+-		Len:      HeaderLen,
+-		TOS:      1,
+-		TotalLen: 0xbeef,
+-		ID:       0xcafe,
+-		Flags:    DontFragment,
+-		FragOff:  1500,
+-		TTL:      255,
+-		Protocol: 1,
+-		Checksum: 0xdead,
+-		Src:      net.IPv4(172, 16, 254, 254),
+-		Dst:      net.IPv4(192, 168, 0, 1),
+-	}
+-)
++	{
++		wireHeaderFromKernel: []byte{
++			0x45, 0x01, 0xbe, 0xef,
++			0xca, 0xfe, 0x45, 0xdc,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++		},
++		wireHeaderToKernel: []byte{
++			0x45, 0x01, 0xbe, 0xef,
++			0xca, 0xfe, 0x45, 0xdc,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++		},
++		wireHeaderFromTradBSDKernel: []byte{
++			0x45, 0x01, 0xdb, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++		},
++		wireHeaderToTradBSDKernel: []byte{
++			0x45, 0x01, 0xef, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++		},
++		wireHeaderFromFreeBSD10Kernel: []byte{
++			0x45, 0x01, 0xef, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++		},
++		wireHeaderToFreeBSD10Kernel: []byte{
++			0x45, 0x01, 0xef, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++		},
++		Header: &Header{
++			Version:  Version,
++			Len:      HeaderLen,
++			TOS:      1,
++			TotalLen: 0xbeef,
++			ID:       0xcafe,
++			Flags:    DontFragment,
++			FragOff:  1500,
++			TTL:      255,
++			Protocol: 1,
++			Checksum: 0xdead,
++			Src:      net.IPv4(172, 16, 254, 254),
++			Dst:      net.IPv4(192, 168, 0, 1),
++		},
++	},
++
++	// with option headers
++	{
++		wireHeaderFromKernel: []byte{
++			0x46, 0x01, 0xbe, 0xf3,
++			0xca, 0xfe, 0x45, 0xdc,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++			0xff, 0xfe, 0xfe, 0xff,
++		},
++		wireHeaderToKernel: []byte{
++			0x46, 0x01, 0xbe, 0xf3,
++			0xca, 0xfe, 0x45, 0xdc,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++			0xff, 0xfe, 0xfe, 0xff,
++		},
++		wireHeaderFromTradBSDKernel: []byte{
++			0x46, 0x01, 0xdb, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++			0xff, 0xfe, 0xfe, 0xff,
++		},
++		wireHeaderToTradBSDKernel: []byte{
++			0x46, 0x01, 0xf3, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++			0xff, 0xfe, 0xfe, 0xff,
++		},
++		wireHeaderFromFreeBSD10Kernel: []byte{
++			0x46, 0x01, 0xf3, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++			0xff, 0xfe, 0xfe, 0xff,
++		},
++		wireHeaderToFreeBSD10Kernel: []byte{
++			0x46, 0x01, 0xf3, 0xbe,
++			0xca, 0xfe, 0xdc, 0x45,
++			0xff, 0x01, 0xde, 0xad,
++			172, 16, 254, 254,
++			192, 168, 0, 1,
++			0xff, 0xfe, 0xfe, 0xff,
++		},
++		Header: &Header{
++			Version:  Version,
++			Len:      HeaderLen + 4,
++			TOS:      1,
++			TotalLen: 0xbef3,
++			ID:       0xcafe,
++			Flags:    DontFragment,
++			FragOff:  1500,
++			TTL:      255,
++			Protocol: 1,
++			Checksum: 0xdead,
++			Src:      net.IPv4(172, 16, 254, 254),
++			Dst:      net.IPv4(192, 168, 0, 1),
++			Options:  []byte{0xff, 0xfe, 0xfe, 0xff},
++		},
++	},
++}
+ 
+ func TestMarshalHeader(t *testing.T) {
+-	b, err := testHeader.Marshal()
+-	if err != nil {
+-		t.Fatal(err)
++	if socket.NativeEndian != binary.LittleEndian {
++		t.Skip("no test for non-little endian machine yet")
+ 	}
+-	var wh []byte
+-	switch runtime.GOOS {
+-	case "darwin", "dragonfly", "netbsd":
+-		wh = wireHeaderToTradBSDKernel[:]
+-	case "freebsd":
+-		if freebsdVersion < 1000000 {
+-			wh = wireHeaderToTradBSDKernel[:]
+-		} else {
+-			wh = wireHeaderFromFreeBSD10Kernel[:]
++
++	for _, tt := range headerLittleEndianTests {
++		b, err := tt.Header.Marshal()
++		if err != nil {
++			t.Fatal(err)
++		}
++		var wh []byte
++		switch runtime.GOOS {
++		case "darwin", "dragonfly", "netbsd":
++			wh = tt.wireHeaderToTradBSDKernel
++		case "freebsd":
++			switch {
++			case freebsdVersion < 1000000:
++				wh = tt.wireHeaderToTradBSDKernel
++			case 1000000 <= freebsdVersion && freebsdVersion < 1100000:
++				wh = tt.wireHeaderToFreeBSD10Kernel
++			default:
++				wh = tt.wireHeaderToKernel
++			}
++		default:
++			wh = tt.wireHeaderToKernel
++		}
++		if !bytes.Equal(b, wh) {
++			t.Fatalf("got %#v; want %#v", b, wh)
+ 		}
+-	default:
+-		wh = wireHeaderToKernel[:]
+-	}
+-	if !bytes.Equal(b, wh) {
+-		t.Fatalf("got %#v; want %#v", b, wh)
+ 	}
+ }
+ 
+ func TestParseHeader(t *testing.T) {
+-	var wh []byte
+-	switch runtime.GOOS {
+-	case "darwin", "dragonfly", "netbsd":
+-		wh = wireHeaderFromTradBSDKernel[:]
+-	case "freebsd":
+-		if freebsdVersion < 1000000 {
+-			wh = wireHeaderFromTradBSDKernel[:]
+-		} else {
+-			wh = wireHeaderFromFreeBSD10Kernel[:]
+-		}
+-	default:
+-		wh = wireHeaderFromKernel[:]
+-	}
+-	h, err := ParseHeader(wh)
+-	if err != nil {
+-		t.Fatal(err)
+-	}
+-	if !reflect.DeepEqual(h, testHeader) {
+-		t.Fatalf("got %#v; want %#v", h, testHeader)
++	if socket.NativeEndian != binary.LittleEndian {
++		t.Skip("no test for big endian machine yet")
+ 	}
+-	s := h.String()
+-	if strings.Contains(s, ",") {
+-		t.Fatalf("should be space-separated values: %s", s)
++
++	for _, tt := range headerLittleEndianTests {
++		var wh []byte
++		switch runtime.GOOS {
++		case "darwin", "dragonfly", "netbsd":
++			wh = tt.wireHeaderFromTradBSDKernel
++		case "freebsd":
++			switch {
++			case freebsdVersion < 1000000:
++				wh = tt.wireHeaderFromTradBSDKernel
++			case 1000000 <= freebsdVersion && freebsdVersion < 1100000:
++				wh = tt.wireHeaderFromFreeBSD10Kernel
++			default:
++				wh = tt.wireHeaderFromKernel
++			}
++		default:
++			wh = tt.wireHeaderFromKernel
++		}
++		h, err := ParseHeader(wh)
++		if err != nil {
++			t.Fatal(err)
++		}
++		if err := h.Parse(wh); err != nil {
++			t.Fatal(err)
++		}
++		if !reflect.DeepEqual(h, tt.Header) {
++			t.Fatalf("got %#v; want %#v", h, tt.Header)
++		}
++		s := h.String()
++		if strings.Contains(s, ",") {
++			t.Fatalf("should be space-separated values: %s", s)
++		}
+ 	}
+ }
+diff -uNr go-net.old/ipv4/helper.go go-net/ipv4/helper.go
+--- go-net.old/ipv4/helper.go	2018-05-31 12:15:22.195956395 +0200
++++ go-net/ipv4/helper.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -18,6 +18,9 @@
+ 	errOpNoSupport              = errors.New("operation not supported")
+ 	errNoSuchInterface          = errors.New("no such interface")
+ 	errNoSuchMulticastInterface = errors.New("no such multicast interface")
++
++	// See http://www.freebsd.org/doc/en/books/porters-handbook/freebsd-versions.html.
++	freebsdVersion uint32
+ )
+ 
+ func boolint(b bool) int {
+@@ -40,3 +43,21 @@
+ 	}
+ 	return nil
+ }
++
++func opAddr(a net.Addr) net.Addr {
++	switch a.(type) {
++	case *net.TCPAddr:
++		if a == nil {
++			return nil
++		}
++	case *net.UDPAddr:
++		if a == nil {
++			return nil
++		}
++	case *net.IPAddr:
++		if a == nil {
++			return nil
++		}
++	}
++	return a
++}
+diff -uNr go-net.old/ipv4/iana.go go-net/ipv4/iana.go
+--- go-net.old/ipv4/iana.go	2018-05-31 12:15:22.199956310 +0200
++++ go-net/ipv4/iana.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,9 +1,9 @@
+ // go generate gen.go
+-// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
++// Code generated by the command above; DO NOT EDIT.
+ 
+ package ipv4
+ 
+-// Internet Control Message Protocol (ICMP) Parameters, Updated: 2013-04-19
++// Internet Control Message Protocol (ICMP) Parameters, Updated: 2018-02-26
+ const (
+ 	ICMPTypeEchoReply              ICMPType = 0  // Echo Reply
+ 	ICMPTypeDestinationUnreachable ICMPType = 3  // Destination Unreachable
+@@ -16,9 +16,11 @@
+ 	ICMPTypeTimestamp              ICMPType = 13 // Timestamp
+ 	ICMPTypeTimestampReply         ICMPType = 14 // Timestamp Reply
+ 	ICMPTypePhoturis               ICMPType = 40 // Photuris
++	ICMPTypeExtendedEchoRequest    ICMPType = 42 // Extended Echo Request
++	ICMPTypeExtendedEchoReply      ICMPType = 43 // Extended Echo Reply
+ )
+ 
+-// Internet Control Message Protocol (ICMP) Parameters, Updated: 2013-04-19
++// Internet Control Message Protocol (ICMP) Parameters, Updated: 2018-02-26
+ var icmpTypes = map[ICMPType]string{
+ 	0:  "echo reply",
+ 	3:  "destination unreachable",
+@@ -31,4 +33,6 @@
+ 	13: "timestamp",
+ 	14: "timestamp reply",
+ 	40: "photuris",
++	42: "extended echo request",
++	43: "extended echo reply",
+ }
+diff -uNr go-net.old/ipv4/icmp_bsd.go go-net/ipv4/icmp_bsd.go
+--- go-net.old/ipv4/icmp_bsd.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/icmp_bsd.go	2018-05-30 21:00:38.874684823 +0200
+@@ -0,0 +1,29 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin dragonfly freebsd netbsd openbsd
++
++package ipv6
++
++func (f *icmpv6Filter) accept(typ ICMPType) {
++	f.Filt[typ>>5] |= 1 << (uint32(typ) & 31)
++}
++
++func (f *icmpv6Filter) block(typ ICMPType) {
++	f.Filt[typ>>5] &^= 1 << (uint32(typ) & 31)
++}
++
++func (f *icmpv6Filter) setAll(block bool) {
++	for i := range f.Filt {
++		if block {
++			f.Filt[i] = 0
++		} else {
++			f.Filt[i] = 1<<32 - 1
++		}
++	}
++}
++
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
++	return f.Filt[typ>>5]&(1<<(uint32(typ)&31)) == 0
++}
+diff -uNr go-net.old/ipv4/icmp.go go-net/ipv4/icmp.go
+--- go-net.old/ipv4/icmp.go	2018-05-31 12:15:35.379675954 +0200
++++ go-net/ipv4/icmp.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,10 +1,10 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv4
+ 
+-import "gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++import "golang.org/x/net/internal/iana"
+ 
+ // An ICMPType represents a type of ICMP message.
+ type ICMPType int
+@@ -26,12 +26,12 @@
+ // packets. The filter belongs to a packet delivery path on a host and
+ // it cannot interact with forwarding packets or tunnel-outer packets.
+ //
+-// Note: RFC 2460 defines a reasonable role model and it works not
++// Note: RFC 8200 defines a reasonable role model and it works not
+ // only for IPv6 but IPv4. A node means a device that implements IP.
+ // A router means a node that forwards IP packets not explicitly
+ // addressed to itself, and a host means a node that is not a router.
+ type ICMPFilter struct {
+-	sysICMPFilter
++	icmpFilter
+ }
+ 
+ // Accept accepts incoming ICMP packets including the type field value
+diff -uNr go-net.old/ipv4/icmp_linux.go go-net/ipv4/icmp_linux.go
+--- go-net.old/ipv4/icmp_linux.go	2018-05-31 12:15:22.199956310 +0200
++++ go-net/ipv4/icmp_linux.go	2018-05-30 21:01:01.914196053 +0200
+@@ -4,15 +4,15 @@
+ 
+ package ipv4
+ 
+-func (f *sysICMPFilter) accept(typ ICMPType) {
++func (f *icmpFilter) accept(typ ICMPType) {
+ 	f.Data &^= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPFilter) block(typ ICMPType) {
++func (f *icmpFilter) block(typ ICMPType) {
+ 	f.Data |= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPFilter) setAll(block bool) {
++func (f *icmpFilter) setAll(block bool) {
+ 	if block {
+ 		f.Data = 1<<32 - 1
+ 	} else {
+@@ -20,6 +20,6 @@
+ 	}
+ }
+ 
+-func (f *sysICMPFilter) willBlock(typ ICMPType) bool {
++func (f *icmpFilter) willBlock(typ ICMPType) bool {
+ 	return f.Data&(1<<(uint32(typ)&31)) != 0
+ }
+diff -uNr go-net.old/ipv4/icmp_solaris.go go-net/ipv4/icmp_solaris.go
+--- go-net.old/ipv4/icmp_solaris.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/icmp_solaris.go	2018-05-30 21:00:38.874684823 +0200
+@@ -0,0 +1,27 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6
++
++func (f *icmpv6Filter) accept(typ ICMPType) {
++	f.X__icmp6_filt[typ>>5] |= 1 << (uint32(typ) & 31)
++}
++
++func (f *icmpv6Filter) block(typ ICMPType) {
++	f.X__icmp6_filt[typ>>5] &^= 1 << (uint32(typ) & 31)
++}
++
++func (f *icmpv6Filter) setAll(block bool) {
++	for i := range f.X__icmp6_filt {
++		if block {
++			f.X__icmp6_filt[i] = 0
++		} else {
++			f.X__icmp6_filt[i] = 1<<32 - 1
++		}
++	}
++}
++
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
++	return f.X__icmp6_filt[typ>>5]&(1<<(uint32(typ)&31)) == 0
++}
+diff -uNr go-net.old/ipv4/icmp_stub.go go-net/ipv4/icmp_stub.go
+--- go-net.old/ipv4/icmp_stub.go	2018-05-31 12:15:22.199956310 +0200
++++ go-net/ipv4/icmp_stub.go	2018-05-30 21:01:01.914196053 +0200
+@@ -6,20 +6,20 @@
+ 
+ package ipv4
+ 
+-const sysSizeofICMPFilter = 0x0
++const sizeofICMPFilter = 0x0
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ }
+ 
+-func (f *sysICMPFilter) accept(typ ICMPType) {
++func (f *icmpFilter) accept(typ ICMPType) {
+ }
+ 
+-func (f *sysICMPFilter) block(typ ICMPType) {
++func (f *icmpFilter) block(typ ICMPType) {
+ }
+ 
+-func (f *sysICMPFilter) setAll(block bool) {
++func (f *icmpFilter) setAll(block bool) {
+ }
+ 
+-func (f *sysICMPFilter) willBlock(typ ICMPType) bool {
++func (f *icmpFilter) willBlock(typ ICMPType) bool {
+ 	return false
+ }
+diff -uNr go-net.old/ipv4/icmp_test.go go-net/ipv4/icmp_test.go
+--- go-net.old/ipv4/icmp_test.go	2018-05-31 12:15:35.383675871 +0200
++++ go-net/ipv4/icmp_test.go	2018-05-30 21:01:01.914196053 +0200
+@@ -10,8 +10,8 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ var icmpStringTests = []struct {
+diff -uNr go-net.old/ipv4/icmp_windows.go go-net/ipv4/icmp_windows.go
+--- go-net.old/ipv4/icmp_windows.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/icmp_windows.go	2018-05-30 21:00:38.874684823 +0200
+@@ -0,0 +1,22 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6
++
++func (f *icmpv6Filter) accept(typ ICMPType) {
++	// TODO(mikio): implement this
++}
++
++func (f *icmpv6Filter) block(typ ICMPType) {
++	// TODO(mikio): implement this
++}
++
++func (f *icmpv6Filter) setAll(block bool) {
++	// TODO(mikio): implement this
++}
++
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
++	// TODO(mikio): implement this
++	return false
++}
+diff -uNr go-net.old/ipv4/mocktransponder_test.go go-net/ipv4/mocktransponder_test.go
+--- go-net.old/ipv4/mocktransponder_test.go	2018-05-31 12:15:22.199956310 +0200
++++ go-net/ipv4/mocktransponder_test.go	2018-05-30 21:00:38.874684823 +0200
+@@ -1,14 +1,25 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-package ipv4_test
++package ipv6_test
+ 
+ import (
+ 	"net"
+ 	"testing"
+ )
+ 
++func connector(t *testing.T, network, addr string, done chan<- bool) {
++	defer func() { done <- true }()
++
++	c, err := net.Dial(network, addr)
++	if err != nil {
++		t.Error(err)
++		return
++	}
++	c.Close()
++}
++
+ func acceptor(t *testing.T, ln net.Listener, done chan<- bool) {
+ 	defer func() { done <- true }()
+ 
+diff -uNr go-net.old/ipv4/multicastlistener_test.go go-net/ipv4/multicastlistener_test.go
+--- go-net.old/ipv4/multicastlistener_test.go	2018-05-31 12:15:35.403675445 +0200
++++ go-net/ipv4/multicastlistener_test.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -9,8 +9,8 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ var udpMultipleGroupListenerTests = []net.Addr{
+@@ -21,7 +21,7 @@
+ 
+ func TestUDPSinglePacketConnWithMultipleGroupListeners(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if testing.Short() {
+@@ -61,7 +61,7 @@
+ 
+ func TestUDPMultiplePacketConnWithMultipleGroupListeners(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if testing.Short() {
+@@ -69,13 +69,16 @@
+ 	}
+ 
+ 	for _, gaddr := range udpMultipleGroupListenerTests {
+-		c1, err := net.ListenPacket("udp4", "224.0.0.0:1024") // wildcard address with reusable port
++		c1, err := net.ListenPacket("udp4", "224.0.0.0:0") // wildcard address with reusable port
+ 		if err != nil {
+ 			t.Fatal(err)
+ 		}
+ 		defer c1.Close()
+-
+-		c2, err := net.ListenPacket("udp4", "224.0.0.0:1024") // wildcard address with reusable port
++		_, port, err := net.SplitHostPort(c1.LocalAddr().String())
++		if err != nil {
++			t.Fatal(err)
++		}
++		c2, err := net.ListenPacket("udp4", net.JoinHostPort("224.0.0.0", port)) // wildcard address with reusable port
+ 		if err != nil {
+ 			t.Fatal(err)
+ 		}
+@@ -113,7 +116,7 @@
+ 
+ func TestUDPPerInterfaceSinglePacketConnWithSingleGroupListener(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if testing.Short() {
+@@ -131,16 +134,29 @@
+ 	if err != nil {
+ 		t.Fatal(err)
+ 	}
++	port := "0"
+ 	for i, ifi := range ift {
+ 		ip, ok := nettest.IsMulticastCapable("ip4", &ifi)
+ 		if !ok {
+ 			continue
+ 		}
+-		c, err := net.ListenPacket("udp4", ip.String()+":"+"1024") // unicast address with non-reusable port
++		c, err := net.ListenPacket("udp4", net.JoinHostPort(ip.String(), port)) // unicast address with non-reusable port
+ 		if err != nil {
+-			t.Fatal(err)
++			// The listen may fail when the serivce is
++			// already in use, but it's fine because the
++			// purpose of this is not to test the
++			// bookkeeping of IP control block inside the
++			// kernel.
++			t.Log(err)
++			continue
+ 		}
+ 		defer c.Close()
++		if port == "0" {
++			_, port, err = net.SplitHostPort(c.LocalAddr().String())
++			if err != nil {
++				t.Fatal(err)
++			}
++		}
+ 		p := ipv4.NewPacketConn(c)
+ 		if err := p.JoinGroup(&ifi, &gaddr); err != nil {
+ 			t.Fatal(err)
+@@ -156,7 +172,7 @@
+ 
+ func TestIPSingleRawConnWithSingleGroupListener(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if testing.Short() {
+@@ -201,7 +217,7 @@
+ 
+ func TestIPPerInterfaceSingleRawConnWithSingleGroupListener(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if testing.Short() {
+diff -uNr go-net.old/ipv4/multicastsockopt_test.go go-net/ipv4/multicastsockopt_test.go
+--- go-net.old/ipv4/multicastsockopt_test.go	2018-05-31 12:15:35.411675274 +0200
++++ go-net/ipv4/multicastsockopt_test.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -9,8 +9,8 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ var packetConnMulticastSocketOptionTests = []struct {
+@@ -26,7 +26,7 @@
+ 
+ func TestPacketConnMulticastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris":
++	case "nacl", "plan9":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagMulticast|net.FlagLoopback)
+@@ -66,7 +66,7 @@
+ 
+ func TestRawConnMulticastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris":
++	case "nacl", "plan9":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if m, ok := nettest.SupportsRawIPSocket(); !ok {
+diff -uNr go-net.old/ipv4/multicast_test.go go-net/ipv4/multicast_test.go
+--- go-net.old/ipv4/multicast_test.go	2018-05-31 12:15:35.395675614 +0200
++++ go-net/ipv4/multicast_test.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,10 +12,10 @@
+ 	"testing"
+ 	"time"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/icmp"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/icmp"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ var packetConnReadWriteMulticastUDPTests = []struct {
+@@ -166,7 +166,11 @@
+ 		if _, err := p.MulticastLoopback(); err != nil {
+ 			t.Fatal(err)
+ 		}
+-		cf := ipv4.FlagTTL | ipv4.FlagDst | ipv4.FlagInterface
++		cf := ipv4.FlagDst | ipv4.FlagInterface
++		if runtime.GOOS != "solaris" {
++			// Solaris never allows to modify ICMP properties.
++			cf |= ipv4.FlagTTL
++		}
+ 
+ 		for i, toggle := range []bool{true, false, true} {
+ 			wb, err := (&icmp.Message{
+diff -uNr go-net.old/ipv4/packet.go go-net/ipv4/packet.go
+--- go-net.old/ipv4/packet.go	2018-05-31 12:15:22.203956224 +0200
++++ go-net/ipv4/packet.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -7,42 +7,30 @@
+ import (
+ 	"net"
+ 	"syscall"
++
++	"golang.org/x/net/internal/socket"
+ )
+ 
++// BUG(mikio): On Windows, the ReadFrom and WriteTo methods of RawConn
++// are not implemented.
++
+ // A packetHandler represents the IPv4 datagram handler.
+ type packetHandler struct {
+-	c *net.IPConn
++	*net.IPConn
++	*socket.Conn
+ 	rawOpt
+ }
+ 
+-func (c *packetHandler) ok() bool { return c != nil && c.c != nil }
++func (c *packetHandler) ok() bool { return c != nil && c.IPConn != nil && c.Conn != nil }
+ 
+ // ReadFrom reads an IPv4 datagram from the endpoint c, copying the
+-// datagram into b.  It returns the received datagram as the IPv4
++// datagram into b. It returns the received datagram as the IPv4
+ // header h, the payload p and the control message cm.
+ func (c *packetHandler) ReadFrom(b []byte) (h *Header, p []byte, cm *ControlMessage, err error) {
+ 	if !c.ok() {
+ 		return nil, nil, nil, syscall.EINVAL
+ 	}
+-	oob := newControlMessage(&c.rawOpt)
+-	n, oobn, _, src, err := c.c.ReadMsgIP(b, oob)
+-	if err != nil {
+-		return nil, nil, nil, err
+-	}
+-	var hs []byte
+-	if hs, p, err = slicePacket(b[:n]); err != nil {
+-		return nil, nil, nil, err
+-	}
+-	if h, err = ParseHeader(hs); err != nil {
+-		return nil, nil, nil, err
+-	}
+-	if cm, err = parseControlMessage(oob[:oobn]); err != nil {
+-		return nil, nil, nil, err
+-	}
+-	if src != nil && cm != nil {
+-		cm.Src = src.IP
+-	}
+-	return
++	return c.readFrom(b)
+ }
+ 
+ func slicePacket(b []byte) (h, p []byte, err error) {
+@@ -54,14 +42,14 @@
+ }
+ 
+ // WriteTo writes an IPv4 datagram through the endpoint c, copying the
+-// datagram from the IPv4 header h and the payload p.  The control
++// datagram from the IPv4 header h and the payload p. The control
+ // message cm allows the datagram path and the outgoing interface to be
+-// specified.  Currently only Darwin and Linux support this.  The cm
++// specified.  Currently only Darwin and Linux support this. The cm
+ // may be nil if control of the outgoing datagram is not required.
+ //
+ // The IPv4 header h must contain appropriate fields that include:
+ //
+-//	Version       = ipv4.Version
++//	Version       = <must be specified>
+ //	Len           = <must be specified>
+ //	TOS           = <must be specified>
+ //	TotalLen      = <must be specified>
+@@ -77,21 +65,5 @@
+ 	if !c.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	oob := marshalControlMessage(cm)
+-	wh, err := h.Marshal()
+-	if err != nil {
+-		return err
+-	}
+-	dst := &net.IPAddr{}
+-	if cm != nil {
+-		if ip := cm.Dst.To4(); ip != nil {
+-			dst.IP = ip
+-		}
+-	}
+-	if dst.IP == nil {
+-		dst.IP = h.Dst
+-	}
+-	wh = append(wh, p...)
+-	_, _, err = c.c.WriteMsgIP(wh, oob, dst)
+-	return err
++	return c.writeTo(h, p, cm)
+ }
+diff -uNr go-net.old/ipv4/packet_go1_8.go go-net/ipv4/packet_go1_8.go
+--- go-net.old/ipv4/packet_go1_8.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/packet_go1_8.go	2018-05-30 21:01:01.914196053 +0200
+@@ -0,0 +1,56 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !go1.9
++
++package ipv4
++
++import "net"
++
++func (c *packetHandler) readFrom(b []byte) (h *Header, p []byte, cm *ControlMessage, err error) {
++	c.rawOpt.RLock()
++	oob := NewControlMessage(c.rawOpt.cflags)
++	c.rawOpt.RUnlock()
++	n, nn, _, src, err := c.ReadMsgIP(b, oob)
++	if err != nil {
++		return nil, nil, nil, err
++	}
++	var hs []byte
++	if hs, p, err = slicePacket(b[:n]); err != nil {
++		return nil, nil, nil, err
++	}
++	if h, err = ParseHeader(hs); err != nil {
++		return nil, nil, nil, err
++	}
++	if nn > 0 {
++		cm = new(ControlMessage)
++		if err := cm.Parse(oob[:nn]); err != nil {
++			return nil, nil, nil, err
++		}
++	}
++	if src != nil && cm != nil {
++		cm.Src = src.IP
++	}
++	return
++}
++
++func (c *packetHandler) writeTo(h *Header, p []byte, cm *ControlMessage) error {
++	oob := cm.Marshal()
++	wh, err := h.Marshal()
++	if err != nil {
++		return err
++	}
++	dst := new(net.IPAddr)
++	if cm != nil {
++		if ip := cm.Dst.To4(); ip != nil {
++			dst.IP = ip
++		}
++	}
++	if dst.IP == nil {
++		dst.IP = h.Dst
++	}
++	wh = append(wh, p...)
++	_, _, err = c.WriteMsgIP(wh, oob, dst)
++	return err
++}
+diff -uNr go-net.old/ipv4/packet_go1_9.go go-net/ipv4/packet_go1_9.go
+--- go-net.old/ipv4/packet_go1_9.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/packet_go1_9.go	2018-05-30 21:01:01.914196053 +0200
+@@ -0,0 +1,67 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++
++package ipv4
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (c *packetHandler) readFrom(b []byte) (h *Header, p []byte, cm *ControlMessage, err error) {
++	c.rawOpt.RLock()
++	m := socket.Message{
++		Buffers: [][]byte{b},
++		OOB:     NewControlMessage(c.rawOpt.cflags),
++	}
++	c.rawOpt.RUnlock()
++	if err := c.RecvMsg(&m, 0); err != nil {
++		return nil, nil, nil, &net.OpError{Op: "read", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++	}
++	var hs []byte
++	if hs, p, err = slicePacket(b[:m.N]); err != nil {
++		return nil, nil, nil, &net.OpError{Op: "read", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++	}
++	if h, err = ParseHeader(hs); err != nil {
++		return nil, nil, nil, &net.OpError{Op: "read", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++	}
++	if m.NN > 0 {
++		cm = new(ControlMessage)
++		if err := cm.Parse(m.OOB[:m.NN]); err != nil {
++			return nil, nil, nil, &net.OpError{Op: "read", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Err: err}
++		}
++	}
++	if src, ok := m.Addr.(*net.IPAddr); ok && cm != nil {
++		cm.Src = src.IP
++	}
++	return
++}
++
++func (c *packetHandler) writeTo(h *Header, p []byte, cm *ControlMessage) error {
++	m := socket.Message{
++		OOB: cm.Marshal(),
++	}
++	wh, err := h.Marshal()
++	if err != nil {
++		return err
++	}
++	m.Buffers = [][]byte{wh, p}
++	dst := new(net.IPAddr)
++	if cm != nil {
++		if ip := cm.Dst.To4(); ip != nil {
++			dst.IP = ip
++		}
++	}
++	if dst.IP == nil {
++		dst.IP = h.Dst
++	}
++	m.Addr = dst
++	if err := c.SendMsg(&m, 0); err != nil {
++		return &net.OpError{Op: "write", Net: c.IPConn.LocalAddr().Network(), Source: c.IPConn.LocalAddr(), Addr: opAddr(dst), Err: err}
++	}
++	return nil
++}
+diff -uNr go-net.old/ipv4/payload_cmsg.go go-net/ipv4/payload_cmsg.go
+--- go-net.old/ipv4/payload_cmsg.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/payload_cmsg.go	2018-05-30 21:01:01.914196053 +0200
+@@ -1,8 +1,8 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build !plan9,!solaris,!windows
++// +build !nacl,!plan9,!windows
+ 
+ package ipv4
+ 
+@@ -12,70 +12,25 @@
+ )
+ 
+ // ReadFrom reads a payload of the received IPv4 datagram, from the
+-// endpoint c, copying the payload into b.  It returns the number of
++// endpoint c, copying the payload into b. It returns the number of
+ // bytes copied into b, the control message cm and the source address
+ // src of the received datagram.
+ func (c *payloadHandler) ReadFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error) {
+ 	if !c.ok() {
+ 		return 0, nil, nil, syscall.EINVAL
+ 	}
+-	oob := newControlMessage(&c.rawOpt)
+-	var oobn int
+-	switch c := c.PacketConn.(type) {
+-	case *net.UDPConn:
+-		if n, oobn, _, src, err = c.ReadMsgUDP(b, oob); err != nil {
+-			return 0, nil, nil, err
+-		}
+-	case *net.IPConn:
+-		if sockOpts[ssoStripHeader].name > 0 {
+-			if n, oobn, _, src, err = c.ReadMsgIP(b, oob); err != nil {
+-				return 0, nil, nil, err
+-			}
+-		} else {
+-			nb := make([]byte, maxHeaderLen+len(b))
+-			if n, oobn, _, src, err = c.ReadMsgIP(nb, oob); err != nil {
+-				return 0, nil, nil, err
+-			}
+-			hdrlen := int(nb[0]&0x0f) << 2
+-			copy(b, nb[hdrlen:])
+-			n -= hdrlen
+-		}
+-	default:
+-		return 0, nil, nil, errInvalidConnType
+-	}
+-	if cm, err = parseControlMessage(oob[:oobn]); err != nil {
+-		return 0, nil, nil, err
+-	}
+-	if cm != nil {
+-		cm.Src = netAddrToIP4(src)
+-	}
+-	return
++	return c.readFrom(b)
+ }
+ 
+ // WriteTo writes a payload of the IPv4 datagram, to the destination
+-// address dst through the endpoint c, copying the payload from b.  It
+-// returns the number of bytes written.  The control message cm allows
++// address dst through the endpoint c, copying the payload from b. It
++// returns the number of bytes written. The control message cm allows
+ // the datagram path and the outgoing interface to be specified.
+-// Currently only Darwin and Linux support this.  The cm may be nil if
++// Currently only Darwin and Linux support this. The cm may be nil if
+ // control of the outgoing datagram is not required.
+ func (c *payloadHandler) WriteTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error) {
+ 	if !c.ok() {
+ 		return 0, syscall.EINVAL
+ 	}
+-	oob := marshalControlMessage(cm)
+-	if dst == nil {
+-		return 0, errMissingAddress
+-	}
+-	switch c := c.PacketConn.(type) {
+-	case *net.UDPConn:
+-		n, _, err = c.WriteMsgUDP(b, oob, dst.(*net.UDPAddr))
+-	case *net.IPConn:
+-		n, _, err = c.WriteMsgIP(b, oob, dst.(*net.IPAddr))
+-	default:
+-		return 0, errInvalidConnType
+-	}
+-	if err != nil {
+-		return 0, err
+-	}
+-	return
++	return c.writeTo(b, cm, dst)
+ }
+diff -uNr go-net.old/ipv4/payload_cmsg_go1_8.go go-net/ipv4/payload_cmsg_go1_8.go
+--- go-net.old/ipv4/payload_cmsg_go1_8.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/payload_cmsg_go1_8.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,59 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !go1.9
++// +build !nacl,!plan9,!windows
++
++package ipv4
++
++import "net"
++
++func (c *payloadHandler) readFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error) {
++	c.rawOpt.RLock()
++	oob := NewControlMessage(c.rawOpt.cflags)
++	c.rawOpt.RUnlock()
++	var nn int
++	switch c := c.PacketConn.(type) {
++	case *net.UDPConn:
++		if n, nn, _, src, err = c.ReadMsgUDP(b, oob); err != nil {
++			return 0, nil, nil, err
++		}
++	case *net.IPConn:
++		nb := make([]byte, maxHeaderLen+len(b))
++		if n, nn, _, src, err = c.ReadMsgIP(nb, oob); err != nil {
++			return 0, nil, nil, err
++		}
++		hdrlen := int(nb[0]&0x0f) << 2
++		copy(b, nb[hdrlen:])
++		n -= hdrlen
++	default:
++		return 0, nil, nil, &net.OpError{Op: "read", Net: c.LocalAddr().Network(), Source: c.LocalAddr(), Err: errInvalidConnType}
++	}
++	if nn > 0 {
++		cm = new(ControlMessage)
++		if err = cm.Parse(oob[:nn]); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++	}
++	if cm != nil {
++		cm.Src = netAddrToIP4(src)
++	}
++	return
++}
++
++func (c *payloadHandler) writeTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error) {
++	oob := cm.Marshal()
++	if dst == nil {
++		return 0, &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: errMissingAddress}
++	}
++	switch c := c.PacketConn.(type) {
++	case *net.UDPConn:
++		n, _, err = c.WriteMsgUDP(b, oob, dst.(*net.UDPAddr))
++	case *net.IPConn:
++		n, _, err = c.WriteMsgIP(b, oob, dst.(*net.IPAddr))
++	default:
++		return 0, &net.OpError{Op: "write", Net: c.LocalAddr().Network(), Source: c.LocalAddr(), Addr: opAddr(dst), Err: errInvalidConnType}
++	}
++	return
++}
+diff -uNr go-net.old/ipv4/payload_cmsg_go1_9.go go-net/ipv4/payload_cmsg_go1_9.go
+--- go-net.old/ipv4/payload_cmsg_go1_9.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/payload_cmsg_go1_9.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,67 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++// +build !nacl,!plan9,!windows
++
++package ipv4
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (c *payloadHandler) readFrom(b []byte) (int, *ControlMessage, net.Addr, error) {
++	c.rawOpt.RLock()
++	m := socket.Message{
++		OOB: NewControlMessage(c.rawOpt.cflags),
++	}
++	c.rawOpt.RUnlock()
++	switch c.PacketConn.(type) {
++	case *net.UDPConn:
++		m.Buffers = [][]byte{b}
++		if err := c.RecvMsg(&m, 0); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++	case *net.IPConn:
++		h := make([]byte, HeaderLen)
++		m.Buffers = [][]byte{h, b}
++		if err := c.RecvMsg(&m, 0); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		hdrlen := int(h[0]&0x0f) << 2
++		if hdrlen > len(h) {
++			d := hdrlen - len(h)
++			copy(b, b[d:])
++			m.N -= d
++		} else {
++			m.N -= hdrlen
++		}
++	default:
++		return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: errInvalidConnType}
++	}
++	var cm *ControlMessage
++	if m.NN > 0 {
++		cm = new(ControlMessage)
++		if err := cm.Parse(m.OOB[:m.NN]); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		cm.Src = netAddrToIP4(m.Addr)
++	}
++	return m.N, cm, m.Addr, nil
++}
++
++func (c *payloadHandler) writeTo(b []byte, cm *ControlMessage, dst net.Addr) (int, error) {
++	m := socket.Message{
++		Buffers: [][]byte{b},
++		OOB:     cm.Marshal(),
++		Addr:    dst,
++	}
++	err := c.SendMsg(&m, 0)
++	if err != nil {
++		err = &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Addr: opAddr(dst), Err: err}
++	}
++	return m.N, err
++}
+diff -uNr go-net.old/ipv4/payload.go go-net/ipv4/payload.go
+--- go-net.old/ipv4/payload.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/payload.go	2018-05-30 21:01:01.918195966 +0200
+@@ -1,15 +1,23 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv4
+ 
+-import "net"
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++// BUG(mikio): On Windows, the ControlMessage for ReadFrom and WriteTo
++// methods of PacketConn is not implemented.
+ 
+ // A payloadHandler represents the IPv4 datagram payload handler.
+ type payloadHandler struct {
+ 	net.PacketConn
++	*socket.Conn
+ 	rawOpt
+ }
+ 
+-func (c *payloadHandler) ok() bool { return c != nil && c.PacketConn != nil }
++func (c *payloadHandler) ok() bool { return c != nil && c.PacketConn != nil && c.Conn != nil }
+diff -uNr go-net.old/ipv4/payload_nocmsg.go go-net/ipv4/payload_nocmsg.go
+--- go-net.old/ipv4/payload_nocmsg.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/payload_nocmsg.go	2018-05-30 21:01:01.918195966 +0200
+@@ -1,8 +1,8 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build plan9 solaris windows
++// +build nacl plan9 windows
+ 
+ package ipv4
+ 
+@@ -12,7 +12,7 @@
+ )
+ 
+ // ReadFrom reads a payload of the received IPv4 datagram, from the
+-// endpoint c, copying the payload into b.  It returns the number of
++// endpoint c, copying the payload into b. It returns the number of
+ // bytes copied into b, the control message cm and the source address
+ // src of the received datagram.
+ func (c *payloadHandler) ReadFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error) {
+@@ -26,10 +26,10 @@
+ }
+ 
+ // WriteTo writes a payload of the IPv4 datagram, to the destination
+-// address dst through the endpoint c, copying the payload from b.  It
+-// returns the number of bytes written.  The control message cm allows
++// address dst through the endpoint c, copying the payload from b. It
++// returns the number of bytes written. The control message cm allows
+ // the datagram path and the outgoing interface to be specified.
+-// Currently only Darwin and Linux support this.  The cm may be nil if
++// Currently only Darwin and Linux support this. The cm may be nil if
+ // control of the outgoing datagram is not required.
+ func (c *payloadHandler) WriteTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error) {
+ 	if !c.ok() {
+diff -uNr go-net.old/ipv4/readwrite_go1_8_test.go go-net/ipv4/readwrite_go1_8_test.go
+--- go-net.old/ipv4/readwrite_go1_8_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/readwrite_go1_8_test.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,248 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !go1.9
++
++package ipv4_test
++
++import (
++	"bytes"
++	"fmt"
++	"net"
++	"runtime"
++	"strings"
++	"sync"
++	"testing"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
++)
++
++func BenchmarkPacketConnReadWriteUnicast(b *testing.B) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		b.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph, err := (&ipv4.Header{
++		Version:  ipv4.Version,
++		Len:      ipv4.HeaderLen,
++		TotalLen: ipv4.HeaderLen + len(payload),
++		TTL:      1,
++		Protocol: iana.ProtocolReserved,
++		Src:      net.IPv4(192, 0, 2, 1),
++		Dst:      net.IPv4(192, 0, 2, 254),
++	}).Marshal()
++	if err != nil {
++		b.Fatal(err)
++	}
++	greh := []byte{0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++	bb := make([]byte, 128)
++	cm := ipv4.ControlMessage{
++		Src: net.IPv4(127, 0, 0, 1),
++	}
++	if ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback); ifi != nil {
++		cm.IfIndex = ifi.Index
++	}
++
++	b.Run("UDP", func(b *testing.B) {
++		c, err := nettest.NewLocalPacketListener("udp4")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv4.FlagTTL | ipv4.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(payload, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(payload, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++	b.Run("IP", func(b *testing.B) {
++		switch runtime.GOOS {
++		case "netbsd":
++			b.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			b.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip4:%d", iana.ProtocolGRE), "127.0.0.1")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv4.FlagTTL | ipv4.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(datagram, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(datagram, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++}
++
++func TestPacketConnConcurrentReadWriteUnicast(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph, err := (&ipv4.Header{
++		Version:  ipv4.Version,
++		Len:      ipv4.HeaderLen,
++		TotalLen: ipv4.HeaderLen + len(payload),
++		TTL:      1,
++		Protocol: iana.ProtocolReserved,
++		Src:      net.IPv4(192, 0, 2, 1),
++		Dst:      net.IPv4(192, 0, 2, 254),
++	}).Marshal()
++	if err != nil {
++		t.Fatal(err)
++	}
++	greh := []byte{0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++
++	t.Run("UDP", func(t *testing.T) {
++		c, err := nettest.NewLocalPacketListener("udp4")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, payload, c.LocalAddr())
++		})
++	})
++	t.Run("IP", func(t *testing.T) {
++		switch runtime.GOOS {
++		case "netbsd":
++			t.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			t.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip4:%d", iana.ProtocolGRE), "127.0.0.1")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, datagram, c.LocalAddr())
++		})
++	})
++}
++
++func testPacketConnConcurrentReadWriteUnicast(t *testing.T, p *ipv4.PacketConn, data []byte, dst net.Addr) {
++	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
++	cf := ipv4.FlagTTL | ipv4.FlagSrc | ipv4.FlagDst | ipv4.FlagInterface
++
++	if err := p.SetControlMessage(cf, true); err != nil { // probe before test
++		if nettest.ProtocolNotSupported(err) {
++			t.Skipf("not supported on %s", runtime.GOOS)
++		}
++		t.Fatal(err)
++	}
++
++	var wg sync.WaitGroup
++	reader := func() {
++		defer wg.Done()
++		b := make([]byte, 128)
++		n, cm, _, err := p.ReadFrom(b)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if !bytes.Equal(b[:n], data) {
++			t.Errorf("got %#v; want %#v", b[:n], data)
++			return
++		}
++		s := cm.String()
++		if strings.Contains(s, ",") {
++			t.Errorf("should be space-separated values: %s", s)
++			return
++		}
++	}
++	writer := func(toggle bool) {
++		defer wg.Done()
++		cm := ipv4.ControlMessage{
++			Src: net.IPv4(127, 0, 0, 1),
++		}
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
++		if err := p.SetControlMessage(cf, toggle); err != nil {
++			t.Error(err)
++			return
++		}
++		n, err := p.WriteTo(data, &cm, dst)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(data) {
++			t.Errorf("got %d; want %d", n, len(data))
++			return
++		}
++	}
++
++	const N = 10
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		go reader()
++	}
++	wg.Add(2 * N)
++	for i := 0; i < 2*N; i++ {
++		go writer(i%2 != 0)
++
++	}
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		go reader()
++	}
++	wg.Wait()
++}
+diff -uNr go-net.old/ipv4/readwrite_go1_9_test.go go-net/ipv4/readwrite_go1_9_test.go
+--- go-net.old/ipv4/readwrite_go1_9_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/readwrite_go1_9_test.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,388 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++
++package ipv4_test
++
++import (
++	"bytes"
++	"fmt"
++	"net"
++	"runtime"
++	"strings"
++	"sync"
++	"testing"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
++)
++
++func BenchmarkPacketConnReadWriteUnicast(b *testing.B) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		b.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph, err := (&ipv4.Header{
++		Version:  ipv4.Version,
++		Len:      ipv4.HeaderLen,
++		TotalLen: ipv4.HeaderLen + len(payload),
++		TTL:      1,
++		Protocol: iana.ProtocolReserved,
++		Src:      net.IPv4(192, 0, 2, 1),
++		Dst:      net.IPv4(192, 0, 2, 254),
++	}).Marshal()
++	if err != nil {
++		b.Fatal(err)
++	}
++	greh := []byte{0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++	bb := make([]byte, 128)
++	cm := ipv4.ControlMessage{
++		Src: net.IPv4(127, 0, 0, 1),
++	}
++	if ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback); ifi != nil {
++		cm.IfIndex = ifi.Index
++	}
++
++	b.Run("UDP", func(b *testing.B) {
++		c, err := nettest.NewLocalPacketListener("udp4")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv4.FlagTTL | ipv4.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		wms := []ipv4.Message{
++			{
++				Buffers: [][]byte{payload},
++				Addr:    dst,
++				OOB:     cm.Marshal(),
++			},
++		}
++		rms := []ipv4.Message{
++			{
++				Buffers: [][]byte{bb},
++				OOB:     ipv4.NewControlMessage(cf),
++			},
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(payload, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(payload, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("Batch", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteBatch(wms, 0); err != nil {
++					b.Fatal(err)
++				}
++				if _, err := p.ReadBatch(rms, 0); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++	b.Run("IP", func(b *testing.B) {
++		switch runtime.GOOS {
++		case "netbsd":
++			b.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			b.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip4:%d", iana.ProtocolGRE), "127.0.0.1")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv4.FlagTTL | ipv4.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		wms := []ipv4.Message{
++			{
++				Buffers: [][]byte{datagram},
++				Addr:    dst,
++				OOB:     cm.Marshal(),
++			},
++		}
++		rms := []ipv4.Message{
++			{
++				Buffers: [][]byte{bb},
++				OOB:     ipv4.NewControlMessage(cf),
++			},
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(datagram, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(datagram, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("Batch", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteBatch(wms, 0); err != nil {
++					b.Fatal(err)
++				}
++				if _, err := p.ReadBatch(rms, 0); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++}
++
++func TestPacketConnConcurrentReadWriteUnicast(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph, err := (&ipv4.Header{
++		Version:  ipv4.Version,
++		Len:      ipv4.HeaderLen,
++		TotalLen: ipv4.HeaderLen + len(payload),
++		TTL:      1,
++		Protocol: iana.ProtocolReserved,
++		Src:      net.IPv4(192, 0, 2, 1),
++		Dst:      net.IPv4(192, 0, 2, 254),
++	}).Marshal()
++	if err != nil {
++		t.Fatal(err)
++	}
++	greh := []byte{0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++
++	t.Run("UDP", func(t *testing.T) {
++		c, err := nettest.NewLocalPacketListener("udp4")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, payload, c.LocalAddr(), false)
++		})
++		t.Run("Batch", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, payload, c.LocalAddr(), true)
++		})
++	})
++	t.Run("IP", func(t *testing.T) {
++		switch runtime.GOOS {
++		case "netbsd":
++			t.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			t.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip4:%d", iana.ProtocolGRE), "127.0.0.1")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv4.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, datagram, c.LocalAddr(), false)
++		})
++		t.Run("Batch", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, datagram, c.LocalAddr(), true)
++		})
++	})
++}
++
++func testPacketConnConcurrentReadWriteUnicast(t *testing.T, p *ipv4.PacketConn, data []byte, dst net.Addr, batch bool) {
++	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
++	cf := ipv4.FlagTTL | ipv4.FlagSrc | ipv4.FlagDst | ipv4.FlagInterface
++
++	if err := p.SetControlMessage(cf, true); err != nil { // probe before test
++		if nettest.ProtocolNotSupported(err) {
++			t.Skipf("not supported on %s", runtime.GOOS)
++		}
++		t.Fatal(err)
++	}
++
++	var wg sync.WaitGroup
++	reader := func() {
++		defer wg.Done()
++		b := make([]byte, 128)
++		n, cm, _, err := p.ReadFrom(b)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if !bytes.Equal(b[:n], data) {
++			t.Errorf("got %#v; want %#v", b[:n], data)
++			return
++		}
++		s := cm.String()
++		if strings.Contains(s, ",") {
++			t.Errorf("should be space-separated values: %s", s)
++			return
++		}
++	}
++	batchReader := func() {
++		defer wg.Done()
++		ms := []ipv4.Message{
++			{
++				Buffers: [][]byte{make([]byte, 128)},
++				OOB:     ipv4.NewControlMessage(cf),
++			},
++		}
++		n, err := p.ReadBatch(ms, 0)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(ms) {
++			t.Errorf("got %d; want %d", n, len(ms))
++			return
++		}
++		var cm ipv4.ControlMessage
++		if err := cm.Parse(ms[0].OOB[:ms[0].NN]); err != nil {
++			t.Error(err)
++			return
++		}
++		var b []byte
++		if _, ok := dst.(*net.IPAddr); ok {
++			var h ipv4.Header
++			if err := h.Parse(ms[0].Buffers[0][:ms[0].N]); err != nil {
++				t.Error(err)
++				return
++			}
++			b = ms[0].Buffers[0][h.Len:ms[0].N]
++		} else {
++			b = ms[0].Buffers[0][:ms[0].N]
++		}
++		if !bytes.Equal(b, data) {
++			t.Errorf("got %#v; want %#v", b, data)
++			return
++		}
++		s := cm.String()
++		if strings.Contains(s, ",") {
++			t.Errorf("should be space-separated values: %s", s)
++			return
++		}
++	}
++	writer := func(toggle bool) {
++		defer wg.Done()
++		cm := ipv4.ControlMessage{
++			Src: net.IPv4(127, 0, 0, 1),
++		}
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
++		if err := p.SetControlMessage(cf, toggle); err != nil {
++			t.Error(err)
++			return
++		}
++		n, err := p.WriteTo(data, &cm, dst)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(data) {
++			t.Errorf("got %d; want %d", n, len(data))
++			return
++		}
++	}
++	batchWriter := func(toggle bool) {
++		defer wg.Done()
++		cm := ipv4.ControlMessage{
++			Src: net.IPv4(127, 0, 0, 1),
++		}
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
++		if err := p.SetControlMessage(cf, toggle); err != nil {
++			t.Error(err)
++			return
++		}
++		ms := []ipv4.Message{
++			{
++				Buffers: [][]byte{data},
++				OOB:     cm.Marshal(),
++				Addr:    dst,
++			},
++		}
++		n, err := p.WriteBatch(ms, 0)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(ms) {
++			t.Errorf("got %d; want %d", n, len(ms))
++			return
++		}
++		if ms[0].N != len(data) {
++			t.Errorf("got %d; want %d", ms[0].N, len(data))
++			return
++		}
++	}
++
++	const N = 10
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		if batch {
++			go batchReader()
++		} else {
++			go reader()
++		}
++	}
++	wg.Add(2 * N)
++	for i := 0; i < 2*N; i++ {
++		if batch {
++			go batchWriter(i%2 != 0)
++		} else {
++			go writer(i%2 != 0)
++		}
++
++	}
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		if batch {
++			go batchReader()
++		} else {
++			go reader()
++		}
++	}
++	wg.Wait()
++}
+diff -uNr go-net.old/ipv4/readwrite_test.go go-net/ipv4/readwrite_test.go
+--- go-net.old/ipv4/readwrite_test.go	2018-05-31 12:15:35.419675105 +0200
++++ go-net/ipv4/readwrite_test.go	2018-05-30 21:01:01.918195966 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,90 +12,60 @@
+ 	"sync"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+-func benchmarkUDPListener() (net.PacketConn, net.Addr, error) {
+-	c, err := net.ListenPacket("udp4", "127.0.0.1:0")
++func BenchmarkReadWriteUnicast(b *testing.B) {
++	c, err := nettest.NewLocalPacketListener("udp4")
+ 	if err != nil {
+-		return nil, nil, err
+-	}
+-	dst, err := net.ResolveUDPAddr("udp4", c.LocalAddr().String())
+-	if err != nil {
+-		c.Close()
+-		return nil, nil, err
+-	}
+-	return c, dst, nil
+-}
+-
+-func BenchmarkReadWriteNetUDP(b *testing.B) {
+-	c, dst, err := benchmarkUDPListener()
+-	if err != nil {
+-		b.Fatal(err)
++		b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
+ 	}
+ 	defer c.Close()
+ 
++	dst := c.LocalAddr()
+ 	wb, rb := []byte("HELLO-R-U-THERE"), make([]byte, 128)
+-	b.ResetTimer()
+-	for i := 0; i < b.N; i++ {
+-		benchmarkReadWriteNetUDP(b, c, wb, rb, dst)
+-	}
+-}
+-
+-func benchmarkReadWriteNetUDP(b *testing.B, c net.PacketConn, wb, rb []byte, dst net.Addr) {
+-	if _, err := c.WriteTo(wb, dst); err != nil {
+-		b.Fatal(err)
+-	}
+-	if _, _, err := c.ReadFrom(rb); err != nil {
+-		b.Fatal(err)
+-	}
+-}
+-
+-func BenchmarkReadWriteIPv4UDP(b *testing.B) {
+-	c, dst, err := benchmarkUDPListener()
+-	if err != nil {
+-		b.Fatal(err)
+-	}
+-	defer c.Close()
+-
+-	p := ipv4.NewPacketConn(c)
+-	defer p.Close()
+-	cf := ipv4.FlagTTL | ipv4.FlagInterface
+-	if err := p.SetControlMessage(cf, true); err != nil {
+-		b.Fatal(err)
+-	}
+-	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
+ 
+-	wb, rb := []byte("HELLO-R-U-THERE"), make([]byte, 128)
+-	b.ResetTimer()
+-	for i := 0; i < b.N; i++ {
+-		benchmarkReadWriteIPv4UDP(b, p, wb, rb, dst, ifi)
+-	}
+-}
++	b.Run("NetUDP", func(b *testing.B) {
++		for i := 0; i < b.N; i++ {
++			if _, err := c.WriteTo(wb, dst); err != nil {
++				b.Fatal(err)
++			}
++			if _, _, err := c.ReadFrom(rb); err != nil {
++				b.Fatal(err)
++			}
++		}
++	})
++	b.Run("IPv4UDP", func(b *testing.B) {
++		p := ipv4.NewPacketConn(c)
++		cf := ipv4.FlagTTL | ipv4.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		cm := ipv4.ControlMessage{TTL: 1}
++		ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
+ 
+-func benchmarkReadWriteIPv4UDP(b *testing.B, p *ipv4.PacketConn, wb, rb []byte, dst net.Addr, ifi *net.Interface) {
+-	cm := ipv4.ControlMessage{TTL: 1}
+-	if ifi != nil {
+-		cm.IfIndex = ifi.Index
+-	}
+-	if n, err := p.WriteTo(wb, &cm, dst); err != nil {
+-		b.Fatal(err)
+-	} else if n != len(wb) {
+-		b.Fatalf("got %v; want %v", n, len(wb))
+-	}
+-	if _, _, _, err := p.ReadFrom(rb); err != nil {
+-		b.Fatal(err)
+-	}
++		for i := 0; i < b.N; i++ {
++			if _, err := p.WriteTo(wb, &cm, dst); err != nil {
++				b.Fatal(err)
++			}
++			if _, _, _, err := p.ReadFrom(rb); err != nil {
++				b.Fatal(err)
++			}
++		}
++	})
+ }
+ 
+ func TestPacketConnConcurrentReadWriteUnicastUDP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 
+-	c, err := net.ListenPacket("udp4", "127.0.0.1:0")
++	c, err := nettest.NewLocalPacketListener("udp4")
+ 	if err != nil {
+ 		t.Fatal(err)
+ 	}
+@@ -103,11 +73,7 @@
+ 	p := ipv4.NewPacketConn(c)
+ 	defer p.Close()
+ 
+-	dst, err := net.ResolveUDPAddr("udp4", c.LocalAddr().String())
+-	if err != nil {
+-		t.Fatal(err)
+-	}
+-
++	dst := c.LocalAddr()
+ 	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
+ 	cf := ipv4.FlagTTL | ipv4.FlagSrc | ipv4.FlagDst | ipv4.FlagInterface
+ 	wb := []byte("HELLO-R-U-THERE")
+@@ -152,7 +118,7 @@
+ 			t.Error(err)
+ 			return
+ 		} else if n != len(wb) {
+-			t.Errorf("short write: %v", n)
++			t.Errorf("got %d; want %d", n, len(wb))
+ 			return
+ 		}
+ 	}
+diff -uNr go-net.old/ipv4/sockopt.go go-net/ipv4/sockopt.go
+--- go-net.old/ipv4/sockopt.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sockopt.go	2018-05-30 21:01:01.918195966 +0200
+@@ -4,6 +4,8 @@
+ 
+ package ipv4
+ 
++import "golang.org/x/net/internal/socket"
++
+ // Sticky socket options
+ const (
+ 	ssoTOS                = iota // header field for unicast packet
+@@ -24,16 +26,12 @@
+ 	ssoLeaveSourceGroup          // source-specific multicast
+ 	ssoBlockSourceGroup          // any-source or source-specific multicast
+ 	ssoUnblockSourceGroup        // any-source or source-specific multicast
+-	ssoMax
++	ssoAttachFilter              // attach BPF for filtering inbound traffic
+ )
+ 
+ // Sticky socket option value types
+ const (
+-	ssoTypeByte = iota + 1
+-	ssoTypeInt
+-	ssoTypeInterface
+-	ssoTypeICMPFilter
+-	ssoTypeIPMreq
++	ssoTypeIPMreq = iota + 1
+ 	ssoTypeIPMreqn
+ 	ssoTypeGroupReq
+ 	ssoTypeGroupSourceReq
+@@ -41,6 +39,6 @@
+ 
+ // A sockOpt represents a binding for sticky socket option.
+ type sockOpt struct {
+-	name int // option name, must be equal or greater than 1
+-	typ  int // option value type, must be equal or greater than 1
++	socket.Option
++	typ int // hint for option value type; optional
+ }
+diff -uNr go-net.old/ipv4/sockopt_posix.go go-net/ipv4/sockopt_posix.go
+--- go-net.old/ipv4/sockopt_posix.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sockopt_posix.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,71 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris windows
++
++package ipv4
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) getMulticastInterface(c *socket.Conn) (*net.Interface, error) {
++	switch so.typ {
++	case ssoTypeIPMreqn:
++		return so.getIPMreqn(c)
++	default:
++		return so.getMulticastIf(c)
++	}
++}
++
++func (so *sockOpt) setMulticastInterface(c *socket.Conn, ifi *net.Interface) error {
++	switch so.typ {
++	case ssoTypeIPMreqn:
++		return so.setIPMreqn(c, ifi, nil)
++	default:
++		return so.setMulticastIf(c, ifi)
++	}
++}
++
++func (so *sockOpt) getICMPFilter(c *socket.Conn) (*ICMPFilter, error) {
++	b := make([]byte, so.Len)
++	n, err := so.Get(c, b)
++	if err != nil {
++		return nil, err
++	}
++	if n != sizeofICMPFilter {
++		return nil, errOpNoSupport
++	}
++	return (*ICMPFilter)(unsafe.Pointer(&b[0])), nil
++}
++
++func (so *sockOpt) setICMPFilter(c *socket.Conn, f *ICMPFilter) error {
++	b := (*[sizeofICMPFilter]byte)(unsafe.Pointer(f))[:sizeofICMPFilter]
++	return so.Set(c, b)
++}
++
++func (so *sockOpt) setGroup(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	switch so.typ {
++	case ssoTypeIPMreq:
++		return so.setIPMreq(c, ifi, grp)
++	case ssoTypeIPMreqn:
++		return so.setIPMreqn(c, ifi, grp)
++	case ssoTypeGroupReq:
++		return so.setGroupReq(c, ifi, grp)
++	default:
++		return errOpNoSupport
++	}
++}
++
++func (so *sockOpt) setSourceGroup(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	return so.setGroupSourceReq(c, ifi, grp, src)
++}
++
++func (so *sockOpt) setBPF(c *socket.Conn, f []bpf.RawInstruction) error {
++	return so.setAttachFilter(c, f)
++}
+diff -uNr go-net.old/ipv4/sockopt_stub.go go-net/ipv4/sockopt_stub.go
+--- go-net.old/ipv4/sockopt_stub.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sockopt_stub.go	2018-05-30 21:01:01.918195966 +0200
+@@ -1,11 +1,42 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9 solaris
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv4
+ 
+-func setInt(fd int, opt *sockOpt, v int) error {
++import (
++	"net"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) getMulticastInterface(c *socket.Conn) (*net.Interface, error) {
++	return nil, errOpNoSupport
++}
++
++func (so *sockOpt) setMulticastInterface(c *socket.Conn, ifi *net.Interface) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) getICMPFilter(c *socket.Conn) (*ICMPFilter, error) {
++	return nil, errOpNoSupport
++}
++
++func (so *sockOpt) setICMPFilter(c *socket.Conn, f *ICMPFilter) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setGroup(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setSourceGroup(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setBPF(c *socket.Conn, f []bpf.RawInstruction) error {
+ 	return errOpNoSupport
+ }
+diff -uNr go-net.old/ipv4/sockopt_test.go go-net/ipv4/sockopt_test.go
+--- go-net.old/ipv4/sockopt_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sockopt_test.go	2018-05-30 21:00:38.874684823 +0200
+@@ -0,0 +1,133 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6_test
++
++import (
++	"fmt"
++	"net"
++	"runtime"
++	"testing"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
++)
++
++var supportsIPv6 bool = nettest.SupportsIPv6()
++
++func TestConnInitiatorPathMTU(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++	if !supportsIPv6 {
++		t.Skip("ipv6 is not supported")
++	}
++
++	ln, err := net.Listen("tcp6", "[::1]:0")
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer ln.Close()
++
++	done := make(chan bool)
++	go acceptor(t, ln, done)
++
++	c, err := net.Dial("tcp6", ln.Addr().String())
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer c.Close()
++
++	if pmtu, err := ipv6.NewConn(c).PathMTU(); err != nil {
++		switch runtime.GOOS {
++		case "darwin": // older darwin kernels don't support IPV6_PATHMTU option
++			t.Logf("not supported on %s", runtime.GOOS)
++		default:
++			t.Fatal(err)
++		}
++	} else {
++		t.Logf("path mtu for %v: %v", c.RemoteAddr(), pmtu)
++	}
++
++	<-done
++}
++
++func TestConnResponderPathMTU(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++	if !supportsIPv6 {
++		t.Skip("ipv6 is not supported")
++	}
++
++	ln, err := net.Listen("tcp6", "[::1]:0")
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer ln.Close()
++
++	done := make(chan bool)
++	go connector(t, "tcp6", ln.Addr().String(), done)
++
++	c, err := ln.Accept()
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer c.Close()
++
++	if pmtu, err := ipv6.NewConn(c).PathMTU(); err != nil {
++		switch runtime.GOOS {
++		case "darwin": // older darwin kernels don't support IPV6_PATHMTU option
++			t.Logf("not supported on %s", runtime.GOOS)
++		default:
++			t.Fatal(err)
++		}
++	} else {
++		t.Logf("path mtu for %v: %v", c.RemoteAddr(), pmtu)
++	}
++
++	<-done
++}
++
++func TestPacketConnChecksum(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++	if !supportsIPv6 {
++		t.Skip("ipv6 is not supported")
++	}
++	if m, ok := nettest.SupportsRawIPSocket(); !ok {
++		t.Skip(m)
++	}
++
++	c, err := net.ListenPacket(fmt.Sprintf("ip6:%d", iana.ProtocolOSPFIGP), "::") // OSPF for IPv6
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer c.Close()
++
++	p := ipv6.NewPacketConn(c)
++	offset := 12 // see RFC 5340
++
++	for _, toggle := range []bool{false, true} {
++		if err := p.SetChecksum(toggle, offset); err != nil {
++			if toggle {
++				t.Fatalf("ipv6.PacketConn.SetChecksum(%v, %v) failed: %v", toggle, offset, err)
++			} else {
++				// Some platforms never allow to disable the kernel
++				// checksum processing.
++				t.Logf("ipv6.PacketConn.SetChecksum(%v, %v) failed: %v", toggle, offset, err)
++			}
++		}
++		if on, offset, err := p.Checksum(); err != nil {
++			t.Fatal(err)
++		} else {
++			t.Logf("kernel checksum processing enabled=%v, offset=%v", on, offset)
++		}
++	}
++}
+diff -uNr go-net.old/ipv4/sys_asmreq.go go-net/ipv4/sys_asmreq.go
+--- go-net.old/ipv4/sys_asmreq.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_asmreq.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,119 @@
++// Copyright 2012 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin dragonfly freebsd netbsd openbsd solaris windows
++
++package ipv4
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setIPMreq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	mreq := ipMreq{Multiaddr: [4]byte{grp[0], grp[1], grp[2], grp[3]}}
++	if err := setIPMreqInterface(&mreq, ifi); err != nil {
++		return err
++	}
++	b := (*[sizeofIPMreq]byte)(unsafe.Pointer(&mreq))[:sizeofIPMreq]
++	return so.Set(c, b)
++}
++
++func (so *sockOpt) getMulticastIf(c *socket.Conn) (*net.Interface, error) {
++	var b [4]byte
++	if _, err := so.Get(c, b[:]); err != nil {
++		return nil, err
++	}
++	ifi, err := netIP4ToInterface(net.IPv4(b[0], b[1], b[2], b[3]))
++	if err != nil {
++		return nil, err
++	}
++	return ifi, nil
++}
++
++func (so *sockOpt) setMulticastIf(c *socket.Conn, ifi *net.Interface) error {
++	ip, err := netInterfaceToIP4(ifi)
++	if err != nil {
++		return err
++	}
++	var b [4]byte
++	copy(b[:], ip)
++	return so.Set(c, b[:])
++}
++
++func setIPMreqInterface(mreq *ipMreq, ifi *net.Interface) error {
++	if ifi == nil {
++		return nil
++	}
++	ifat, err := ifi.Addrs()
++	if err != nil {
++		return err
++	}
++	for _, ifa := range ifat {
++		switch ifa := ifa.(type) {
++		case *net.IPAddr:
++			if ip := ifa.IP.To4(); ip != nil {
++				copy(mreq.Interface[:], ip)
++				return nil
++			}
++		case *net.IPNet:
++			if ip := ifa.IP.To4(); ip != nil {
++				copy(mreq.Interface[:], ip)
++				return nil
++			}
++		}
++	}
++	return errNoSuchInterface
++}
++
++func netIP4ToInterface(ip net.IP) (*net.Interface, error) {
++	ift, err := net.Interfaces()
++	if err != nil {
++		return nil, err
++	}
++	for _, ifi := range ift {
++		ifat, err := ifi.Addrs()
++		if err != nil {
++			return nil, err
++		}
++		for _, ifa := range ifat {
++			switch ifa := ifa.(type) {
++			case *net.IPAddr:
++				if ip.Equal(ifa.IP) {
++					return &ifi, nil
++				}
++			case *net.IPNet:
++				if ip.Equal(ifa.IP) {
++					return &ifi, nil
++				}
++			}
++		}
++	}
++	return nil, errNoSuchInterface
++}
++
++func netInterfaceToIP4(ifi *net.Interface) (net.IP, error) {
++	if ifi == nil {
++		return net.IPv4zero.To4(), nil
++	}
++	ifat, err := ifi.Addrs()
++	if err != nil {
++		return nil, err
++	}
++	for _, ifa := range ifat {
++		switch ifa := ifa.(type) {
++		case *net.IPAddr:
++			if ip := ifa.IP.To4(); ip != nil {
++				return ip, nil
++			}
++		case *net.IPNet:
++			if ip := ifa.IP.To4(); ip != nil {
++				return ip, nil
++			}
++		}
++	}
++	return nil, errNoSuchInterface
++}
+diff -uNr go-net.old/ipv4/sys_asmreqn.go go-net/ipv4/sys_asmreqn.go
+--- go-net.old/ipv4/sys_asmreqn.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_asmreqn.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,42 @@
++// Copyright 2014 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin freebsd linux
++
++package ipv4
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) getIPMreqn(c *socket.Conn) (*net.Interface, error) {
++	b := make([]byte, so.Len)
++	if _, err := so.Get(c, b); err != nil {
++		return nil, err
++	}
++	mreqn := (*ipMreqn)(unsafe.Pointer(&b[0]))
++	if mreqn.Ifindex == 0 {
++		return nil, nil
++	}
++	ifi, err := net.InterfaceByIndex(int(mreqn.Ifindex))
++	if err != nil {
++		return nil, err
++	}
++	return ifi, nil
++}
++
++func (so *sockOpt) setIPMreqn(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	var mreqn ipMreqn
++	if ifi != nil {
++		mreqn.Ifindex = int32(ifi.Index)
++	}
++	if grp != nil {
++		mreqn.Multiaddr = [4]byte{grp[0], grp[1], grp[2], grp[3]}
++	}
++	b := (*[sizeofIPMreqn]byte)(unsafe.Pointer(&mreqn))[:sizeofIPMreqn]
++	return so.Set(c, b)
++}
+diff -uNr go-net.old/ipv4/sys_asmreqn_stub.go go-net/ipv4/sys_asmreqn_stub.go
+--- go-net.old/ipv4/sys_asmreqn_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_asmreqn_stub.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,21 @@
++// Copyright 2014 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !darwin,!freebsd,!linux
++
++package ipv4
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) getIPMreqn(c *socket.Conn) (*net.Interface, error) {
++	return nil, errOpNoSupport
++}
++
++func (so *sockOpt) setIPMreqn(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv4/sys_asmreq_stub.go go-net/ipv4/sys_asmreq_stub.go
+--- go-net.old/ipv4/sys_asmreq_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_asmreq_stub.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,25 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !darwin,!dragonfly,!freebsd,!netbsd,!openbsd,!solaris,!windows
++
++package ipv4
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setIPMreq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) getMulticastIf(c *socket.Conn) (*net.Interface, error) {
++	return nil, errOpNoSupport
++}
++
++func (so *sockOpt) setMulticastIf(c *socket.Conn, ifi *net.Interface) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv4/sys_bpf.go go-net/ipv4/sys_bpf.go
+--- go-net.old/ipv4/sys_bpf.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_bpf.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,23 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build linux
++
++package ipv4
++
++import (
++	"unsafe"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setAttachFilter(c *socket.Conn, f []bpf.RawInstruction) error {
++	prog := sockFProg{
++		Len:    uint16(len(f)),
++		Filter: (*sockFilter)(unsafe.Pointer(&f[0])),
++	}
++	b := (*[sizeofSockFprog]byte)(unsafe.Pointer(&prog))[:sizeofSockFprog]
++	return so.Set(c, b)
++}
+diff -uNr go-net.old/ipv4/sys_bpf_stub.go go-net/ipv4/sys_bpf_stub.go
+--- go-net.old/ipv4/sys_bpf_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_bpf_stub.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,16 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !linux
++
++package ipv4
++
++import (
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setAttachFilter(c *socket.Conn, f []bpf.RawInstruction) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv4/sys_bsd.go go-net/ipv4/sys_bsd.go
+--- go-net.old/ipv4/sys_bsd.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sys_bsd.go	2018-05-30 21:01:01.918195966 +0200
+@@ -2,16 +2,17 @@
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build dragonfly netbsd
++// +build netbsd openbsd
+ 
+ package ipv4
+ 
+ import (
+ 	"net"
+ 	"syscall"
+-)
+ 
+-type sysSockoptLen int32
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
+ 
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+@@ -20,17 +21,17 @@
+ 		ctlInterface: {sysIP_RECVIF, syscall.SizeofSockaddrDatalink, marshalInterface, parseInterface},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTOS:                {sysIP_TOS, ssoTypeInt},
+-		ssoTTL:                {sysIP_TTL, ssoTypeInt},
+-		ssoMulticastTTL:       {sysIP_MULTICAST_TTL, ssoTypeByte},
+-		ssoMulticastInterface: {sysIP_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastLoopback:  {sysIP_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTTL:         {sysIP_RECVTTL, ssoTypeInt},
+-		ssoReceiveDst:         {sysIP_RECVDSTADDR, ssoTypeInt},
+-		ssoReceiveInterface:   {sysIP_RECVIF, ssoTypeInt},
+-		ssoHeaderPrepend:      {sysIP_HDRINCL, ssoTypeInt},
+-		ssoJoinGroup:          {sysIP_ADD_MEMBERSHIP, ssoTypeIPMreq},
+-		ssoLeaveGroup:         {sysIP_DROP_MEMBERSHIP, ssoTypeIPMreq},
++	sockOpts = map[int]*sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 1}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 1}},
++		ssoReceiveTTL:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVTTL, Len: 4}},
++		ssoReceiveDst:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVDSTADDR, Len: 4}},
++		ssoReceiveInterface:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVIF, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_ADD_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_DROP_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
+ 	}
+ )
+diff -uNr go-net.old/ipv4/sys_darwin.go go-net/ipv4/sys_darwin.go
+--- go-net.old/ipv4/sys_darwin.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sys_darwin.go	2018-05-30 21:01:01.918195966 +0200
+@@ -6,11 +6,14 @@
+ 
+ import (
+ 	"net"
++	"strconv"
++	"strings"
+ 	"syscall"
+ 	"unsafe"
+-)
+ 
+-type sysSockoptLen int32
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
+ 
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+@@ -19,80 +22,72 @@
+ 		ctlInterface: {sysIP_RECVIF, syscall.SizeofSockaddrDatalink, marshalInterface, parseInterface},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTOS:                {sysIP_TOS, ssoTypeInt},
+-		ssoTTL:                {sysIP_TTL, ssoTypeInt},
+-		ssoMulticastTTL:       {sysIP_MULTICAST_TTL, ssoTypeByte},
+-		ssoMulticastInterface: {sysIP_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastLoopback:  {sysIP_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTTL:         {sysIP_RECVTTL, ssoTypeInt},
+-		ssoReceiveDst:         {sysIP_RECVDSTADDR, ssoTypeInt},
+-		ssoReceiveInterface:   {sysIP_RECVIF, ssoTypeInt},
+-		ssoHeaderPrepend:      {sysIP_HDRINCL, ssoTypeInt},
+-		ssoStripHeader:        {sysIP_STRIPHDR, ssoTypeInt},
+-		ssoJoinGroup:          {sysIP_ADD_MEMBERSHIP, ssoTypeIPMreq},
+-		ssoLeaveGroup:         {sysIP_DROP_MEMBERSHIP, ssoTypeIPMreq},
++	sockOpts = map[int]*sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 1}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTTL:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVTTL, Len: 4}},
++		ssoReceiveDst:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVDSTADDR, Len: 4}},
++		ssoReceiveInterface:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVIF, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoStripHeader:        {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_STRIPHDR, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_ADD_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_DROP_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
+ 	}
+ )
+ 
+ func init() {
+ 	// Seems like kern.osreldate is veiled on latest OS X. We use
+ 	// kern.osrelease instead.
+-	osver, err := syscall.Sysctl("kern.osrelease")
++	s, err := syscall.Sysctl("kern.osrelease")
+ 	if err != nil {
+ 		return
+ 	}
+-	var i int
+-	for i = range osver {
+-		if osver[i] == '.' {
+-			break
+-		}
++	ss := strings.Split(s, ".")
++	if len(ss) == 0 {
++		return
+ 	}
+ 	// The IP_PKTINFO and protocol-independent multicast API were
+-	// introduced in OS X 10.7 (Darwin 11.0.0). But it looks like
+-	// those features require OS X 10.8 (Darwin 12.0.0) and above.
++	// introduced in OS X 10.7 (Darwin 11). But it looks like
++	// those features require OS X 10.8 (Darwin 12) or above.
+ 	// See http://support.apple.com/kb/HT1633.
+-	if i > 2 || i == 2 && osver[0] >= '1' && osver[1] >= '2' {
+-		ctlOpts[ctlPacketInfo].name = sysIP_PKTINFO
+-		ctlOpts[ctlPacketInfo].length = sysSizeofInetPktinfo
+-		ctlOpts[ctlPacketInfo].marshal = marshalPacketInfo
+-		ctlOpts[ctlPacketInfo].parse = parsePacketInfo
+-		sockOpts[ssoPacketInfo].name = sysIP_RECVPKTINFO
+-		sockOpts[ssoPacketInfo].typ = ssoTypeInt
+-		sockOpts[ssoMulticastInterface].typ = ssoTypeIPMreqn
+-		sockOpts[ssoJoinGroup].name = sysMCAST_JOIN_GROUP
+-		sockOpts[ssoJoinGroup].typ = ssoTypeGroupReq
+-		sockOpts[ssoLeaveGroup].name = sysMCAST_LEAVE_GROUP
+-		sockOpts[ssoLeaveGroup].typ = ssoTypeGroupReq
+-		sockOpts[ssoJoinSourceGroup].name = sysMCAST_JOIN_SOURCE_GROUP
+-		sockOpts[ssoJoinSourceGroup].typ = ssoTypeGroupSourceReq
+-		sockOpts[ssoLeaveSourceGroup].name = sysMCAST_LEAVE_SOURCE_GROUP
+-		sockOpts[ssoLeaveSourceGroup].typ = ssoTypeGroupSourceReq
+-		sockOpts[ssoBlockSourceGroup].name = sysMCAST_BLOCK_SOURCE
+-		sockOpts[ssoBlockSourceGroup].typ = ssoTypeGroupSourceReq
+-		sockOpts[ssoUnblockSourceGroup].name = sysMCAST_UNBLOCK_SOURCE
+-		sockOpts[ssoUnblockSourceGroup].typ = ssoTypeGroupSourceReq
++	if mjver, err := strconv.Atoi(ss[0]); err != nil || mjver < 12 {
++		return
+ 	}
++	ctlOpts[ctlPacketInfo].name = sysIP_PKTINFO
++	ctlOpts[ctlPacketInfo].length = sizeofInetPktinfo
++	ctlOpts[ctlPacketInfo].marshal = marshalPacketInfo
++	ctlOpts[ctlPacketInfo].parse = parsePacketInfo
++	sockOpts[ssoPacketInfo] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVPKTINFO, Len: 4}}
++	sockOpts[ssoMulticastInterface] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: sizeofIPMreqn}, typ: ssoTypeIPMreqn}
++	sockOpts[ssoJoinGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq}
++	sockOpts[ssoLeaveGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq}
++	sockOpts[ssoJoinSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
++	sockOpts[ssoLeaveSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
++	sockOpts[ssoBlockSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
++	sockOpts[ssoUnblockSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
+ }
+ 
+-func (pi *sysInetPktinfo) setIfindex(i int) {
++func (pi *inetPktinfo) setIfindex(i int) {
+ 	pi.Ifindex = uint32(i)
+ }
+ 
+-func (gr *sysGroupReq) setGroup(grp net.IP) {
+-	sa := (*sysSockaddrInet)(unsafe.Pointer(&gr.Pad_cgo_0[0]))
+-	sa.Len = sysSizeofSockaddrInet
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(uintptr(unsafe.Pointer(gr)) + 4))
++	sa.Len = sizeofSockaddrInet
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], grp)
+ }
+ 
+-func (gsr *sysGroupSourceReq) setSourceGroup(grp, src net.IP) {
+-	sa := (*sysSockaddrInet)(unsafe.Pointer(&gsr.Pad_cgo_0[0]))
+-	sa.Len = sysSizeofSockaddrInet
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 4))
++	sa.Len = sizeofSockaddrInet
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], grp)
+-	sa = (*sysSockaddrInet)(unsafe.Pointer(&gsr.Pad_cgo_1[0]))
+-	sa.Len = sysSizeofSockaddrInet
++	sa = (*sockaddrInet)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 132))
++	sa.Len = sizeofSockaddrInet
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], src)
+ }
+diff -uNr go-net.old/ipv4/sys_dragonfly.go go-net/ipv4/sys_dragonfly.go
+--- go-net.old/ipv4/sys_dragonfly.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_dragonfly.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,35 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv4
++
++import (
++	"net"
++	"syscall"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
++
++var (
++	ctlOpts = [ctlMax]ctlOpt{
++		ctlTTL:       {sysIP_RECVTTL, 1, marshalTTL, parseTTL},
++		ctlDst:       {sysIP_RECVDSTADDR, net.IPv4len, marshalDst, parseDst},
++		ctlInterface: {sysIP_RECVIF, syscall.SizeofSockaddrDatalink, marshalInterface, parseInterface},
++	}
++
++	sockOpts = map[int]*sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 1}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTTL:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVTTL, Len: 4}},
++		ssoReceiveDst:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVDSTADDR, Len: 4}},
++		ssoReceiveInterface:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVIF, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_ADD_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_DROP_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
++	}
++)
+diff -uNr go-net.old/ipv4/sys_freebsd.go go-net/ipv4/sys_freebsd.go
+--- go-net.old/ipv4/sys_freebsd.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sys_freebsd.go	2018-05-30 21:01:01.918195966 +0200
+@@ -10,9 +10,10 @@
+ 	"strings"
+ 	"syscall"
+ 	"unsafe"
+-)
+ 
+-type sysSockoptLen int32
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
+ 
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+@@ -21,29 +22,29 @@
+ 		ctlInterface: {sysIP_RECVIF, syscall.SizeofSockaddrDatalink, marshalInterface, parseInterface},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTOS:                {sysIP_TOS, ssoTypeInt},
+-		ssoTTL:                {sysIP_TTL, ssoTypeInt},
+-		ssoMulticastTTL:       {sysIP_MULTICAST_TTL, ssoTypeByte},
+-		ssoMulticastInterface: {sysIP_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastLoopback:  {sysIP_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTTL:         {sysIP_RECVTTL, ssoTypeInt},
+-		ssoReceiveDst:         {sysIP_RECVDSTADDR, ssoTypeInt},
+-		ssoReceiveInterface:   {sysIP_RECVIF, ssoTypeInt},
+-		ssoHeaderPrepend:      {sysIP_HDRINCL, ssoTypeInt},
+-		ssoJoinGroup:          {sysMCAST_JOIN_GROUP, ssoTypeGroupReq},
+-		ssoLeaveGroup:         {sysMCAST_LEAVE_GROUP, ssoTypeGroupReq},
+-		ssoJoinSourceGroup:    {sysMCAST_JOIN_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoLeaveSourceGroup:   {sysMCAST_LEAVE_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoBlockSourceGroup:   {sysMCAST_BLOCK_SOURCE, ssoTypeGroupSourceReq},
+-		ssoUnblockSourceGroup: {sysMCAST_UNBLOCK_SOURCE, ssoTypeGroupSourceReq},
++	sockOpts = map[int]*sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 1}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTTL:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVTTL, Len: 4}},
++		ssoReceiveDst:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVDSTADDR, Len: 4}},
++		ssoReceiveInterface:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVIF, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoJoinSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoLeaveSourceGroup:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoBlockSourceGroup:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoUnblockSourceGroup: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
+ 	}
+ )
+ 
+ func init() {
+ 	freebsdVersion, _ = syscall.SysctlUint32("kern.osreldate")
+ 	if freebsdVersion >= 1000000 {
+-		sockOpts[ssoMulticastInterface].typ = ssoTypeIPMreqn
++		sockOpts[ssoMulticastInterface] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: sizeofIPMreqn}, typ: ssoTypeIPMreqn}
+ 	}
+ 	if runtime.GOOS == "freebsd" && runtime.GOARCH == "386" {
+ 		archs, _ := syscall.Sysctl("kern.supported_archs")
+@@ -56,20 +57,20 @@
+ 	}
+ }
+ 
+-func (gr *sysGroupReq) setGroup(grp net.IP) {
+-	sa := (*sysSockaddrInet)(unsafe.Pointer(&gr.Group))
+-	sa.Len = sysSizeofSockaddrInet
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(&gr.Group))
++	sa.Len = sizeofSockaddrInet
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], grp)
+ }
+ 
+-func (gsr *sysGroupSourceReq) setSourceGroup(grp, src net.IP) {
+-	sa := (*sysSockaddrInet)(unsafe.Pointer(&gsr.Group))
+-	sa.Len = sysSizeofSockaddrInet
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(&gsr.Group))
++	sa.Len = sizeofSockaddrInet
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], grp)
+-	sa = (*sysSockaddrInet)(unsafe.Pointer(&gsr.Source))
+-	sa.Len = sysSizeofSockaddrInet
++	sa = (*sockaddrInet)(unsafe.Pointer(&gsr.Source))
++	sa.Len = sizeofSockaddrInet
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], src)
+ }
+diff -uNr go-net.old/ipv4/sys_linux.go go-net/ipv4/sys_linux.go
+--- go-net.old/ipv4/sys_linux.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sys_linux.go	2018-05-30 21:01:01.918195966 +0200
+@@ -8,50 +8,52 @@
+ 	"net"
+ 	"syscall"
+ 	"unsafe"
+-)
+ 
+-type sysSockoptLen int32
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
+ 
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+ 		ctlTTL:        {sysIP_TTL, 1, marshalTTL, parseTTL},
+-		ctlPacketInfo: {sysIP_PKTINFO, sysSizeofInetPktinfo, marshalPacketInfo, parsePacketInfo},
++		ctlPacketInfo: {sysIP_PKTINFO, sizeofInetPktinfo, marshalPacketInfo, parsePacketInfo},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTOS:                {sysIP_TOS, ssoTypeInt},
+-		ssoTTL:                {sysIP_TTL, ssoTypeInt},
+-		ssoMulticastTTL:       {sysIP_MULTICAST_TTL, ssoTypeInt},
+-		ssoMulticastInterface: {sysIP_MULTICAST_IF, ssoTypeIPMreqn},
+-		ssoMulticastLoopback:  {sysIP_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTTL:         {sysIP_RECVTTL, ssoTypeInt},
+-		ssoPacketInfo:         {sysIP_PKTINFO, ssoTypeInt},
+-		ssoHeaderPrepend:      {sysIP_HDRINCL, ssoTypeInt},
+-		ssoICMPFilter:         {sysICMP_FILTER, ssoTypeICMPFilter},
+-		ssoJoinGroup:          {sysMCAST_JOIN_GROUP, ssoTypeGroupReq},
+-		ssoLeaveGroup:         {sysMCAST_LEAVE_GROUP, ssoTypeGroupReq},
+-		ssoJoinSourceGroup:    {sysMCAST_JOIN_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoLeaveSourceGroup:   {sysMCAST_LEAVE_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoBlockSourceGroup:   {sysMCAST_BLOCK_SOURCE, ssoTypeGroupSourceReq},
+-		ssoUnblockSourceGroup: {sysMCAST_UNBLOCK_SOURCE, ssoTypeGroupSourceReq},
++	sockOpts = map[int]*sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 4}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: sizeofIPMreqn}, typ: ssoTypeIPMreqn},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTTL:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVTTL, Len: 4}},
++		ssoPacketInfo:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_PKTINFO, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoICMPFilter:         {Option: socket.Option{Level: iana.ProtocolReserved, Name: sysICMP_FILTER, Len: sizeofICMPFilter}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoJoinSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoLeaveSourceGroup:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoBlockSourceGroup:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoUnblockSourceGroup: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoAttachFilter:       {Option: socket.Option{Level: sysSOL_SOCKET, Name: sysSO_ATTACH_FILTER, Len: sizeofSockFprog}},
+ 	}
+ )
+ 
+-func (pi *sysInetPktinfo) setIfindex(i int) {
++func (pi *inetPktinfo) setIfindex(i int) {
+ 	pi.Ifindex = int32(i)
+ }
+ 
+-func (gr *sysGroupReq) setGroup(grp net.IP) {
+-	sa := (*sysSockaddrInet)(unsafe.Pointer(&gr.Group))
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(&gr.Group))
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], grp)
+ }
+ 
+-func (gsr *sysGroupSourceReq) setSourceGroup(grp, src net.IP) {
+-	sa := (*sysSockaddrInet)(unsafe.Pointer(&gsr.Group))
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(&gsr.Group))
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], grp)
+-	sa = (*sysSockaddrInet)(unsafe.Pointer(&gsr.Source))
++	sa = (*sockaddrInet)(unsafe.Pointer(&gsr.Source))
+ 	sa.Family = syscall.AF_INET
+ 	copy(sa.Addr[:], src)
+ }
+diff -uNr go-net.old/ipv4/sys_solaris.go go-net/ipv4/sys_solaris.go
+--- go-net.old/ipv4/sys_solaris.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_solaris.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,57 @@
++// Copyright 2016 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv4
++
++import (
++	"net"
++	"syscall"
++	"unsafe"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
++
++var (
++	ctlOpts = [ctlMax]ctlOpt{
++		ctlTTL:        {sysIP_RECVTTL, 4, marshalTTL, parseTTL},
++		ctlPacketInfo: {sysIP_PKTINFO, sizeofInetPktinfo, marshalPacketInfo, parsePacketInfo},
++	}
++
++	sockOpts = map[int]sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 1}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 1}},
++		ssoReceiveTTL:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVTTL, Len: 4}},
++		ssoPacketInfo:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_RECVPKTINFO, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoJoinSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoLeaveSourceGroup:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoBlockSourceGroup:   {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoUnblockSourceGroup: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++	}
++)
++
++func (pi *inetPktinfo) setIfindex(i int) {
++	pi.Ifindex = uint32(i)
++}
++
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(uintptr(unsafe.Pointer(gr)) + 4))
++	sa.Family = syscall.AF_INET
++	copy(sa.Addr[:], grp)
++}
++
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 4))
++	sa.Family = syscall.AF_INET
++	copy(sa.Addr[:], grp)
++	sa = (*sockaddrInet)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 260))
++	sa.Family = syscall.AF_INET
++	copy(sa.Addr[:], src)
++}
+diff -uNr go-net.old/ipv4/sys_ssmreq.go go-net/ipv4/sys_ssmreq.go
+--- go-net.old/ipv4/sys_ssmreq.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_ssmreq.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,54 @@
++// Copyright 2014 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin freebsd linux solaris
++
++package ipv4
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/internal/socket"
++)
++
++var freebsd32o64 bool
++
++func (so *sockOpt) setGroupReq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	var gr groupReq
++	if ifi != nil {
++		gr.Interface = uint32(ifi.Index)
++	}
++	gr.setGroup(grp)
++	var b []byte
++	if freebsd32o64 {
++		var d [sizeofGroupReq + 4]byte
++		s := (*[sizeofGroupReq]byte)(unsafe.Pointer(&gr))
++		copy(d[:4], s[:4])
++		copy(d[8:], s[4:])
++		b = d[:]
++	} else {
++		b = (*[sizeofGroupReq]byte)(unsafe.Pointer(&gr))[:sizeofGroupReq]
++	}
++	return so.Set(c, b)
++}
++
++func (so *sockOpt) setGroupSourceReq(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	var gsr groupSourceReq
++	if ifi != nil {
++		gsr.Interface = uint32(ifi.Index)
++	}
++	gsr.setSourceGroup(grp, src)
++	var b []byte
++	if freebsd32o64 {
++		var d [sizeofGroupSourceReq + 4]byte
++		s := (*[sizeofGroupSourceReq]byte)(unsafe.Pointer(&gsr))
++		copy(d[:4], s[:4])
++		copy(d[8:], s[4:])
++		b = d[:]
++	} else {
++		b = (*[sizeofGroupSourceReq]byte)(unsafe.Pointer(&gsr))[:sizeofGroupSourceReq]
++	}
++	return so.Set(c, b)
++}
+diff -uNr go-net.old/ipv4/sys_ssmreq_stub.go go-net/ipv4/sys_ssmreq_stub.go
+--- go-net.old/ipv4/sys_ssmreq_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/sys_ssmreq_stub.go	2018-05-30 21:01:01.918195966 +0200
+@@ -0,0 +1,21 @@
++// Copyright 2014 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !darwin,!freebsd,!linux,!solaris
++
++package ipv4
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setGroupReq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setGroupSourceReq(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv4/sys_stub.go go-net/ipv4/sys_stub.go
+--- go-net.old/ipv4/sys_stub.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sys_stub.go	2018-05-30 21:01:01.918195966 +0200
+@@ -2,14 +2,12 @@
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9 solaris
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv4
+ 
+-type sysSockoptLen int32
+-
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{}
+ 
+-	sockOpts = [ssoMax]sockOpt{}
++	sockOpts = map[int]*sockOpt{}
+ )
+diff -uNr go-net.old/ipv4/sys_windows.go go-net/ipv4/sys_windows.go
+--- go-net.old/ipv4/sys_windows.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/sys_windows.go	2018-05-30 21:01:01.918195966 +0200
+@@ -4,6 +4,11 @@
+ 
+ package ipv4
+ 
++import (
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
++
+ const (
+ 	// See ws2tcpip.h.
+ 	sysIP_OPTIONS                = 0x1
+@@ -20,22 +25,22 @@
+ 	sysIP_DROP_SOURCE_MEMBERSHIP = 0x10
+ 	sysIP_PKTINFO                = 0x13
+ 
+-	sysSizeofInetPktinfo  = 0x8
+-	sysSizeofIPMreq       = 0x8
+-	sysSizeofIPMreqSource = 0xc
++	sizeofInetPktinfo  = 0x8
++	sizeofIPMreq       = 0x8
++	sizeofIPMreqSource = 0xc
+ )
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Addr    [4]byte
+ 	Ifindex int32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte
+ 	Interface [4]byte
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  [4]byte
+ 	Sourceaddr [4]byte
+ 	Interface  [4]byte
+@@ -45,17 +50,18 @@
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTOS:                {sysIP_TOS, ssoTypeInt},
+-		ssoTTL:                {sysIP_TTL, ssoTypeInt},
+-		ssoMulticastTTL:       {sysIP_MULTICAST_TTL, ssoTypeInt},
+-		ssoMulticastInterface: {sysIP_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastLoopback:  {sysIP_MULTICAST_LOOP, ssoTypeInt},
+-		ssoJoinGroup:          {sysIP_ADD_MEMBERSHIP, ssoTypeIPMreq},
+-		ssoLeaveGroup:         {sysIP_DROP_MEMBERSHIP, ssoTypeIPMreq},
++	sockOpts = map[int]*sockOpt{
++		ssoTOS:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TOS, Len: 4}},
++		ssoTTL:                {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_TTL, Len: 4}},
++		ssoMulticastTTL:       {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_TTL, Len: 4}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_IF, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_MULTICAST_LOOP, Len: 4}},
++		ssoHeaderPrepend:      {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_HDRINCL, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_ADD_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIP, Name: sysIP_DROP_MEMBERSHIP, Len: sizeofIPMreq}, typ: ssoTypeIPMreq},
+ 	}
+ )
+ 
+-func (pi *sysInetPktinfo) setIfindex(i int) {
++func (pi *inetPktinfo) setIfindex(i int) {
+ 	pi.Ifindex = int32(i)
+ }
+diff -uNr go-net.old/ipv4/unicastsockopt_test.go go-net/ipv4/unicastsockopt_test.go
+--- go-net.old/ipv4/unicastsockopt_test.go	2018-05-31 12:15:35.447674508 +0200
++++ go-net/ipv4/unicastsockopt_test.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -9,14 +9,14 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ func TestConnUnicastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
+@@ -30,8 +30,15 @@
+ 	}
+ 	defer ln.Close()
+ 
+-	done := make(chan bool)
+-	go acceptor(t, ln, done)
++	errc := make(chan error, 1)
++	go func() {
++		c, err := ln.Accept()
++		if err != nil {
++			errc <- err
++			return
++		}
++		errc <- c.Close()
++	}()
+ 
+ 	c, err := net.Dial("tcp4", ln.Addr().String())
+ 	if err != nil {
+@@ -41,7 +48,9 @@
+ 
+ 	testUnicastSocketOptions(t, ipv4.NewConn(c))
+ 
+-	<-done
++	if err := <-errc; err != nil {
++		t.Errorf("server: %v", err)
++	}
+ }
+ 
+ var packetConnUnicastSocketOptionTests = []struct {
+@@ -53,7 +62,7 @@
+ 
+ func TestPacketConnUnicastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
+@@ -79,7 +88,7 @@
+ 
+ func TestRawConnUnicastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if m, ok := nettest.SupportsRawIPSocket(); !ok {
+diff -uNr go-net.old/ipv4/unicast_test.go go-net/ipv4/unicast_test.go
+--- go-net.old/ipv4/unicast_test.go	2018-05-31 12:15:35.443674593 +0200
++++ go-net/ipv4/unicast_test.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2012 The Go Authors.  All rights reserved.
++// Copyright 2012 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,15 +12,15 @@
+ 	"testing"
+ 	"time"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/icmp"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv4"
++	"golang.org/x/net/icmp"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv4"
+ )
+ 
+ func TestPacketConnReadWriteUnicastUDP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	ifi := nettest.RoutedInterface("ip4", net.FlagUp|net.FlagLoopback)
+@@ -28,18 +28,15 @@
+ 		t.Skipf("not available on %s", runtime.GOOS)
+ 	}
+ 
+-	c, err := net.ListenPacket("udp4", "127.0.0.1:0")
++	c, err := nettest.NewLocalPacketListener("udp4")
+ 	if err != nil {
+ 		t.Fatal(err)
+ 	}
+ 	defer c.Close()
+-
+-	dst, err := net.ResolveUDPAddr("udp4", c.LocalAddr().String())
+-	if err != nil {
+-		t.Fatal(err)
+-	}
+ 	p := ipv4.NewPacketConn(c)
+ 	defer p.Close()
++
++	dst := c.LocalAddr()
+ 	cf := ipv4.FlagTTL | ipv4.FlagDst | ipv4.FlagInterface
+ 	wb := []byte("HELLO-R-U-THERE")
+ 
+@@ -74,7 +71,7 @@
+ 
+ func TestPacketConnReadWriteUnicastICMP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if m, ok := nettest.SupportsRawIPSocket(); !ok {
+@@ -97,7 +94,11 @@
+ 	}
+ 	p := ipv4.NewPacketConn(c)
+ 	defer p.Close()
+-	cf := ipv4.FlagTTL | ipv4.FlagDst | ipv4.FlagInterface
++	cf := ipv4.FlagDst | ipv4.FlagInterface
++	if runtime.GOOS != "solaris" {
++		// Solaris never allows to modify ICMP properties.
++		cf |= ipv4.FlagTTL
++	}
+ 
+ 	for i, toggle := range []bool{true, false, true} {
+ 		wb, err := (&icmp.Message{
+@@ -156,7 +157,7 @@
+ 
+ func TestRawConnReadWriteUnicastICMP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if m, ok := nettest.SupportsRawIPSocket(); !ok {
+diff -uNr go-net.old/ipv4/zsys_darwin.go go-net/ipv4/zsys_darwin.go
+--- go-net.old/ipv4/zsys_darwin.go	2018-05-31 12:15:22.211956055 +0200
++++ go-net/ipv4/zsys_darwin.go	2018-05-30 21:01:01.922195884 +0200
+@@ -37,18 +37,18 @@
+ 	sysMCAST_BLOCK_SOURCE        = 0x54
+ 	sysMCAST_UNBLOCK_SOURCE      = 0x55
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet    = 0x10
+-	sysSizeofInetPktinfo     = 0xc
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet    = 0x10
++	sizeofInetPktinfo     = 0xc
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -56,7 +56,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Len    uint8
+ 	Family uint8
+ 	Port   uint16
+@@ -64,35 +64,35 @@
+ 	Zero   [8]int8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  uint32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  [4]byte /* in_addr */
+ 	Sourceaddr [4]byte /* in_addr */
+ 	Interface  [4]byte /* in_addr */
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [128]byte
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [128]byte
+ 	Pad_cgo_1 [128]byte
+diff -uNr go-net.old/ipv4/zsys_dragonfly.go go-net/ipv4/zsys_dragonfly.go
+--- go-net.old/ipv4/zsys_dragonfly.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_dragonfly.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_dragonfly.go
+ 
+-// +build dragonfly
+-
+ package ipv4
+ 
+ const (
+@@ -24,10 +22,10 @@
+ 	sysIP_ADD_MEMBERSHIP  = 0xc
+ 	sysIP_DROP_MEMBERSHIP = 0xd
+ 
+-	sysSizeofIPMreq = 0x8
++	sizeofIPMreq = 0x8
+ )
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+diff -uNr go-net.old/ipv4/zsys_freebsd_386.go go-net/ipv4/zsys_freebsd_386.go
+--- go-net.old/ipv4/zsys_freebsd_386.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_freebsd_386.go	2018-05-30 21:01:01.922195884 +0200
+@@ -38,17 +38,17 @@
+ 	sysMCAST_BLOCK_SOURCE        = 0x54
+ 	sysMCAST_UNBLOCK_SOURCE      = 0x55
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet    = 0x10
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet    = 0x10
+ 
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -56,7 +56,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Len    uint8
+ 	Family uint8
+ 	Port   uint16
+@@ -64,30 +64,30 @@
+ 	Zero   [8]int8
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  [4]byte /* in_addr */
+ 	Sourceaddr [4]byte /* in_addr */
+ 	Interface  [4]byte /* in_addr */
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+-	Group     sysSockaddrStorage
++	Group     sockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+-	Group     sysSockaddrStorage
+-	Source    sysSockaddrStorage
++	Group     sockaddrStorage
++	Source    sockaddrStorage
+ }
+diff -uNr go-net.old/ipv4/zsys_freebsd_amd64.go go-net/ipv4/zsys_freebsd_amd64.go
+--- go-net.old/ipv4/zsys_freebsd_amd64.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_freebsd_amd64.go	2018-05-30 21:01:01.922195884 +0200
+@@ -38,17 +38,17 @@
+ 	sysMCAST_BLOCK_SOURCE        = 0x54
+ 	sysMCAST_UNBLOCK_SOURCE      = 0x55
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet    = 0x10
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet    = 0x10
+ 
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -56,7 +56,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Len    uint8
+ 	Family uint8
+ 	Port   uint16
+@@ -64,32 +64,32 @@
+ 	Zero   [8]int8
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  [4]byte /* in_addr */
+ 	Sourceaddr [4]byte /* in_addr */
+ 	Interface  [4]byte /* in_addr */
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
++	Group     sockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
+-	Source    sysSockaddrStorage
++	Group     sockaddrStorage
++	Source    sockaddrStorage
+ }
+diff -uNr go-net.old/ipv4/zsys_freebsd_arm.go go-net/ipv4/zsys_freebsd_arm.go
+--- go-net.old/ipv4/zsys_freebsd_arm.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_freebsd_arm.go	2018-05-30 21:01:01.922195884 +0200
+@@ -38,17 +38,17 @@
+ 	sysMCAST_BLOCK_SOURCE        = 0x54
+ 	sysMCAST_UNBLOCK_SOURCE      = 0x55
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet    = 0x10
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet    = 0x10
+ 
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -56,7 +56,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Len    uint8
+ 	Family uint8
+ 	Port   uint16
+@@ -64,32 +64,32 @@
+ 	Zero   [8]int8
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  [4]byte /* in_addr */
+ 	Sourceaddr [4]byte /* in_addr */
+ 	Interface  [4]byte /* in_addr */
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
++	Group     sockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
+-	Source    sysSockaddrStorage
++	Group     sockaddrStorage
++	Source    sockaddrStorage
+ }
+diff -uNr go-net.old/ipv4/zsys_linux_386.go go-net/ipv4/zsys_linux_386.go
+--- go-net.old/ipv4/zsys_linux_386.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_linux_386.go	2018-05-30 21:01:01.922195884 +0200
+@@ -55,39 +55,44 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet          = 0x10
+-	sysSizeofInetPktinfo           = 0xc
+-	sysSizeofSockExtendedErr       = 0x10
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
+ 
+-	sysSizeofICMPFilter = 0x4
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x8
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Family uint16
+ 	Port   uint16
+ 	Addr   [4]byte /* in_addr */
+ 	X__pad [8]uint8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  int32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysSockExtendedErr struct {
++type sockExtendedErr struct {
+ 	Errno  uint32
+ 	Origin uint8
+ 	Type   uint8
+@@ -97,34 +102,47 @@
+ 	Data   uint32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  uint32
+ 	Interface  uint32
+ 	Sourceaddr uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ 	Data uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_amd64.go go-net/ipv4/zsys_linux_amd64.go
+--- go-net.old/ipv4/zsys_linux_amd64.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_linux_amd64.go	2018-05-30 21:01:01.922195884 +0200
+@@ -55,39 +55,44 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet          = 0x10
+-	sysSizeofInetPktinfo           = 0xc
+-	sysSizeofSockExtendedErr       = 0x10
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
+ 
+-	sysSizeofICMPFilter = 0x4
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Family uint16
+ 	Port   uint16
+ 	Addr   [4]byte /* in_addr */
+ 	X__pad [8]uint8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  int32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysSockExtendedErr struct {
++type sockExtendedErr struct {
+ 	Errno  uint32
+ 	Origin uint8
+ 	Type   uint8
+@@ -97,36 +102,49 @@
+ 	Data   uint32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  uint32
+ 	Interface  uint32
+ 	Sourceaddr uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ 	Data uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_arm64.go go-net/ipv4/zsys_linux_arm64.go
+--- go-net.old/ipv4/zsys_linux_arm64.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_linux_arm64.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_linux.go
+ 
+-// +build linux,arm64
+-
+ package ipv4
+ 
+ const (
+@@ -57,39 +55,44 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet          = 0x10
+-	sysSizeofInetPktinfo           = 0xc
+-	sysSizeofSockExtendedErr       = 0x10
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPFilter = 0x4
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Family uint16
+ 	Port   uint16
+ 	Addr   [4]byte /* in_addr */
+ 	X__pad [8]uint8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  int32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysSockExtendedErr struct {
++type sockExtendedErr struct {
+ 	Errno  uint32
+ 	Origin uint8
+ 	Type   uint8
+@@ -99,36 +102,49 @@
+ 	Data   uint32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  uint32
+ 	Interface  uint32
+ 	Sourceaddr uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ 	Data uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_arm.go go-net/ipv4/zsys_linux_arm.go
+--- go-net.old/ipv4/zsys_linux_arm.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_linux_arm.go	2018-05-30 21:01:01.922195884 +0200
+@@ -55,39 +55,44 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet          = 0x10
+-	sysSizeofInetPktinfo           = 0xc
+-	sysSizeofSockExtendedErr       = 0x10
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
+ 
+-	sysSizeofICMPFilter = 0x4
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x8
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Family uint16
+ 	Port   uint16
+ 	Addr   [4]byte /* in_addr */
+ 	X__pad [8]uint8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  int32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysSockExtendedErr struct {
++type sockExtendedErr struct {
+ 	Errno  uint32
+ 	Origin uint8
+ 	Type   uint8
+@@ -97,34 +102,47 @@
+ 	Data   uint32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  uint32
+ 	Interface  uint32
+ 	Sourceaddr uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ 	Data uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_mips64.go go-net/ipv4/zsys_linux_mips64.go
+--- go-net.old/ipv4/zsys_linux_mips64.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/zsys_linux_mips64.go	2018-05-30 21:01:01.922195884 +0200
+@@ -0,0 +1,150 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv4
++
++const (
++	sysIP_TOS             = 0x1
++	sysIP_TTL             = 0x2
++	sysIP_HDRINCL         = 0x3
++	sysIP_OPTIONS         = 0x4
++	sysIP_ROUTER_ALERT    = 0x5
++	sysIP_RECVOPTS        = 0x6
++	sysIP_RETOPTS         = 0x7
++	sysIP_PKTINFO         = 0x8
++	sysIP_PKTOPTIONS      = 0x9
++	sysIP_MTU_DISCOVER    = 0xa
++	sysIP_RECVERR         = 0xb
++	sysIP_RECVTTL         = 0xc
++	sysIP_RECVTOS         = 0xd
++	sysIP_MTU             = 0xe
++	sysIP_FREEBIND        = 0xf
++	sysIP_TRANSPARENT     = 0x13
++	sysIP_RECVRETOPTS     = 0x7
++	sysIP_ORIGDSTADDR     = 0x14
++	sysIP_RECVORIGDSTADDR = 0x14
++	sysIP_MINTTL          = 0x15
++	sysIP_NODEFRAG        = 0x16
++	sysIP_UNICAST_IF      = 0x32
++
++	sysIP_MULTICAST_IF           = 0x20
++	sysIP_MULTICAST_TTL          = 0x21
++	sysIP_MULTICAST_LOOP         = 0x22
++	sysIP_ADD_MEMBERSHIP         = 0x23
++	sysIP_DROP_MEMBERSHIP        = 0x24
++	sysIP_UNBLOCK_SOURCE         = 0x25
++	sysIP_BLOCK_SOURCE           = 0x26
++	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x27
++	sysIP_DROP_SOURCE_MEMBERSHIP = 0x28
++	sysIP_MSFILTER               = 0x29
++	sysMCAST_JOIN_GROUP          = 0x2a
++	sysMCAST_LEAVE_GROUP         = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP   = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP  = 0x2f
++	sysMCAST_BLOCK_SOURCE        = 0x2b
++	sysMCAST_UNBLOCK_SOURCE      = 0x2c
++	sysMCAST_MSFILTER            = 0x30
++	sysIP_MULTICAST_ALL          = 0x31
++
++	sysICMP_FILTER = 0x1
++
++	sysSO_EE_ORIGIN_NONE         = 0x0
++	sysSO_EE_ORIGIN_LOCAL        = 0x1
++	sysSO_EE_ORIGIN_ICMP         = 0x2
++	sysSO_EE_ORIGIN_ICMP6        = 0x3
++	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
++	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	X__pad [8]uint8
++}
++
++type inetPktinfo struct {
++	Ifindex  int32
++	Spec_dst [4]byte /* in_addr */
++	Addr     [4]byte /* in_addr */
++}
++
++type sockExtendedErr struct {
++	Errno  uint32
++	Origin uint8
++	Type   uint8
++	Code   uint8
++	Pad    uint8
++	Info   uint32
++	Data   uint32
++}
++
++type ipMreq struct {
++	Multiaddr [4]byte /* in_addr */
++	Interface [4]byte /* in_addr */
++}
++
++type ipMreqn struct {
++	Multiaddr [4]byte /* in_addr */
++	Address   [4]byte /* in_addr */
++	Ifindex   int32
++}
++
++type ipMreqSource struct {
++	Multiaddr  uint32
++	Interface  uint32
++	Sourceaddr uint32
++}
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpFilter struct {
++	Data uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_mips64le.go go-net/ipv4/zsys_linux_mips64le.go
+--- go-net.old/ipv4/zsys_linux_mips64le.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/zsys_linux_mips64le.go	2018-05-30 21:01:01.922195884 +0200
+@@ -0,0 +1,150 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv4
++
++const (
++	sysIP_TOS             = 0x1
++	sysIP_TTL             = 0x2
++	sysIP_HDRINCL         = 0x3
++	sysIP_OPTIONS         = 0x4
++	sysIP_ROUTER_ALERT    = 0x5
++	sysIP_RECVOPTS        = 0x6
++	sysIP_RETOPTS         = 0x7
++	sysIP_PKTINFO         = 0x8
++	sysIP_PKTOPTIONS      = 0x9
++	sysIP_MTU_DISCOVER    = 0xa
++	sysIP_RECVERR         = 0xb
++	sysIP_RECVTTL         = 0xc
++	sysIP_RECVTOS         = 0xd
++	sysIP_MTU             = 0xe
++	sysIP_FREEBIND        = 0xf
++	sysIP_TRANSPARENT     = 0x13
++	sysIP_RECVRETOPTS     = 0x7
++	sysIP_ORIGDSTADDR     = 0x14
++	sysIP_RECVORIGDSTADDR = 0x14
++	sysIP_MINTTL          = 0x15
++	sysIP_NODEFRAG        = 0x16
++	sysIP_UNICAST_IF      = 0x32
++
++	sysIP_MULTICAST_IF           = 0x20
++	sysIP_MULTICAST_TTL          = 0x21
++	sysIP_MULTICAST_LOOP         = 0x22
++	sysIP_ADD_MEMBERSHIP         = 0x23
++	sysIP_DROP_MEMBERSHIP        = 0x24
++	sysIP_UNBLOCK_SOURCE         = 0x25
++	sysIP_BLOCK_SOURCE           = 0x26
++	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x27
++	sysIP_DROP_SOURCE_MEMBERSHIP = 0x28
++	sysIP_MSFILTER               = 0x29
++	sysMCAST_JOIN_GROUP          = 0x2a
++	sysMCAST_LEAVE_GROUP         = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP   = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP  = 0x2f
++	sysMCAST_BLOCK_SOURCE        = 0x2b
++	sysMCAST_UNBLOCK_SOURCE      = 0x2c
++	sysMCAST_MSFILTER            = 0x30
++	sysIP_MULTICAST_ALL          = 0x31
++
++	sysICMP_FILTER = 0x1
++
++	sysSO_EE_ORIGIN_NONE         = 0x0
++	sysSO_EE_ORIGIN_LOCAL        = 0x1
++	sysSO_EE_ORIGIN_ICMP         = 0x2
++	sysSO_EE_ORIGIN_ICMP6        = 0x3
++	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
++	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	X__pad [8]uint8
++}
++
++type inetPktinfo struct {
++	Ifindex  int32
++	Spec_dst [4]byte /* in_addr */
++	Addr     [4]byte /* in_addr */
++}
++
++type sockExtendedErr struct {
++	Errno  uint32
++	Origin uint8
++	Type   uint8
++	Code   uint8
++	Pad    uint8
++	Info   uint32
++	Data   uint32
++}
++
++type ipMreq struct {
++	Multiaddr [4]byte /* in_addr */
++	Interface [4]byte /* in_addr */
++}
++
++type ipMreqn struct {
++	Multiaddr [4]byte /* in_addr */
++	Address   [4]byte /* in_addr */
++	Ifindex   int32
++}
++
++type ipMreqSource struct {
++	Multiaddr  uint32
++	Interface  uint32
++	Sourceaddr uint32
++}
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpFilter struct {
++	Data uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_mips.go go-net/ipv4/zsys_linux_mips.go
+--- go-net.old/ipv4/zsys_linux_mips.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/zsys_linux_mips.go	2018-05-30 21:01:01.922195884 +0200
+@@ -0,0 +1,148 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv4
++
++const (
++	sysIP_TOS             = 0x1
++	sysIP_TTL             = 0x2
++	sysIP_HDRINCL         = 0x3
++	sysIP_OPTIONS         = 0x4
++	sysIP_ROUTER_ALERT    = 0x5
++	sysIP_RECVOPTS        = 0x6
++	sysIP_RETOPTS         = 0x7
++	sysIP_PKTINFO         = 0x8
++	sysIP_PKTOPTIONS      = 0x9
++	sysIP_MTU_DISCOVER    = 0xa
++	sysIP_RECVERR         = 0xb
++	sysIP_RECVTTL         = 0xc
++	sysIP_RECVTOS         = 0xd
++	sysIP_MTU             = 0xe
++	sysIP_FREEBIND        = 0xf
++	sysIP_TRANSPARENT     = 0x13
++	sysIP_RECVRETOPTS     = 0x7
++	sysIP_ORIGDSTADDR     = 0x14
++	sysIP_RECVORIGDSTADDR = 0x14
++	sysIP_MINTTL          = 0x15
++	sysIP_NODEFRAG        = 0x16
++	sysIP_UNICAST_IF      = 0x32
++
++	sysIP_MULTICAST_IF           = 0x20
++	sysIP_MULTICAST_TTL          = 0x21
++	sysIP_MULTICAST_LOOP         = 0x22
++	sysIP_ADD_MEMBERSHIP         = 0x23
++	sysIP_DROP_MEMBERSHIP        = 0x24
++	sysIP_UNBLOCK_SOURCE         = 0x25
++	sysIP_BLOCK_SOURCE           = 0x26
++	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x27
++	sysIP_DROP_SOURCE_MEMBERSHIP = 0x28
++	sysIP_MSFILTER               = 0x29
++	sysMCAST_JOIN_GROUP          = 0x2a
++	sysMCAST_LEAVE_GROUP         = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP   = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP  = 0x2f
++	sysMCAST_BLOCK_SOURCE        = 0x2b
++	sysMCAST_UNBLOCK_SOURCE      = 0x2c
++	sysMCAST_MSFILTER            = 0x30
++	sysIP_MULTICAST_ALL          = 0x31
++
++	sysICMP_FILTER = 0x1
++
++	sysSO_EE_ORIGIN_NONE         = 0x0
++	sysSO_EE_ORIGIN_LOCAL        = 0x1
++	sysSO_EE_ORIGIN_ICMP         = 0x2
++	sysSO_EE_ORIGIN_ICMP6        = 0x3
++	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
++	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x8
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	X__pad [8]uint8
++}
++
++type inetPktinfo struct {
++	Ifindex  int32
++	Spec_dst [4]byte /* in_addr */
++	Addr     [4]byte /* in_addr */
++}
++
++type sockExtendedErr struct {
++	Errno  uint32
++	Origin uint8
++	Type   uint8
++	Code   uint8
++	Pad    uint8
++	Info   uint32
++	Data   uint32
++}
++
++type ipMreq struct {
++	Multiaddr [4]byte /* in_addr */
++	Interface [4]byte /* in_addr */
++}
++
++type ipMreqn struct {
++	Multiaddr [4]byte /* in_addr */
++	Address   [4]byte /* in_addr */
++	Ifindex   int32
++}
++
++type ipMreqSource struct {
++	Multiaddr  uint32
++	Interface  uint32
++	Sourceaddr uint32
++}
++
++type groupReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpFilter struct {
++	Data uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_mipsle.go go-net/ipv4/zsys_linux_mipsle.go
+--- go-net.old/ipv4/zsys_linux_mipsle.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/zsys_linux_mipsle.go	2018-05-30 21:01:01.922195884 +0200
+@@ -0,0 +1,148 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv4
++
++const (
++	sysIP_TOS             = 0x1
++	sysIP_TTL             = 0x2
++	sysIP_HDRINCL         = 0x3
++	sysIP_OPTIONS         = 0x4
++	sysIP_ROUTER_ALERT    = 0x5
++	sysIP_RECVOPTS        = 0x6
++	sysIP_RETOPTS         = 0x7
++	sysIP_PKTINFO         = 0x8
++	sysIP_PKTOPTIONS      = 0x9
++	sysIP_MTU_DISCOVER    = 0xa
++	sysIP_RECVERR         = 0xb
++	sysIP_RECVTTL         = 0xc
++	sysIP_RECVTOS         = 0xd
++	sysIP_MTU             = 0xe
++	sysIP_FREEBIND        = 0xf
++	sysIP_TRANSPARENT     = 0x13
++	sysIP_RECVRETOPTS     = 0x7
++	sysIP_ORIGDSTADDR     = 0x14
++	sysIP_RECVORIGDSTADDR = 0x14
++	sysIP_MINTTL          = 0x15
++	sysIP_NODEFRAG        = 0x16
++	sysIP_UNICAST_IF      = 0x32
++
++	sysIP_MULTICAST_IF           = 0x20
++	sysIP_MULTICAST_TTL          = 0x21
++	sysIP_MULTICAST_LOOP         = 0x22
++	sysIP_ADD_MEMBERSHIP         = 0x23
++	sysIP_DROP_MEMBERSHIP        = 0x24
++	sysIP_UNBLOCK_SOURCE         = 0x25
++	sysIP_BLOCK_SOURCE           = 0x26
++	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x27
++	sysIP_DROP_SOURCE_MEMBERSHIP = 0x28
++	sysIP_MSFILTER               = 0x29
++	sysMCAST_JOIN_GROUP          = 0x2a
++	sysMCAST_LEAVE_GROUP         = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP   = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP  = 0x2f
++	sysMCAST_BLOCK_SOURCE        = 0x2b
++	sysMCAST_UNBLOCK_SOURCE      = 0x2c
++	sysMCAST_MSFILTER            = 0x30
++	sysIP_MULTICAST_ALL          = 0x31
++
++	sysICMP_FILTER = 0x1
++
++	sysSO_EE_ORIGIN_NONE         = 0x0
++	sysSO_EE_ORIGIN_LOCAL        = 0x1
++	sysSO_EE_ORIGIN_ICMP         = 0x2
++	sysSO_EE_ORIGIN_ICMP6        = 0x3
++	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
++	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x8
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	X__pad [8]uint8
++}
++
++type inetPktinfo struct {
++	Ifindex  int32
++	Spec_dst [4]byte /* in_addr */
++	Addr     [4]byte /* in_addr */
++}
++
++type sockExtendedErr struct {
++	Errno  uint32
++	Origin uint8
++	Type   uint8
++	Code   uint8
++	Pad    uint8
++	Info   uint32
++	Data   uint32
++}
++
++type ipMreq struct {
++	Multiaddr [4]byte /* in_addr */
++	Interface [4]byte /* in_addr */
++}
++
++type ipMreqn struct {
++	Multiaddr [4]byte /* in_addr */
++	Address   [4]byte /* in_addr */
++	Ifindex   int32
++}
++
++type ipMreqSource struct {
++	Multiaddr  uint32
++	Interface  uint32
++	Sourceaddr uint32
++}
++
++type groupReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpFilter struct {
++	Data uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_ppc64.go go-net/ipv4/zsys_linux_ppc64.go
+--- go-net.old/ipv4/zsys_linux_ppc64.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_linux_ppc64.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_linux.go
+ 
+-// +build linux,ppc64
+-
+ package ipv4
+ 
+ const (
+@@ -57,39 +55,44 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet          = 0x10
+-	sysSizeofInetPktinfo           = 0xc
+-	sysSizeofSockExtendedErr       = 0x10
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPFilter = 0x4
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Family uint16
+ 	Port   uint16
+ 	Addr   [4]byte /* in_addr */
+ 	X__pad [8]uint8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  int32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysSockExtendedErr struct {
++type sockExtendedErr struct {
+ 	Errno  uint32
+ 	Origin uint8
+ 	Type   uint8
+@@ -99,36 +102,49 @@
+ 	Data   uint32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  uint32
+ 	Interface  uint32
+ 	Sourceaddr uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ 	Data uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_ppc64le.go go-net/ipv4/zsys_linux_ppc64le.go
+--- go-net.old/ipv4/zsys_linux_ppc64le.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_linux_ppc64le.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_linux.go
+ 
+-// +build linux,ppc64le
+-
+ package ipv4
+ 
+ const (
+@@ -57,39 +55,44 @@
+ 	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
+ 	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet          = 0x10
+-	sysSizeofInetPktinfo           = 0xc
+-	sysSizeofSockExtendedErr       = 0x10
+-
+-	sysSizeofIPMreq         = 0x8
+-	sysSizeofIPMreqn        = 0xc
+-	sysSizeofIPMreqSource   = 0xc
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPFilter = 0x4
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet struct {
++type sockaddrInet struct {
+ 	Family uint16
+ 	Port   uint16
+ 	Addr   [4]byte /* in_addr */
+ 	X__pad [8]uint8
+ }
+ 
+-type sysInetPktinfo struct {
++type inetPktinfo struct {
+ 	Ifindex  int32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysSockExtendedErr struct {
++type sockExtendedErr struct {
+ 	Errno  uint32
+ 	Origin uint8
+ 	Type   uint8
+@@ -99,36 +102,49 @@
+ 	Data   uint32
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqn struct {
++type ipMreqn struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Address   [4]byte /* in_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  uint32
+ 	Interface  uint32
+ 	Sourceaddr uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPFilter struct {
++type icmpFilter struct {
+ 	Data uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_ppc.go go-net/ipv4/zsys_linux_ppc.go
+--- go-net.old/ipv4/zsys_linux_ppc.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/zsys_linux_ppc.go	2018-05-30 21:01:01.922195884 +0200
+@@ -0,0 +1,148 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv4
++
++const (
++	sysIP_TOS             = 0x1
++	sysIP_TTL             = 0x2
++	sysIP_HDRINCL         = 0x3
++	sysIP_OPTIONS         = 0x4
++	sysIP_ROUTER_ALERT    = 0x5
++	sysIP_RECVOPTS        = 0x6
++	sysIP_RETOPTS         = 0x7
++	sysIP_PKTINFO         = 0x8
++	sysIP_PKTOPTIONS      = 0x9
++	sysIP_MTU_DISCOVER    = 0xa
++	sysIP_RECVERR         = 0xb
++	sysIP_RECVTTL         = 0xc
++	sysIP_RECVTOS         = 0xd
++	sysIP_MTU             = 0xe
++	sysIP_FREEBIND        = 0xf
++	sysIP_TRANSPARENT     = 0x13
++	sysIP_RECVRETOPTS     = 0x7
++	sysIP_ORIGDSTADDR     = 0x14
++	sysIP_RECVORIGDSTADDR = 0x14
++	sysIP_MINTTL          = 0x15
++	sysIP_NODEFRAG        = 0x16
++	sysIP_UNICAST_IF      = 0x32
++
++	sysIP_MULTICAST_IF           = 0x20
++	sysIP_MULTICAST_TTL          = 0x21
++	sysIP_MULTICAST_LOOP         = 0x22
++	sysIP_ADD_MEMBERSHIP         = 0x23
++	sysIP_DROP_MEMBERSHIP        = 0x24
++	sysIP_UNBLOCK_SOURCE         = 0x25
++	sysIP_BLOCK_SOURCE           = 0x26
++	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x27
++	sysIP_DROP_SOURCE_MEMBERSHIP = 0x28
++	sysIP_MSFILTER               = 0x29
++	sysMCAST_JOIN_GROUP          = 0x2a
++	sysMCAST_LEAVE_GROUP         = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP   = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP  = 0x2f
++	sysMCAST_BLOCK_SOURCE        = 0x2b
++	sysMCAST_UNBLOCK_SOURCE      = 0x2c
++	sysMCAST_MSFILTER            = 0x30
++	sysIP_MULTICAST_ALL          = 0x31
++
++	sysICMP_FILTER = 0x1
++
++	sysSO_EE_ORIGIN_NONE         = 0x0
++	sysSO_EE_ORIGIN_LOCAL        = 0x1
++	sysSO_EE_ORIGIN_ICMP         = 0x2
++	sysSO_EE_ORIGIN_ICMP6        = 0x3
++	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
++	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x8
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]uint8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	X__pad [8]uint8
++}
++
++type inetPktinfo struct {
++	Ifindex  int32
++	Spec_dst [4]byte /* in_addr */
++	Addr     [4]byte /* in_addr */
++}
++
++type sockExtendedErr struct {
++	Errno  uint32
++	Origin uint8
++	Type   uint8
++	Code   uint8
++	Pad    uint8
++	Info   uint32
++	Data   uint32
++}
++
++type ipMreq struct {
++	Multiaddr [4]byte /* in_addr */
++	Interface [4]byte /* in_addr */
++}
++
++type ipMreqn struct {
++	Multiaddr [4]byte /* in_addr */
++	Address   [4]byte /* in_addr */
++	Ifindex   int32
++}
++
++type ipMreqSource struct {
++	Multiaddr  uint32
++	Interface  uint32
++	Sourceaddr uint32
++}
++
++type groupReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpFilter struct {
++	Data uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_linux_s390x.go go-net/ipv4/zsys_linux_s390x.go
+--- go-net.old/ipv4/zsys_linux_s390x.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv4/zsys_linux_s390x.go	2018-05-30 21:01:01.922195884 +0200
+@@ -0,0 +1,150 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv4
++
++const (
++	sysIP_TOS             = 0x1
++	sysIP_TTL             = 0x2
++	sysIP_HDRINCL         = 0x3
++	sysIP_OPTIONS         = 0x4
++	sysIP_ROUTER_ALERT    = 0x5
++	sysIP_RECVOPTS        = 0x6
++	sysIP_RETOPTS         = 0x7
++	sysIP_PKTINFO         = 0x8
++	sysIP_PKTOPTIONS      = 0x9
++	sysIP_MTU_DISCOVER    = 0xa
++	sysIP_RECVERR         = 0xb
++	sysIP_RECVTTL         = 0xc
++	sysIP_RECVTOS         = 0xd
++	sysIP_MTU             = 0xe
++	sysIP_FREEBIND        = 0xf
++	sysIP_TRANSPARENT     = 0x13
++	sysIP_RECVRETOPTS     = 0x7
++	sysIP_ORIGDSTADDR     = 0x14
++	sysIP_RECVORIGDSTADDR = 0x14
++	sysIP_MINTTL          = 0x15
++	sysIP_NODEFRAG        = 0x16
++	sysIP_UNICAST_IF      = 0x32
++
++	sysIP_MULTICAST_IF           = 0x20
++	sysIP_MULTICAST_TTL          = 0x21
++	sysIP_MULTICAST_LOOP         = 0x22
++	sysIP_ADD_MEMBERSHIP         = 0x23
++	sysIP_DROP_MEMBERSHIP        = 0x24
++	sysIP_UNBLOCK_SOURCE         = 0x25
++	sysIP_BLOCK_SOURCE           = 0x26
++	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x27
++	sysIP_DROP_SOURCE_MEMBERSHIP = 0x28
++	sysIP_MSFILTER               = 0x29
++	sysMCAST_JOIN_GROUP          = 0x2a
++	sysMCAST_LEAVE_GROUP         = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP   = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP  = 0x2f
++	sysMCAST_BLOCK_SOURCE        = 0x2b
++	sysMCAST_UNBLOCK_SOURCE      = 0x2c
++	sysMCAST_MSFILTER            = 0x30
++	sysIP_MULTICAST_ALL          = 0x31
++
++	sysICMP_FILTER = 0x1
++
++	sysSO_EE_ORIGIN_NONE         = 0x0
++	sysSO_EE_ORIGIN_LOCAL        = 0x1
++	sysSO_EE_ORIGIN_ICMP         = 0x2
++	sysSO_EE_ORIGIN_ICMP6        = 0x3
++	sysSO_EE_ORIGIN_TXSTATUS     = 0x4
++	sysSO_EE_ORIGIN_TIMESTAMPING = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet          = 0x10
++	sizeofInetPktinfo           = 0xc
++	sizeofSockExtendedErr       = 0x10
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqn        = 0xc
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPFilter = 0x4
++
++	sizeofSockFprog = 0x10
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	X__pad [8]uint8
++}
++
++type inetPktinfo struct {
++	Ifindex  int32
++	Spec_dst [4]byte /* in_addr */
++	Addr     [4]byte /* in_addr */
++}
++
++type sockExtendedErr struct {
++	Errno  uint32
++	Origin uint8
++	Type   uint8
++	Code   uint8
++	Pad    uint8
++	Info   uint32
++	Data   uint32
++}
++
++type ipMreq struct {
++	Multiaddr [4]byte /* in_addr */
++	Interface [4]byte /* in_addr */
++}
++
++type ipMreqn struct {
++	Multiaddr [4]byte /* in_addr */
++	Address   [4]byte /* in_addr */
++	Ifindex   int32
++}
++
++type ipMreqSource struct {
++	Multiaddr  uint32
++	Interface  uint32
++	Sourceaddr uint32
++}
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpFilter struct {
++	Data uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv4/zsys_netbsd.go go-net/ipv4/zsys_netbsd.go
+--- go-net.old/ipv4/zsys_netbsd.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_netbsd.go	2018-05-30 21:01:01.922195884 +0200
+@@ -21,10 +21,10 @@
+ 	sysIP_ADD_MEMBERSHIP  = 0xc
+ 	sysIP_DROP_MEMBERSHIP = 0xd
+ 
+-	sysSizeofIPMreq = 0x8
++	sizeofIPMreq = 0x8
+ )
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+diff -uNr go-net.old/ipv4/zsys_openbsd.go go-net/ipv4/zsys_openbsd.go
+--- go-net.old/ipv4/zsys_openbsd.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_openbsd.go	2018-05-30 21:01:01.922195884 +0200
+@@ -21,10 +21,10 @@
+ 	sysIP_ADD_MEMBERSHIP  = 0xc
+ 	sysIP_DROP_MEMBERSHIP = 0xd
+ 
+-	sysSizeofIPMreq = 0x8
++	sizeofIPMreq = 0x8
+ )
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+diff -uNr go-net.old/ipv4/zsys_solaris.go go-net/ipv4/zsys_solaris.go
+--- go-net.old/ipv4/zsys_solaris.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv4/zsys_solaris.go	2018-05-30 21:01:01.922195884 +0200
+@@ -1,30 +1,20 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_solaris.go
+ 
+-// +build solaris
+-
+ package ipv4
+ 
+ const (
+-	sysIP_OPTIONS       = 0x1
+-	sysIP_HDRINCL       = 0x2
+-	sysIP_TOS           = 0x3
+-	sysIP_TTL           = 0x4
+-	sysIP_RECVOPTS      = 0x5
+-	sysIP_RECVRETOPTS   = 0x6
+-	sysIP_RECVDSTADDR   = 0x7
+-	sysIP_RETOPTS       = 0x8
+-	sysIP_RECVIF        = 0x9
+-	sysIP_RECVSLLA      = 0xa
+-	sysIP_RECVTTL       = 0xb
+-	sysIP_NEXTHOP       = 0x19
+-	sysIP_PKTINFO       = 0x1a
+-	sysIP_RECVPKTINFO   = 0x1a
+-	sysIP_DONTFRAG      = 0x1b
+-	sysIP_BOUND_IF      = 0x41
+-	sysIP_UNSPEC_SRC    = 0x42
+-	sysIP_BROADCAST_TTL = 0x43
+-	sysIP_DHCPINIT_IF   = 0x45
++	sysIP_OPTIONS     = 0x1
++	sysIP_HDRINCL     = 0x2
++	sysIP_TOS         = 0x3
++	sysIP_TTL         = 0x4
++	sysIP_RECVOPTS    = 0x5
++	sysIP_RECVRETOPTS = 0x6
++	sysIP_RECVDSTADDR = 0x7
++	sysIP_RETOPTS     = 0x8
++	sysIP_RECVIF      = 0x9
++	sysIP_RECVSLLA    = 0xa
++	sysIP_RECVTTL     = 0xb
+ 
+ 	sysIP_MULTICAST_IF           = 0x10
+ 	sysIP_MULTICAST_TTL          = 0x11
+@@ -35,26 +25,76 @@
+ 	sysIP_UNBLOCK_SOURCE         = 0x16
+ 	sysIP_ADD_SOURCE_MEMBERSHIP  = 0x17
+ 	sysIP_DROP_SOURCE_MEMBERSHIP = 0x18
++	sysIP_NEXTHOP                = 0x19
+ 
+-	sysSizeofInetPktinfo = 0xc
++	sysIP_PKTINFO     = 0x1a
++	sysIP_RECVPKTINFO = 0x1a
++	sysIP_DONTFRAG    = 0x1b
++
++	sysIP_BOUND_IF      = 0x41
++	sysIP_UNSPEC_SRC    = 0x42
++	sysIP_BROADCAST_TTL = 0x43
++	sysIP_DHCPINIT_IF   = 0x45
+ 
+-	sysSizeofIPMreq       = 0x8
+-	sysSizeofIPMreqSource = 0xc
++	sysIP_REUSEADDR = 0x104
++	sysIP_DONTROUTE = 0x105
++	sysIP_BROADCAST = 0x106
++
++	sysMCAST_JOIN_GROUP         = 0x29
++	sysMCAST_LEAVE_GROUP        = 0x2a
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2d
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2e
++
++	sizeofSockaddrStorage = 0x100
++	sizeofSockaddrInet    = 0x10
++	sizeofInetPktinfo     = 0xc
++
++	sizeofIPMreq         = 0x8
++	sizeofIPMreqSource   = 0xc
++	sizeofGroupReq       = 0x104
++	sizeofGroupSourceReq = 0x204
+ )
+ 
+-type sysInetPktinfo struct {
++type sockaddrStorage struct {
++	Family     uint16
++	X_ss_pad1  [6]int8
++	X_ss_align float64
++	X_ss_pad2  [240]int8
++}
++
++type sockaddrInet struct {
++	Family uint16
++	Port   uint16
++	Addr   [4]byte /* in_addr */
++	Zero   [8]int8
++}
++
++type inetPktinfo struct {
+ 	Ifindex  uint32
+ 	Spec_dst [4]byte /* in_addr */
+ 	Addr     [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreq struct {
++type ipMreq struct {
+ 	Multiaddr [4]byte /* in_addr */
+ 	Interface [4]byte /* in_addr */
+ }
+ 
+-type sysIPMreqSource struct {
++type ipMreqSource struct {
+ 	Multiaddr  [4]byte /* in_addr */
+ 	Sourceaddr [4]byte /* in_addr */
+ 	Interface  [4]byte /* in_addr */
+ }
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [256]byte
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [256]byte
++	Pad_cgo_1 [256]byte
++}
+diff -uNr go-net.old/ipv6/batch.go go-net/ipv6/batch.go
+--- go-net.old/ipv6/batch.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/batch.go	2018-05-30 21:00:53.410376452 +0200
+@@ -0,0 +1,119 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++
++package ipv6
++
++import (
++	"net"
++	"runtime"
++	"syscall"
++
++	"golang.org/x/net/internal/socket"
++)
++
++// BUG(mikio): On Windows, the ReadBatch and WriteBatch methods of
++// PacketConn are not implemented.
++
++// A Message represents an IO message.
++//
++//	type Message struct {
++//		Buffers [][]byte
++//		OOB     []byte
++//		Addr    net.Addr
++//		N       int
++//		NN      int
++//		Flags   int
++//	}
++//
++// The Buffers fields represents a list of contiguous buffers, which
++// can be used for vectored IO, for example, putting a header and a
++// payload in each slice.
++// When writing, the Buffers field must contain at least one byte to
++// write.
++// When reading, the Buffers field will always contain a byte to read.
++//
++// The OOB field contains protocol-specific control or miscellaneous
++// ancillary data known as out-of-band data.
++// It can be nil when not required.
++//
++// The Addr field specifies a destination address when writing.
++// It can be nil when the underlying protocol of the endpoint uses
++// connection-oriented communication.
++// After a successful read, it may contain the source address on the
++// received packet.
++//
++// The N field indicates the number of bytes read or written from/to
++// Buffers.
++//
++// The NN field indicates the number of bytes read or written from/to
++// OOB.
++//
++// The Flags field contains protocol-specific information on the
++// received message.
++type Message = socket.Message
++
++// ReadBatch reads a batch of messages.
++//
++// The provided flags is a set of platform-dependent flags, such as
++// syscall.MSG_PEEK.
++//
++// On a successful read it returns the number of messages received, up
++// to len(ms).
++//
++// On Linux, a batch read will be optimized.
++// On other platforms, this method will read only a single message.
++func (c *payloadHandler) ReadBatch(ms []Message, flags int) (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	switch runtime.GOOS {
++	case "linux":
++		n, err := c.RecvMsgs([]socket.Message(ms), flags)
++		if err != nil {
++			err = &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	default:
++		n := 1
++		err := c.RecvMsg(&ms[0], flags)
++		if err != nil {
++			n = 0
++			err = &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	}
++}
++
++// WriteBatch writes a batch of messages.
++//
++// The provided flags is a set of platform-dependent flags, such as
++// syscall.MSG_DONTROUTE.
++//
++// It returns the number of messages written on a successful write.
++//
++// On Linux, a batch write will be optimized.
++// On other platforms, this method will write only a single message.
++func (c *payloadHandler) WriteBatch(ms []Message, flags int) (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	switch runtime.GOOS {
++	case "linux":
++		n, err := c.SendMsgs([]socket.Message(ms), flags)
++		if err != nil {
++			err = &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	default:
++		n := 1
++		err := c.SendMsg(&ms[0], flags)
++		if err != nil {
++			n = 0
++			err = &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		return n, err
++	}
++}
+diff -uNr go-net.old/ipv6/bpf_test.go go-net/ipv6/bpf_test.go
+--- go-net.old/ipv6/bpf_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/bpf_test.go	2018-05-30 21:00:53.410376452 +0200
+@@ -0,0 +1,96 @@
++// Copyright 2016 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6_test
++
++import (
++	"net"
++	"runtime"
++	"testing"
++	"time"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/ipv6"
++)
++
++func TestBPF(t *testing.T) {
++	if runtime.GOOS != "linux" {
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++	if !supportsIPv6 {
++		t.Skip("ipv6 is not supported")
++	}
++
++	l, err := net.ListenPacket("udp6", "[::1]:0")
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer l.Close()
++
++	p := ipv6.NewPacketConn(l)
++
++	// This filter accepts UDP packets whose first payload byte is
++	// even.
++	prog, err := bpf.Assemble([]bpf.Instruction{
++		// Load the first byte of the payload (skipping UDP header).
++		bpf.LoadAbsolute{Off: 8, Size: 1},
++		// Select LSB of the byte.
++		bpf.ALUOpConstant{Op: bpf.ALUOpAnd, Val: 1},
++		// Byte is even?
++		bpf.JumpIf{Cond: bpf.JumpEqual, Val: 0, SkipFalse: 1},
++		// Accept.
++		bpf.RetConstant{Val: 4096},
++		// Ignore.
++		bpf.RetConstant{Val: 0},
++	})
++	if err != nil {
++		t.Fatalf("compiling BPF: %s", err)
++	}
++
++	if err = p.SetBPF(prog); err != nil {
++		t.Fatalf("attaching filter to Conn: %s", err)
++	}
++
++	s, err := net.Dial("udp6", l.LocalAddr().String())
++	if err != nil {
++		t.Fatal(err)
++	}
++	defer s.Close()
++	go func() {
++		for i := byte(0); i < 10; i++ {
++			s.Write([]byte{i})
++		}
++	}()
++
++	l.SetDeadline(time.Now().Add(2 * time.Second))
++	seen := make([]bool, 5)
++	for {
++		var b [512]byte
++		n, _, err := l.ReadFrom(b[:])
++		if err != nil {
++			t.Fatalf("reading from listener: %s", err)
++		}
++		if n != 1 {
++			t.Fatalf("unexpected packet length, want 1, got %d", n)
++		}
++		if b[0] >= 10 {
++			t.Fatalf("unexpected byte, want 0-9, got %d", b[0])
++		}
++		if b[0]%2 != 0 {
++			t.Fatalf("got odd byte %d, wanted only even bytes", b[0])
++		}
++		seen[b[0]/2] = true
++
++		seenAll := true
++		for _, v := range seen {
++			if !v {
++				seenAll = false
++				break
++			}
++		}
++		if seenAll {
++			break
++		}
++	}
++}
+diff -uNr go-net.old/ipv6/control.go go-net/ipv6/control.go
+--- go-net.old/ipv6/control.go	2018-05-31 12:15:22.215955969 +0200
++++ go-net/ipv6/control.go	2018-05-30 21:00:53.410376452 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -8,10 +8,13 @@
+ 	"fmt"
+ 	"net"
+ 	"sync"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ // Note that RFC 3542 obsoletes RFC 2292 but OS X Snow Leopard and the
+-// former still support RFC 2292 only.  Please be aware that almost
++// former still support RFC 2292 only. Please be aware that almost
+ // all protocol implementations prohibit using a combination of RFC
+ // 2292 and RFC 3542 for some practical reasons.
+ 
+@@ -66,6 +69,105 @@
+ 	return fmt.Sprintf("tclass=%#x hoplim=%d src=%v dst=%v ifindex=%d nexthop=%v mtu=%d", cm.TrafficClass, cm.HopLimit, cm.Src, cm.Dst, cm.IfIndex, cm.NextHop, cm.MTU)
+ }
+ 
++// Marshal returns the binary encoding of cm.
++func (cm *ControlMessage) Marshal() []byte {
++	if cm == nil {
++		return nil
++	}
++	var l int
++	tclass := false
++	if ctlOpts[ctlTrafficClass].name > 0 && cm.TrafficClass > 0 {
++		tclass = true
++		l += socket.ControlMessageSpace(ctlOpts[ctlTrafficClass].length)
++	}
++	hoplimit := false
++	if ctlOpts[ctlHopLimit].name > 0 && cm.HopLimit > 0 {
++		hoplimit = true
++		l += socket.ControlMessageSpace(ctlOpts[ctlHopLimit].length)
++	}
++	pktinfo := false
++	if ctlOpts[ctlPacketInfo].name > 0 && (cm.Src.To16() != nil && cm.Src.To4() == nil || cm.IfIndex > 0) {
++		pktinfo = true
++		l += socket.ControlMessageSpace(ctlOpts[ctlPacketInfo].length)
++	}
++	nexthop := false
++	if ctlOpts[ctlNextHop].name > 0 && cm.NextHop.To16() != nil && cm.NextHop.To4() == nil {
++		nexthop = true
++		l += socket.ControlMessageSpace(ctlOpts[ctlNextHop].length)
++	}
++	var b []byte
++	if l > 0 {
++		b = make([]byte, l)
++		bb := b
++		if tclass {
++			bb = ctlOpts[ctlTrafficClass].marshal(bb, cm)
++		}
++		if hoplimit {
++			bb = ctlOpts[ctlHopLimit].marshal(bb, cm)
++		}
++		if pktinfo {
++			bb = ctlOpts[ctlPacketInfo].marshal(bb, cm)
++		}
++		if nexthop {
++			bb = ctlOpts[ctlNextHop].marshal(bb, cm)
++		}
++	}
++	return b
++}
++
++// Parse parses b as a control message and stores the result in cm.
++func (cm *ControlMessage) Parse(b []byte) error {
++	ms, err := socket.ControlMessage(b).Parse()
++	if err != nil {
++		return err
++	}
++	for _, m := range ms {
++		lvl, typ, l, err := m.ParseHeader()
++		if err != nil {
++			return err
++		}
++		if lvl != iana.ProtocolIPv6 {
++			continue
++		}
++		switch {
++		case typ == ctlOpts[ctlTrafficClass].name && l >= ctlOpts[ctlTrafficClass].length:
++			ctlOpts[ctlTrafficClass].parse(cm, m.Data(l))
++		case typ == ctlOpts[ctlHopLimit].name && l >= ctlOpts[ctlHopLimit].length:
++			ctlOpts[ctlHopLimit].parse(cm, m.Data(l))
++		case typ == ctlOpts[ctlPacketInfo].name && l >= ctlOpts[ctlPacketInfo].length:
++			ctlOpts[ctlPacketInfo].parse(cm, m.Data(l))
++		case typ == ctlOpts[ctlPathMTU].name && l >= ctlOpts[ctlPathMTU].length:
++			ctlOpts[ctlPathMTU].parse(cm, m.Data(l))
++		}
++	}
++	return nil
++}
++
++// NewControlMessage returns a new control message.
++//
++// The returned message is large enough for options specified by cf.
++func NewControlMessage(cf ControlFlags) []byte {
++	opt := rawOpt{cflags: cf}
++	var l int
++	if opt.isset(FlagTrafficClass) && ctlOpts[ctlTrafficClass].name > 0 {
++		l += socket.ControlMessageSpace(ctlOpts[ctlTrafficClass].length)
++	}
++	if opt.isset(FlagHopLimit) && ctlOpts[ctlHopLimit].name > 0 {
++		l += socket.ControlMessageSpace(ctlOpts[ctlHopLimit].length)
++	}
++	if opt.isset(flagPacketInfo) && ctlOpts[ctlPacketInfo].name > 0 {
++		l += socket.ControlMessageSpace(ctlOpts[ctlPacketInfo].length)
++	}
++	if opt.isset(FlagPathMTU) && ctlOpts[ctlPathMTU].name > 0 {
++		l += socket.ControlMessageSpace(ctlOpts[ctlPathMTU].length)
++	}
++	var b []byte
++	if l > 0 {
++		b = make([]byte, l)
++	}
++	return b
++}
++
+ // Ancillary data socket options
+ const (
+ 	ctlTrafficClass = iota // header field
+diff -uNr go-net.old/ipv6/control_rfc2292_unix.go go-net/ipv6/control_rfc2292_unix.go
+--- go-net.old/ipv6/control_rfc2292_unix.go	2018-05-31 12:15:35.451674424 +0200
++++ go-net/ipv6/control_rfc2292_unix.go	2018-05-30 21:00:53.410376452 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -7,32 +7,26 @@
+ package ipv6
+ 
+ import (
+-	"syscall"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ func marshal2292HopLimit(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_2292HOPLIMIT
+-	m.SetLen(syscall.CmsgLen(4))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_2292HOPLIMIT, 4)
+ 	if cm != nil {
+-		data := b[syscall.CmsgLen(0):]
+-		// TODO(mikio): fix potential misaligned memory access
+-		*(*int32)(unsafe.Pointer(&data[:4][0])) = int32(cm.HopLimit)
++		socket.NativeEndian.PutUint32(m.Data(4), uint32(cm.HopLimit))
+ 	}
+-	return b[syscall.CmsgSpace(4):]
++	return m.Next(4)
+ }
+ 
+ func marshal2292PacketInfo(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_2292PKTINFO
+-	m.SetLen(syscall.CmsgLen(sysSizeofInet6Pktinfo))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_2292PKTINFO, sizeofInet6Pktinfo)
+ 	if cm != nil {
+-		pi := (*sysInet6Pktinfo)(unsafe.Pointer(&b[syscall.CmsgLen(0)]))
++		pi := (*inet6Pktinfo)(unsafe.Pointer(&m.Data(sizeofInet6Pktinfo)[0]))
+ 		if ip := cm.Src.To16(); ip != nil && ip.To4() == nil {
+ 			copy(pi.Addr[:], ip)
+ 		}
+@@ -40,17 +34,15 @@
+ 			pi.setIfindex(cm.IfIndex)
+ 		}
+ 	}
+-	return b[syscall.CmsgSpace(sysSizeofInet6Pktinfo):]
++	return m.Next(sizeofInet6Pktinfo)
+ }
+ 
+ func marshal2292NextHop(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_2292NEXTHOP
+-	m.SetLen(syscall.CmsgLen(sysSizeofSockaddrInet6))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_2292NEXTHOP, sizeofSockaddrInet6)
+ 	if cm != nil {
+-		sa := (*sysSockaddrInet6)(unsafe.Pointer(&b[syscall.CmsgLen(0)]))
++		sa := (*sockaddrInet6)(unsafe.Pointer(&m.Data(sizeofSockaddrInet6)[0]))
+ 		sa.setSockaddr(cm.NextHop, cm.IfIndex)
+ 	}
+-	return b[syscall.CmsgSpace(sysSizeofSockaddrInet6):]
++	return m.Next(sizeofSockaddrInet6)
+ }
+diff -uNr go-net.old/ipv6/control_rfc3542_unix.go go-net/ipv6/control_rfc3542_unix.go
+--- go-net.old/ipv6/control_rfc3542_unix.go	2018-05-31 12:15:35.455674339 +0200
++++ go-net/ipv6/control_rfc3542_unix.go	2018-05-30 21:00:53.410376452 +0200
+@@ -1,61 +1,50 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build darwin dragonfly freebsd linux netbsd openbsd
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris
+ 
+ package ipv6
+ 
+ import (
+-	"syscall"
++	"net"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ func marshalTrafficClass(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_TCLASS
+-	m.SetLen(syscall.CmsgLen(4))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_TCLASS, 4)
+ 	if cm != nil {
+-		data := b[syscall.CmsgLen(0):]
+-		// TODO(mikio): fix potential misaligned memory access
+-		*(*int32)(unsafe.Pointer(&data[:4][0])) = int32(cm.TrafficClass)
++		socket.NativeEndian.PutUint32(m.Data(4), uint32(cm.TrafficClass))
+ 	}
+-	return b[syscall.CmsgSpace(4):]
++	return m.Next(4)
+ }
+ 
+ func parseTrafficClass(cm *ControlMessage, b []byte) {
+-	// TODO(mikio): fix potential misaligned memory access
+-	cm.TrafficClass = int(*(*int32)(unsafe.Pointer(&b[:4][0])))
++	cm.TrafficClass = int(socket.NativeEndian.Uint32(b[:4]))
+ }
+ 
+ func marshalHopLimit(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_HOPLIMIT
+-	m.SetLen(syscall.CmsgLen(4))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_HOPLIMIT, 4)
+ 	if cm != nil {
+-		data := b[syscall.CmsgLen(0):]
+-		// TODO(mikio): fix potential misaligned memory access
+-		*(*int32)(unsafe.Pointer(&data[:4][0])) = int32(cm.HopLimit)
++		socket.NativeEndian.PutUint32(m.Data(4), uint32(cm.HopLimit))
+ 	}
+-	return b[syscall.CmsgSpace(4):]
++	return m.Next(4)
+ }
+ 
+ func parseHopLimit(cm *ControlMessage, b []byte) {
+-	// TODO(mikio): fix potential misaligned memory access
+-	cm.HopLimit = int(*(*int32)(unsafe.Pointer(&b[:4][0])))
++	cm.HopLimit = int(socket.NativeEndian.Uint32(b[:4]))
+ }
+ 
+ func marshalPacketInfo(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_PKTINFO
+-	m.SetLen(syscall.CmsgLen(sysSizeofInet6Pktinfo))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_PKTINFO, sizeofInet6Pktinfo)
+ 	if cm != nil {
+-		pi := (*sysInet6Pktinfo)(unsafe.Pointer(&b[syscall.CmsgLen(0)]))
++		pi := (*inet6Pktinfo)(unsafe.Pointer(&m.Data(sizeofInet6Pktinfo)[0]))
+ 		if ip := cm.Src.To16(); ip != nil && ip.To4() == nil {
+ 			copy(pi.Addr[:], ip)
+ 		}
+@@ -63,41 +52,43 @@
+ 			pi.setIfindex(cm.IfIndex)
+ 		}
+ 	}
+-	return b[syscall.CmsgSpace(sysSizeofInet6Pktinfo):]
++	return m.Next(sizeofInet6Pktinfo)
+ }
+ 
+ func parsePacketInfo(cm *ControlMessage, b []byte) {
+-	pi := (*sysInet6Pktinfo)(unsafe.Pointer(&b[0]))
+-	cm.Dst = pi.Addr[:]
++	pi := (*inet6Pktinfo)(unsafe.Pointer(&b[0]))
++	if len(cm.Dst) < net.IPv6len {
++		cm.Dst = make(net.IP, net.IPv6len)
++	}
++	copy(cm.Dst, pi.Addr[:])
+ 	cm.IfIndex = int(pi.Ifindex)
+ }
+ 
+ func marshalNextHop(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_NEXTHOP
+-	m.SetLen(syscall.CmsgLen(sysSizeofSockaddrInet6))
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_NEXTHOP, sizeofSockaddrInet6)
+ 	if cm != nil {
+-		sa := (*sysSockaddrInet6)(unsafe.Pointer(&b[syscall.CmsgLen(0)]))
++		sa := (*sockaddrInet6)(unsafe.Pointer(&m.Data(sizeofSockaddrInet6)[0]))
+ 		sa.setSockaddr(cm.NextHop, cm.IfIndex)
+ 	}
+-	return b[syscall.CmsgSpace(sysSizeofSockaddrInet6):]
++	return m.Next(sizeofSockaddrInet6)
+ }
+ 
+ func parseNextHop(cm *ControlMessage, b []byte) {
+ }
+ 
+ func marshalPathMTU(b []byte, cm *ControlMessage) []byte {
+-	m := (*syscall.Cmsghdr)(unsafe.Pointer(&b[0]))
+-	m.Level = iana.ProtocolIPv6
+-	m.Type = sysIPV6_PATHMTU
+-	m.SetLen(syscall.CmsgLen(sysSizeofIPv6Mtuinfo))
+-	return b[syscall.CmsgSpace(sysSizeofIPv6Mtuinfo):]
++	m := socket.ControlMessage(b)
++	m.MarshalHeader(iana.ProtocolIPv6, sysIPV6_PATHMTU, sizeofIPv6Mtuinfo)
++	return m.Next(sizeofIPv6Mtuinfo)
+ }
+ 
+ func parsePathMTU(cm *ControlMessage, b []byte) {
+-	mi := (*sysIPv6Mtuinfo)(unsafe.Pointer(&b[0]))
+-	cm.Dst = mi.Addr.Addr[:]
++	mi := (*ipv6Mtuinfo)(unsafe.Pointer(&b[0]))
++	if len(cm.Dst) < net.IPv6len {
++		cm.Dst = make(net.IP, net.IPv6len)
++	}
++	copy(cm.Dst, mi.Addr.Addr[:])
+ 	cm.IfIndex = int(mi.Addr.Scope_id)
+ 	cm.MTU = int(mi.Mtu)
+ }
+diff -uNr go-net.old/ipv6/control_stub.go go-net/ipv6/control_stub.go
+--- go-net.old/ipv6/control_stub.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/control_stub.go	2018-05-30 21:00:53.410376452 +0200
+@@ -1,23 +1,13 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9 solaris
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv6
+ 
+-func setControlMessage(fd int, opt *rawOpt, cf ControlFlags, on bool) error {
+-	return errOpNoSupport
+-}
+-
+-func newControlMessage(opt *rawOpt) (oob []byte) {
+-	return nil
+-}
++import "golang.org/x/net/internal/socket"
+ 
+-func parseControlMessage(b []byte) (*ControlMessage, error) {
+-	return nil, errOpNoSupport
+-}
+-
+-func marshalControlMessage(cm *ControlMessage) (oob []byte) {
+-	return nil
++func setControlMessage(c *socket.Conn, opt *rawOpt, cf ControlFlags, on bool) error {
++	return errOpNoSupport
+ }
+diff -uNr go-net.old/ipv6/control_test.go go-net/ipv6/control_test.go
+--- go-net.old/ipv6/control_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/control_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,21 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6_test
++
++import (
++	"testing"
++
++	"golang.org/x/net/ipv6"
++)
++
++func TestControlMessageParseWithFuzz(t *testing.T) {
++	var cm ipv6.ControlMessage
++	for _, fuzz := range []string{
++		"\f\x00\x00\x00)\x00\x00\x00.\x00\x00\x00",
++		"\f\x00\x00\x00)\x00\x00\x00,\x00\x00\x00",
++	} {
++		cm.Parse([]byte(fuzz))
++	}
++}
+diff -uNr go-net.old/ipv6/control_unix.go go-net/ipv6/control_unix.go
+--- go-net.old/ipv6/control_unix.go	2018-05-31 12:15:35.459674253 +0200
++++ go-net/ipv6/control_unix.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,23 +1,18 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build darwin dragonfly freebsd linux netbsd openbsd
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris
+ 
+ package ipv6
+ 
+-import (
+-	"os"
+-	"syscall"
++import "golang.org/x/net/internal/socket"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-)
+-
+-func setControlMessage(fd int, opt *rawOpt, cf ControlFlags, on bool) error {
++func setControlMessage(c *socket.Conn, opt *rawOpt, cf ControlFlags, on bool) error {
+ 	opt.Lock()
+ 	defer opt.Unlock()
+-	if cf&FlagTrafficClass != 0 && sockOpts[ssoReceiveTrafficClass].name > 0 {
+-		if err := setInt(fd, &sockOpts[ssoReceiveTrafficClass], boolint(on)); err != nil {
++	if so, ok := sockOpts[ssoReceiveTrafficClass]; ok && cf&FlagTrafficClass != 0 {
++		if err := so.SetInt(c, boolint(on)); err != nil {
+ 			return err
+ 		}
+ 		if on {
+@@ -26,8 +21,8 @@
+ 			opt.clear(FlagTrafficClass)
+ 		}
+ 	}
+-	if cf&FlagHopLimit != 0 && sockOpts[ssoReceiveHopLimit].name > 0 {
+-		if err := setInt(fd, &sockOpts[ssoReceiveHopLimit], boolint(on)); err != nil {
++	if so, ok := sockOpts[ssoReceiveHopLimit]; ok && cf&FlagHopLimit != 0 {
++		if err := so.SetInt(c, boolint(on)); err != nil {
+ 			return err
+ 		}
+ 		if on {
+@@ -36,8 +31,8 @@
+ 			opt.clear(FlagHopLimit)
+ 		}
+ 	}
+-	if cf&flagPacketInfo != 0 && sockOpts[ssoReceivePacketInfo].name > 0 {
+-		if err := setInt(fd, &sockOpts[ssoReceivePacketInfo], boolint(on)); err != nil {
++	if so, ok := sockOpts[ssoReceivePacketInfo]; ok && cf&flagPacketInfo != 0 {
++		if err := so.SetInt(c, boolint(on)); err != nil {
+ 			return err
+ 		}
+ 		if on {
+@@ -46,8 +41,8 @@
+ 			opt.clear(cf & flagPacketInfo)
+ 		}
+ 	}
+-	if cf&FlagPathMTU != 0 && sockOpts[ssoReceivePathMTU].name > 0 {
+-		if err := setInt(fd, &sockOpts[ssoReceivePathMTU], boolint(on)); err != nil {
++	if so, ok := sockOpts[ssoReceivePathMTU]; ok && cf&FlagPathMTU != 0 {
++		if err := so.SetInt(c, boolint(on)); err != nil {
+ 			return err
+ 		}
+ 		if on {
+@@ -58,109 +53,3 @@
+ 	}
+ 	return nil
+ }
+-
+-func newControlMessage(opt *rawOpt) (oob []byte) {
+-	opt.RLock()
+-	var l int
+-	if opt.isset(FlagTrafficClass) && ctlOpts[ctlTrafficClass].name > 0 {
+-		l += syscall.CmsgSpace(ctlOpts[ctlTrafficClass].length)
+-	}
+-	if opt.isset(FlagHopLimit) && ctlOpts[ctlHopLimit].name > 0 {
+-		l += syscall.CmsgSpace(ctlOpts[ctlHopLimit].length)
+-	}
+-	if opt.isset(flagPacketInfo) && ctlOpts[ctlPacketInfo].name > 0 {
+-		l += syscall.CmsgSpace(ctlOpts[ctlPacketInfo].length)
+-	}
+-	if opt.isset(FlagPathMTU) && ctlOpts[ctlPathMTU].name > 0 {
+-		l += syscall.CmsgSpace(ctlOpts[ctlPathMTU].length)
+-	}
+-	if l > 0 {
+-		oob = make([]byte, l)
+-		b := oob
+-		if opt.isset(FlagTrafficClass) && ctlOpts[ctlTrafficClass].name > 0 {
+-			b = ctlOpts[ctlTrafficClass].marshal(b, nil)
+-		}
+-		if opt.isset(FlagHopLimit) && ctlOpts[ctlHopLimit].name > 0 {
+-			b = ctlOpts[ctlHopLimit].marshal(b, nil)
+-		}
+-		if opt.isset(flagPacketInfo) && ctlOpts[ctlPacketInfo].name > 0 {
+-			b = ctlOpts[ctlPacketInfo].marshal(b, nil)
+-		}
+-		if opt.isset(FlagPathMTU) && ctlOpts[ctlPathMTU].name > 0 {
+-			b = ctlOpts[ctlPathMTU].marshal(b, nil)
+-		}
+-	}
+-	opt.RUnlock()
+-	return
+-}
+-
+-func parseControlMessage(b []byte) (*ControlMessage, error) {
+-	if len(b) == 0 {
+-		return nil, nil
+-	}
+-	cmsgs, err := syscall.ParseSocketControlMessage(b)
+-	if err != nil {
+-		return nil, os.NewSyscallError("parse socket control message", err)
+-	}
+-	cm := &ControlMessage{}
+-	for _, m := range cmsgs {
+-		if m.Header.Level != iana.ProtocolIPv6 {
+-			continue
+-		}
+-		switch int(m.Header.Type) {
+-		case ctlOpts[ctlTrafficClass].name:
+-			ctlOpts[ctlTrafficClass].parse(cm, m.Data[:])
+-		case ctlOpts[ctlHopLimit].name:
+-			ctlOpts[ctlHopLimit].parse(cm, m.Data[:])
+-		case ctlOpts[ctlPacketInfo].name:
+-			ctlOpts[ctlPacketInfo].parse(cm, m.Data[:])
+-		case ctlOpts[ctlPathMTU].name:
+-			ctlOpts[ctlPathMTU].parse(cm, m.Data[:])
+-		}
+-	}
+-	return cm, nil
+-}
+-
+-func marshalControlMessage(cm *ControlMessage) (oob []byte) {
+-	if cm == nil {
+-		return
+-	}
+-	var l int
+-	tclass := false
+-	if ctlOpts[ctlTrafficClass].name > 0 && cm.TrafficClass > 0 {
+-		tclass = true
+-		l += syscall.CmsgSpace(ctlOpts[ctlTrafficClass].length)
+-	}
+-	hoplimit := false
+-	if ctlOpts[ctlHopLimit].name > 0 && cm.HopLimit > 0 {
+-		hoplimit = true
+-		l += syscall.CmsgSpace(ctlOpts[ctlHopLimit].length)
+-	}
+-	pktinfo := false
+-	if ctlOpts[ctlPacketInfo].name > 0 && (cm.Src.To16() != nil && cm.Src.To4() == nil || cm.IfIndex > 0) {
+-		pktinfo = true
+-		l += syscall.CmsgSpace(ctlOpts[ctlPacketInfo].length)
+-	}
+-	nexthop := false
+-	if ctlOpts[ctlNextHop].name > 0 && cm.NextHop.To16() != nil && cm.NextHop.To4() == nil {
+-		nexthop = true
+-		l += syscall.CmsgSpace(ctlOpts[ctlNextHop].length)
+-	}
+-	if l > 0 {
+-		oob = make([]byte, l)
+-		b := oob
+-		if tclass {
+-			b = ctlOpts[ctlTrafficClass].marshal(b, cm)
+-		}
+-		if hoplimit {
+-			b = ctlOpts[ctlHopLimit].marshal(b, cm)
+-		}
+-		if pktinfo {
+-			b = ctlOpts[ctlPacketInfo].marshal(b, cm)
+-		}
+-		if nexthop {
+-			b = ctlOpts[ctlNextHop].marshal(b, cm)
+-		}
+-	}
+-	return
+-}
+diff -uNr go-net.old/ipv6/control_windows.go go-net/ipv6/control_windows.go
+--- go-net.old/ipv6/control_windows.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/control_windows.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,27 +1,16 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv6
+ 
+-import "syscall"
++import (
++	"syscall"
+ 
+-func setControlMessage(fd syscall.Handle, opt *rawOpt, cf ControlFlags, on bool) error {
+-	// TODO(mikio): implement this
+-	return syscall.EWINDOWS
+-}
+-
+-func newControlMessage(opt *rawOpt) (oob []byte) {
+-	// TODO(mikio): implement this
+-	return nil
+-}
++	"golang.org/x/net/internal/socket"
++)
+ 
+-func parseControlMessage(b []byte) (*ControlMessage, error) {
++func setControlMessage(c *socket.Conn, opt *rawOpt, cf ControlFlags, on bool) error {
+ 	// TODO(mikio): implement this
+-	return nil, syscall.EWINDOWS
+-}
+-
+-func marshalControlMessage(cm *ControlMessage) (oob []byte) {
+-	// TODO(mikio): implement this
+-	return nil
++	return syscall.EWINDOWS
+ }
+diff -uNr go-net.old/ipv6/defs_darwin.go go-net/ipv6/defs_darwin.go
+--- go-net.old/ipv6/defs_darwin.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/defs_darwin.go	2018-05-30 21:00:53.414376369 +0200
+@@ -83,30 +83,30 @@
+ 	sysIPV6_PORTRANGE_HIGH    = C.IPV6_PORTRANGE_HIGH
+ 	sysIPV6_PORTRANGE_LOW     = C.IPV6_PORTRANGE_LOW
+ 
+-	sysSizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
+-	sysSizeofSockaddrInet6   = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo    = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo     = C.sizeof_struct_ip6_mtuinfo
+-
+-	sysSizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
+-	sysSizeofGroupReq       = C.sizeof_struct_group_req
+-	sysSizeofGroupSourceReq = C.sizeof_struct_group_source_req
++	sizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
++	sizeofSockaddrInet6   = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo    = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo     = C.sizeof_struct_ip6_mtuinfo
++
++	sizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
+ )
+ 
+-type sysSockaddrStorage C.struct_sockaddr_storage
++type sockaddrStorage C.struct_sockaddr_storage
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type sockaddrInet6 C.struct_sockaddr_in6
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type inet6Pktinfo C.struct_in6_pktinfo
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type icmpv6Filter C.struct_icmp6_filter
+ 
+-type sysGroupReq C.struct_group_req
++type groupReq C.struct_group_req
+ 
+-type sysGroupSourceReq C.struct_group_source_req
++type groupSourceReq C.struct_group_source_req
+diff -uNr go-net.old/ipv6/defs_dragonfly.go go-net/ipv6/defs_dragonfly.go
+--- go-net.old/ipv6/defs_dragonfly.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/defs_dragonfly.go	2018-05-30 21:00:53.414376369 +0200
+@@ -64,21 +64,21 @@
+ 	sysIPV6_PORTRANGE_HIGH    = C.IPV6_PORTRANGE_HIGH
+ 	sysIPV6_PORTRANGE_LOW     = C.IPV6_PORTRANGE_LOW
+ 
+-	sysSizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
++	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
+ 
+-	sysSizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
++	sizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
+ )
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type sockaddrInet6 C.struct_sockaddr_in6
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type inet6Pktinfo C.struct_in6_pktinfo
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type icmpv6Filter C.struct_icmp6_filter
+diff -uNr go-net.old/ipv6/defs_freebsd.go go-net/ipv6/defs_freebsd.go
+--- go-net.old/ipv6/defs_freebsd.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/defs_freebsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -76,30 +76,30 @@
+ 	sysIPV6_PORTRANGE_HIGH    = C.IPV6_PORTRANGE_HIGH
+ 	sysIPV6_PORTRANGE_LOW     = C.IPV6_PORTRANGE_LOW
+ 
+-	sysSizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
+-	sysSizeofSockaddrInet6   = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo    = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo     = C.sizeof_struct_ip6_mtuinfo
+-
+-	sysSizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
+-	sysSizeofGroupReq       = C.sizeof_struct_group_req
+-	sysSizeofGroupSourceReq = C.sizeof_struct_group_source_req
++	sizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
++	sizeofSockaddrInet6   = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo    = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo     = C.sizeof_struct_ip6_mtuinfo
++
++	sizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
+ )
+ 
+-type sysSockaddrStorage C.struct_sockaddr_storage
++type sockaddrStorage C.struct_sockaddr_storage
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type sockaddrInet6 C.struct_sockaddr_in6
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type inet6Pktinfo C.struct_in6_pktinfo
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysGroupReq C.struct_group_req
++type groupReq C.struct_group_req
+ 
+-type sysGroupSourceReq C.struct_group_source_req
++type groupSourceReq C.struct_group_source_req
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type icmpv6Filter C.struct_icmp6_filter
+diff -uNr go-net.old/ipv6/defs_linux.go go-net/ipv6/defs_linux.go
+--- go-net.old/ipv6/defs_linux.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/defs_linux.go	2018-05-30 21:00:53.414376369 +0200
+@@ -13,6 +13,8 @@
+ #include <linux/in6.h>
+ #include <linux/ipv6.h>
+ #include <linux/icmpv6.h>
++#include <linux/filter.h>
++#include <sys/socket.h>
+ */
+ import "C"
+ 
+@@ -104,33 +106,42 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = C.ICMPV6_FILTER_BLOCKOTHERS
+ 	sysICMPV6_FILTER_PASSONLY    = C.ICMPV6_FILTER_PASSONLY
+ 
+-	sysSizeofKernelSockaddrStorage = C.sizeof_struct___kernel_sockaddr_storage
+-	sysSizeofSockaddrInet6         = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo          = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo           = C.sizeof_struct_ip6_mtuinfo
+-	sysSizeofIPv6FlowlabelReq      = C.sizeof_struct_in6_flowlabel_req
+-
+-	sysSizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
+-	sysSizeofGroupReq       = C.sizeof_struct_group_req
+-	sysSizeofGroupSourceReq = C.sizeof_struct_group_source_req
++	sysSOL_SOCKET       = C.SOL_SOCKET
++	sysSO_ATTACH_FILTER = C.SO_ATTACH_FILTER
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofKernelSockaddrStorage = C.sizeof_struct___kernel_sockaddr_storage
++	sizeofSockaddrInet6         = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo          = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo           = C.sizeof_struct_ip6_mtuinfo
++	sizeofIPv6FlowlabelReq      = C.sizeof_struct_in6_flowlabel_req
++
++	sizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
++
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++
++	sizeofSockFprog = C.sizeof_struct_sock_fprog
+ )
+ 
+-type sysKernelSockaddrStorage C.struct___kernel_sockaddr_storage
++type kernelSockaddrStorage C.struct___kernel_sockaddr_storage
++
++type sockaddrInet6 C.struct_sockaddr_in6
++
++type inet6Pktinfo C.struct_in6_pktinfo
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type ipv6FlowlabelReq C.struct_in6_flowlabel_req
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysIPv6FlowlabelReq C.struct_in6_flowlabel_req
++type groupReq C.struct_group_req
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type groupSourceReq C.struct_group_source_req
+ 
+-type sysGroupReq C.struct_group_req
++type icmpv6Filter C.struct_icmp6_filter
+ 
+-type sysGroupSourceReq C.struct_group_source_req
++type sockFProg C.struct_sock_fprog
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type sockFilter C.struct_sock_filter
+diff -uNr go-net.old/ipv6/defs_netbsd.go go-net/ipv6/defs_netbsd.go
+--- go-net.old/ipv6/defs_netbsd.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/defs_netbsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -60,21 +60,21 @@
+ 	sysIPV6_PORTRANGE_HIGH    = C.IPV6_PORTRANGE_HIGH
+ 	sysIPV6_PORTRANGE_LOW     = C.IPV6_PORTRANGE_LOW
+ 
+-	sysSizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
++	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
+ 
+-	sysSizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
++	sizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
+ )
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type sockaddrInet6 C.struct_sockaddr_in6
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type inet6Pktinfo C.struct_in6_pktinfo
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type icmpv6Filter C.struct_icmp6_filter
+diff -uNr go-net.old/ipv6/defs_openbsd.go go-net/ipv6/defs_openbsd.go
+--- go-net.old/ipv6/defs_openbsd.go	2018-05-31 12:15:22.219955884 +0200
++++ go-net/ipv6/defs_openbsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -69,21 +69,21 @@
+ 	sysIPV6_PORTRANGE_HIGH    = C.IPV6_PORTRANGE_HIGH
+ 	sysIPV6_PORTRANGE_LOW     = C.IPV6_PORTRANGE_LOW
+ 
+-	sysSizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
++	sizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
+ 
+-	sysSizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
++	sizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
+ )
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type sockaddrInet6 C.struct_sockaddr_in6
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type inet6Pktinfo C.struct_in6_pktinfo
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type icmpv6Filter C.struct_icmp6_filter
+diff -uNr go-net.old/ipv6/defs_solaris.go go-net/ipv6/defs_solaris.go
+--- go-net.old/ipv6/defs_solaris.go	2018-05-31 12:15:22.227955715 +0200
++++ go-net/ipv6/defs_solaris.go	2018-05-30 21:00:53.414376369 +0200
+@@ -9,6 +9,8 @@
+ package ipv6
+ 
+ /*
++#include <sys/socket.h>
++
+ #include <netinet/in.h>
+ #include <netinet/icmp6.h>
+ */
+@@ -53,6 +55,13 @@
+ 
+ 	sysIPV6_RECVDSTOPTS = C.IPV6_RECVDSTOPTS
+ 
++	sysMCAST_JOIN_GROUP         = C.MCAST_JOIN_GROUP
++	sysMCAST_LEAVE_GROUP        = C.MCAST_LEAVE_GROUP
++	sysMCAST_BLOCK_SOURCE       = C.MCAST_BLOCK_SOURCE
++	sysMCAST_UNBLOCK_SOURCE     = C.MCAST_UNBLOCK_SOURCE
++	sysMCAST_JOIN_SOURCE_GROUP  = C.MCAST_JOIN_SOURCE_GROUP
++	sysMCAST_LEAVE_SOURCE_GROUP = C.MCAST_LEAVE_SOURCE_GROUP
++
+ 	sysIPV6_PREFER_SRC_HOME   = C.IPV6_PREFER_SRC_HOME
+ 	sysIPV6_PREFER_SRC_COA    = C.IPV6_PREFER_SRC_COA
+ 	sysIPV6_PREFER_SRC_PUBLIC = C.IPV6_PREFER_SRC_PUBLIC
+@@ -76,21 +85,30 @@
+ 
+ 	sysICMP6_FILTER = C.ICMP6_FILTER
+ 
+-	sysSizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6
+-	sysSizeofInet6Pktinfo  = C.sizeof_struct_in6_pktinfo
+-	sysSizeofIPv6Mtuinfo   = C.sizeof_struct_ip6_mtuinfo
+-
+-	sysSizeofIPv6Mreq = C.sizeof_struct_ipv6_mreq
++	sizeofSockaddrStorage = C.sizeof_struct_sockaddr_storage
++	sizeofSockaddrInet6   = C.sizeof_struct_sockaddr_in6
++	sizeofInet6Pktinfo    = C.sizeof_struct_in6_pktinfo
++	sizeofIPv6Mtuinfo     = C.sizeof_struct_ip6_mtuinfo
++
++	sizeofIPv6Mreq       = C.sizeof_struct_ipv6_mreq
++	sizeofGroupReq       = C.sizeof_struct_group_req
++	sizeofGroupSourceReq = C.sizeof_struct_group_source_req
+ 
+-	sysSizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
++	sizeofICMPv6Filter = C.sizeof_struct_icmp6_filter
+ )
+ 
+-type sysSockaddrInet6 C.struct_sockaddr_in6
++type sockaddrStorage C.struct_sockaddr_storage
++
++type sockaddrInet6 C.struct_sockaddr_in6
++
++type inet6Pktinfo C.struct_in6_pktinfo
++
++type ipv6Mtuinfo C.struct_ip6_mtuinfo
+ 
+-type sysInet6Pktinfo C.struct_in6_pktinfo
++type ipv6Mreq C.struct_ipv6_mreq
+ 
+-type sysIPv6Mtuinfo C.struct_ip6_mtuinfo
++type groupReq C.struct_group_req
+ 
+-type sysIPv6Mreq C.struct_ipv6_mreq
++type groupSourceReq C.struct_group_source_req
+ 
+-type sysICMPv6Filter C.struct_icmp6_filter
++type icmpv6Filter C.struct_icmp6_filter
+diff -uNr go-net.old/ipv6/dgramopt.go go-net/ipv6/dgramopt.go
+--- go-net.old/ipv6/dgramopt.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/dgramopt.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,302 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6
++
++import (
++	"net"
++	"syscall"
++
++	"golang.org/x/net/bpf"
++)
++
++// MulticastHopLimit returns the hop limit field value for outgoing
++// multicast packets.
++func (c *dgramOpt) MulticastHopLimit() (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastHopLimit]
++	if !ok {
++		return 0, errOpNoSupport
++	}
++	return so.GetInt(c.Conn)
++}
++
++// SetMulticastHopLimit sets the hop limit field value for future
++// outgoing multicast packets.
++func (c *dgramOpt) SetMulticastHopLimit(hoplim int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastHopLimit]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, hoplim)
++}
++
++// MulticastInterface returns the default interface for multicast
++// packet transmissions.
++func (c *dgramOpt) MulticastInterface() (*net.Interface, error) {
++	if !c.ok() {
++		return nil, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastInterface]
++	if !ok {
++		return nil, errOpNoSupport
++	}
++	return so.getMulticastInterface(c.Conn)
++}
++
++// SetMulticastInterface sets the default interface for future
++// multicast packet transmissions.
++func (c *dgramOpt) SetMulticastInterface(ifi *net.Interface) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastInterface]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.setMulticastInterface(c.Conn, ifi)
++}
++
++// MulticastLoopback reports whether transmitted multicast packets
++// should be copied and send back to the originator.
++func (c *dgramOpt) MulticastLoopback() (bool, error) {
++	if !c.ok() {
++		return false, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastLoopback]
++	if !ok {
++		return false, errOpNoSupport
++	}
++	on, err := so.GetInt(c.Conn)
++	if err != nil {
++		return false, err
++	}
++	return on == 1, nil
++}
++
++// SetMulticastLoopback sets whether transmitted multicast packets
++// should be copied and send back to the originator.
++func (c *dgramOpt) SetMulticastLoopback(on bool) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoMulticastLoopback]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, boolint(on))
++}
++
++// JoinGroup joins the group address group on the interface ifi.
++// By default all sources that can cast data to group are accepted.
++// It's possible to mute and unmute data transmission from a specific
++// source by using ExcludeSourceSpecificGroup and
++// IncludeSourceSpecificGroup.
++// JoinGroup uses the system assigned multicast interface when ifi is
++// nil, although this is not recommended because the assignment
++// depends on platforms and sometimes it might require routing
++// configuration.
++func (c *dgramOpt) JoinGroup(ifi *net.Interface, group net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoJoinGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP16(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	return so.setGroup(c.Conn, ifi, grp)
++}
++
++// LeaveGroup leaves the group address group on the interface ifi
++// regardless of whether the group is any-source group or
++// source-specific group.
++func (c *dgramOpt) LeaveGroup(ifi *net.Interface, group net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoLeaveGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP16(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	return so.setGroup(c.Conn, ifi, grp)
++}
++
++// JoinSourceSpecificGroup joins the source-specific group comprising
++// group and source on the interface ifi.
++// JoinSourceSpecificGroup uses the system assigned multicast
++// interface when ifi is nil, although this is not recommended because
++// the assignment depends on platforms and sometimes it might require
++// routing configuration.
++func (c *dgramOpt) JoinSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoJoinSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP16(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP16(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// LeaveSourceSpecificGroup leaves the source-specific group on the
++// interface ifi.
++func (c *dgramOpt) LeaveSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoLeaveSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP16(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP16(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// ExcludeSourceSpecificGroup excludes the source-specific group from
++// the already joined any-source groups by JoinGroup on the interface
++// ifi.
++func (c *dgramOpt) ExcludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoBlockSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP16(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP16(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// IncludeSourceSpecificGroup includes the excluded source-specific
++// group by ExcludeSourceSpecificGroup again on the interface ifi.
++func (c *dgramOpt) IncludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoUnblockSourceGroup]
++	if !ok {
++		return errOpNoSupport
++	}
++	grp := netAddrToIP16(group)
++	if grp == nil {
++		return errMissingAddress
++	}
++	src := netAddrToIP16(source)
++	if src == nil {
++		return errMissingAddress
++	}
++	return so.setSourceGroup(c.Conn, ifi, grp, src)
++}
++
++// Checksum reports whether the kernel will compute, store or verify a
++// checksum for both incoming and outgoing packets. If on is true, it
++// returns an offset in bytes into the data of where the checksum
++// field is located.
++func (c *dgramOpt) Checksum() (on bool, offset int, err error) {
++	if !c.ok() {
++		return false, 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoChecksum]
++	if !ok {
++		return false, 0, errOpNoSupport
++	}
++	offset, err = so.GetInt(c.Conn)
++	if err != nil {
++		return false, 0, err
++	}
++	if offset < 0 {
++		return false, 0, nil
++	}
++	return true, offset, nil
++}
++
++// SetChecksum enables the kernel checksum processing. If on is ture,
++// the offset should be an offset in bytes into the data of where the
++// checksum field is located.
++func (c *dgramOpt) SetChecksum(on bool, offset int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoChecksum]
++	if !ok {
++		return errOpNoSupport
++	}
++	if !on {
++		offset = -1
++	}
++	return so.SetInt(c.Conn, offset)
++}
++
++// ICMPFilter returns an ICMP filter.
++func (c *dgramOpt) ICMPFilter() (*ICMPFilter, error) {
++	if !c.ok() {
++		return nil, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoICMPFilter]
++	if !ok {
++		return nil, errOpNoSupport
++	}
++	return so.getICMPFilter(c.Conn)
++}
++
++// SetICMPFilter deploys the ICMP filter.
++func (c *dgramOpt) SetICMPFilter(f *ICMPFilter) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoICMPFilter]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.setICMPFilter(c.Conn, f)
++}
++
++// SetBPF attaches a BPF program to the connection.
++//
++// Only supported on Linux.
++func (c *dgramOpt) SetBPF(filter []bpf.RawInstruction) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoAttachFilter]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.setBPF(c.Conn, filter)
++}
+diff -uNr go-net.old/ipv6/doc.go go-net/ipv6/doc.go
+--- go-net.old/ipv6/doc.go	2018-05-31 12:15:22.227955715 +0200
++++ go-net/ipv6/doc.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -8,23 +8,24 @@
+ // The package provides IP-level socket options that allow
+ // manipulation of IPv6 facilities.
+ //
+-// The IPv6 protocol is defined in RFC 2460.
+-// Basic and advanced socket interface extensions are defined in RFC
+-// 3493 and RFC 3542.
+-// Socket interface extensions for multicast source filters are
+-// defined in RFC 3678.
++// The IPv6 protocol is defined in RFC 8200.
++// Socket interface extensions are defined in RFC 3493, RFC 3542 and
++// RFC 3678.
+ // MLDv1 and MLDv2 are defined in RFC 2710 and RFC 3810.
+ // Source-specific multicast is defined in RFC 4607.
+ //
++// On Darwin, this package requires OS X Mavericks version 10.9 or
++// above, or equivalent.
++//
+ //
+ // Unicasting
+ //
+ // The options for unicasting are available for net.TCPConn,
+ // net.UDPConn and net.IPConn which are created as network connections
+-// that use the IPv6 transport.  When a single TCP connection carrying
++// that use the IPv6 transport. When a single TCP connection carrying
+ // a data flow of multiple packets needs to indicate the flow is
+-// important, ipv6.Conn is used to set the traffic class field on the
+-// IPv6 header for each packet.
++// important, Conn is used to set the traffic class field on the IPv6
++// header for each packet.
+ //
+ //	ln, err := net.Listen("tcp6", "[::]:1024")
+ //	if err != nil {
+@@ -56,7 +57,7 @@
+ //
+ // The options for multicasting are available for net.UDPConn and
+ // net.IPconn which are created as network connections that use the
+-// IPv6 transport.  A few network facilities must be prepared before
++// IPv6 transport. A few network facilities must be prepared before
+ // you begin multicasting, at a minimum joining network interfaces and
+ // multicast groups.
+ //
+@@ -80,7 +81,7 @@
+ //	defer c.Close()
+ //
+ // Second, the application joins multicast groups, starts listening to
+-// the groups on the specified network interfaces.  Note that the
++// the groups on the specified network interfaces. Note that the
+ // service port for transport layer protocol does not matter with this
+ // operation as joining groups affects only network and link layer
+ // protocols, such as IPv6 and Ethernet.
+@@ -94,10 +95,10 @@
+ //	}
+ //
+ // The application might set per packet control message transmissions
+-// between the protocol stack within the kernel.  When the application
++// between the protocol stack within the kernel. When the application
+ // needs a destination address on an incoming packet,
+-// SetControlMessage of ipv6.PacketConn is used to enable control
+-// message transmissons.
++// SetControlMessage of PacketConn is used to enable control message
++// transmissions.
+ //
+ //	if err := p.SetControlMessage(ipv6.FlagDst, true); err != nil {
+ //		// error handling
+@@ -130,7 +131,7 @@
+ //			// error handling
+ //		}
+ //		dst := &net.UDPAddr{IP: group, Port: 1024}
+-//		wcm := ipv6.ControlMessage{TrafficClass: DiffServCS7, HopLimit: 1}
++//		wcm := ipv6.ControlMessage{TrafficClass: 0xe0, HopLimit: 1}
+ //		for _, ifi := range []*net.Interface{en0, en1} {
+ //			wcm.IfIndex = ifi.Index
+ //			if _, err := p.WriteTo(data[:n], &wcm, dst); err != nil {
+@@ -143,7 +144,7 @@
+ // More multicasting
+ //
+ // An application that uses PacketConn may join multiple multicast
+-// groups.  For example, a UDP listener with port 1024 might join two
++// groups. For example, a UDP listener with port 1024 might join two
+ // different groups across over two different network interfaces by
+ // using:
+ //
+@@ -164,7 +165,7 @@
+ //	}
+ //
+ // It is possible for multiple UDP listeners that listen on the same
+-// UDP port to join the same multicast group.  The net package will
++// UDP port to join the same multicast group. The net package will
+ // provide a socket that listens to a wildcard address with reusable
+ // UDP port when an appropriate multicast address prefix is passed to
+ // the net.ListenPacket or net.ListenUDP.
+@@ -237,4 +238,6 @@
+ // MLDv1 and starts to listen to multicast traffic.
+ // In the fallback case, ExcludeSourceSpecificGroup and
+ // IncludeSourceSpecificGroup may return an error.
+-package ipv6
++package ipv6 // import "golang.org/x/net/ipv6"
++
++// BUG(mikio): This package is not implemented on NaCl and Plan 9.
+diff -uNr go-net.old/ipv6/endpoint.go go-net/ipv6/endpoint.go
+--- go-net.old/ipv6/endpoint.go	2018-05-31 12:15:22.227955715 +0200
++++ go-net/ipv6/endpoint.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -8,8 +8,15 @@
+ 	"net"
+ 	"syscall"
+ 	"time"
++
++	"golang.org/x/net/internal/socket"
+ )
+ 
++// BUG(mikio): On Windows, the JoinSourceSpecificGroup,
++// LeaveSourceSpecificGroup, ExcludeSourceSpecificGroup and
++// IncludeSourceSpecificGroup methods of PacketConn are not
++// implemented.
++
+ // A Conn represents a network endpoint that uses IPv6 transport.
+ // It allows to set basic IP-level socket options such as traffic
+ // class and hop limit.
+@@ -18,7 +25,7 @@
+ }
+ 
+ type genericOpt struct {
+-	net.Conn
++	*socket.Conn
+ }
+ 
+ func (c *genericOpt) ok() bool { return c != nil && c.Conn != nil }
+@@ -26,14 +33,14 @@
+ // PathMTU returns a path MTU value for the destination associated
+ // with the endpoint.
+ func (c *Conn) PathMTU() (int, error) {
+-	if !c.genericOpt.ok() {
++	if !c.ok() {
+ 		return 0, syscall.EINVAL
+ 	}
+-	fd, err := c.genericOpt.sysfd()
+-	if err != nil {
+-		return 0, err
++	so, ok := sockOpts[ssoPathMTU]
++	if !ok {
++		return 0, errOpNoSupport
+ 	}
+-	_, mtu, err := getMTUInfo(fd, &sockOpts[ssoPathMTU])
++	_, mtu, err := so.getMTUInfo(c.Conn)
+ 	if err != nil {
+ 		return 0, err
+ 	}
+@@ -42,14 +49,15 @@
+ 
+ // NewConn returns a new Conn.
+ func NewConn(c net.Conn) *Conn {
++	cc, _ := socket.NewConn(c)
+ 	return &Conn{
+-		genericOpt: genericOpt{Conn: c},
++		genericOpt: genericOpt{Conn: cc},
+ 	}
+ }
+ 
+ // A PacketConn represents a packet network endpoint that uses IPv6
+-// transport.  It is used to control several IP-level socket options
+-// including IPv6 header manipulation.  It also provides datagram
++// transport. It is used to control several IP-level socket options
++// including IPv6 header manipulation. It also provides datagram
+ // based network I/O methods specific to the IPv6 and higher layer
+ // protocols such as OSPF, GRE, and UDP.
+ type PacketConn struct {
+@@ -59,10 +67,10 @@
+ }
+ 
+ type dgramOpt struct {
+-	net.PacketConn
++	*socket.Conn
+ }
+ 
+-func (c *dgramOpt) ok() bool { return c != nil && c.PacketConn != nil }
++func (c *dgramOpt) ok() bool { return c != nil && c.Conn != nil }
+ 
+ // SetControlMessage allows to receive the per packet basis IP-level
+ // socket options.
+@@ -70,11 +78,7 @@
+ 	if !c.payloadHandler.ok() {
+ 		return syscall.EINVAL
+ 	}
+-	fd, err := c.payloadHandler.sysfd()
+-	if err != nil {
+-		return err
+-	}
+-	return setControlMessage(fd, &c.payloadHandler.rawOpt, cf, on)
++	return setControlMessage(c.dgramOpt.Conn, &c.payloadHandler.rawOpt, cf, on)
+ }
+ 
+ // SetDeadline sets the read and write deadlines associated with the
+@@ -115,9 +119,10 @@
+ // NewPacketConn returns a new PacketConn using c as its underlying
+ // transport.
+ func NewPacketConn(c net.PacketConn) *PacketConn {
++	cc, _ := socket.NewConn(c.(net.Conn))
+ 	return &PacketConn{
+-		genericOpt:     genericOpt{Conn: c.(net.Conn)},
+-		dgramOpt:       dgramOpt{PacketConn: c},
+-		payloadHandler: payloadHandler{PacketConn: c},
++		genericOpt:     genericOpt{Conn: cc},
++		dgramOpt:       dgramOpt{Conn: cc},
++		payloadHandler: payloadHandler{PacketConn: c, Conn: cc},
+ 	}
+ }
+diff -uNr go-net.old/ipv6/example_test.go go-net/ipv6/example_test.go
+--- go-net.old/ipv6/example_test.go	2018-05-31 12:15:35.471673998 +0200
++++ go-net/ipv6/example_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -11,12 +11,12 @@
+ 	"os"
+ 	"time"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/icmp"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/icmp"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ func ExampleConn_markingTCP() {
+-	ln, err := net.Listen("tcp6", "[::]:1024")
++	ln, err := net.Listen("tcp", "[::]:1024")
+ 	if err != nil {
+ 		log.Fatal(err)
+ 	}
+@@ -29,12 +29,14 @@
+ 		}
+ 		go func(c net.Conn) {
+ 			defer c.Close()
+-			p := ipv6.NewConn(c)
+-			if err := p.SetTrafficClass(0x28); err != nil { // DSCP AF11
+-				log.Fatal(err)
+-			}
+-			if err := p.SetHopLimit(128); err != nil {
+-				log.Fatal(err)
++			if c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil && c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {
++				p := ipv6.NewConn(c)
++				if err := p.SetTrafficClass(0x28); err != nil { // DSCP AF11
++					log.Fatal(err)
++				}
++				if err := p.SetHopLimit(128); err != nil {
++					log.Fatal(err)
++				}
+ 			}
+ 			if _, err := c.Write([]byte("HELLO-R-U-THERE-ACK")); err != nil {
+ 				log.Fatal(err)
+diff -uNr go-net.old/ipv6/genericopt.go go-net/ipv6/genericopt.go
+--- go-net.old/ipv6/genericopt.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/genericopt.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,58 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6
++
++import "syscall"
++
++// TrafficClass returns the traffic class field value for outgoing
++// packets.
++func (c *genericOpt) TrafficClass() (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoTrafficClass]
++	if !ok {
++		return 0, errOpNoSupport
++	}
++	return so.GetInt(c.Conn)
++}
++
++// SetTrafficClass sets the traffic class field value for future
++// outgoing packets.
++func (c *genericOpt) SetTrafficClass(tclass int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoTrafficClass]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, tclass)
++}
++
++// HopLimit returns the hop limit field value for outgoing packets.
++func (c *genericOpt) HopLimit() (int, error) {
++	if !c.ok() {
++		return 0, syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoHopLimit]
++	if !ok {
++		return 0, errOpNoSupport
++	}
++	return so.GetInt(c.Conn)
++}
++
++// SetHopLimit sets the hop limit field value for future outgoing
++// packets.
++func (c *genericOpt) SetHopLimit(hoplim int) error {
++	if !c.ok() {
++		return syscall.EINVAL
++	}
++	so, ok := sockOpts[ssoHopLimit]
++	if !ok {
++		return errOpNoSupport
++	}
++	return so.SetInt(c.Conn, hoplim)
++}
+diff -uNr go-net.old/ipv6/gen.go go-net/ipv6/gen.go
+--- go-net.old/ipv6/gen.go	2018-05-31 12:15:22.231955629 +0200
++++ go-net/ipv6/gen.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -52,15 +52,6 @@
+ 	if err != nil {
+ 		return err
+ 	}
+-	// The ipv6 pacakge still supports go1.2, and so we need to
+-	// take care of additional platforms in go1.3 and above for
+-	// working with go1.2.
+-	switch {
+-	case runtime.GOOS == "dragonfly" || runtime.GOOS == "solaris":
+-		b = bytes.Replace(b, []byte("package ipv6\n"), []byte("// +build "+runtime.GOOS+"\n\npackage ipv6\n"), 1)
+-	case runtime.GOOS == "linux" && (runtime.GOARCH == "arm64" || runtime.GOARCH == "ppc64" || runtime.GOARCH == "ppc64le"):
+-		b = bytes.Replace(b, []byte("package ipv6\n"), []byte("// +build "+runtime.GOOS+","+runtime.GOARCH+"\n\npackage ipv6\n"), 1)
+-	}
+ 	b, err = format.Source(b)
+ 	if err != nil {
+ 		return err
+@@ -81,7 +72,7 @@
+ 	parse func(io.Writer, io.Reader) error
+ }{
+ 	{
+-		"http://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xml",
++		"https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xml",
+ 		parseICMPv6Parameters,
+ 	},
+ }
+@@ -89,7 +80,7 @@
+ func geniana() error {
+ 	var bb bytes.Buffer
+ 	fmt.Fprintf(&bb, "// go generate gen.go\n")
+-	fmt.Fprintf(&bb, "// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n\n")
++	fmt.Fprintf(&bb, "// Code generated by the command above; DO NOT EDIT.\n\n")
+ 	fmt.Fprintf(&bb, "package ipv6\n\n")
+ 	for _, r := range registries {
+ 		resp, err := http.Get(r.url)
+diff -uNr go-net.old/ipv6/header.go go-net/ipv6/header.go
+--- go-net.old/ipv6/header.go	2018-05-31 12:15:22.231955629 +0200
++++ go-net/ipv6/header.go	2018-05-30 21:00:53.414376369 +0200
+@@ -5,6 +5,7 @@
+ package ipv6
+ 
+ import (
++	"encoding/binary"
+ 	"fmt"
+ 	"net"
+ )
+@@ -42,7 +43,7 @@
+ 		Version:      int(b[0]) >> 4,
+ 		TrafficClass: int(b[0]&0x0f)<<4 | int(b[1])>>4,
+ 		FlowLabel:    int(b[1]&0x0f)<<16 | int(b[2])<<8 | int(b[3]),
+-		PayloadLen:   int(b[4])<<8 | int(b[5]),
++		PayloadLen:   int(binary.BigEndian.Uint16(b[4:6])),
+ 		NextHeader:   int(b[6]),
+ 		HopLimit:     int(b[7]),
+ 	}
+diff -uNr go-net.old/ipv6/header_test.go go-net/ipv6/header_test.go
+--- go-net.old/ipv6/header_test.go	2018-05-31 12:15:35.471673998 +0200
++++ go-net/ipv6/header_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -10,8 +10,8 @@
+ 	"strings"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ var (
+diff -uNr go-net.old/ipv6/helper.go go-net/ipv6/helper.go
+--- go-net.old/ipv6/helper.go	2018-05-31 12:15:22.231955629 +0200
++++ go-net/ipv6/helper.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -37,3 +37,21 @@
+ 	}
+ 	return nil
+ }
++
++func opAddr(a net.Addr) net.Addr {
++	switch a.(type) {
++	case *net.TCPAddr:
++		if a == nil {
++			return nil
++		}
++	case *net.UDPAddr:
++		if a == nil {
++			return nil
++		}
++	case *net.IPAddr:
++		if a == nil {
++			return nil
++		}
++	}
++	return a
++}
+diff -uNr go-net.old/ipv6/iana.go go-net/ipv6/iana.go
+--- go-net.old/ipv6/iana.go	2018-05-31 12:15:22.231955629 +0200
++++ go-net/ipv6/iana.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,9 +1,9 @@
+ // go generate gen.go
+-// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
++// Code generated by the command above; DO NOT EDIT.
+ 
+ package ipv6
+ 
+-// Internet Control Message Protocol version 6 (ICMPv6) Parameters, Updated: 2015-07-07
++// Internet Control Message Protocol version 6 (ICMPv6) Parameters, Updated: 2018-03-09
+ const (
+ 	ICMPTypeDestinationUnreachable                ICMPType = 1   // Destination Unreachable
+ 	ICMPTypePacketTooBig                          ICMPType = 2   // Packet Too Big
+@@ -40,9 +40,11 @@
+ 	ICMPTypeDuplicateAddressRequest               ICMPType = 157 // Duplicate Address Request
+ 	ICMPTypeDuplicateAddressConfirmation          ICMPType = 158 // Duplicate Address Confirmation
+ 	ICMPTypeMPLControl                            ICMPType = 159 // MPL Control Message
++	ICMPTypeExtendedEchoRequest                   ICMPType = 160 // Extended Echo Request
++	ICMPTypeExtendedEchoReply                     ICMPType = 161 // Extended Echo Reply
+ )
+ 
+-// Internet Control Message Protocol version 6 (ICMPv6) Parameters, Updated: 2015-07-07
++// Internet Control Message Protocol version 6 (ICMPv6) Parameters, Updated: 2018-03-09
+ var icmpTypes = map[ICMPType]string{
+ 	1:   "destination unreachable",
+ 	2:   "packet too big",
+@@ -79,4 +81,6 @@
+ 	157: "duplicate address request",
+ 	158: "duplicate address confirmation",
+ 	159: "mpl control message",
++	160: "extended echo request",
++	161: "extended echo reply",
+ }
+diff -uNr go-net.old/ipv6/icmp_bsd.go go-net/ipv6/icmp_bsd.go
+--- go-net.old/ipv6/icmp_bsd.go	2018-05-31 12:15:22.235955543 +0200
++++ go-net/ipv6/icmp_bsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -6,15 +6,15 @@
+ 
+ package ipv6
+ 
+-func (f *sysICMPv6Filter) accept(typ ICMPType) {
++func (f *icmpv6Filter) accept(typ ICMPType) {
+ 	f.Filt[typ>>5] |= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPv6Filter) block(typ ICMPType) {
++func (f *icmpv6Filter) block(typ ICMPType) {
+ 	f.Filt[typ>>5] &^= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPv6Filter) setAll(block bool) {
++func (f *icmpv6Filter) setAll(block bool) {
+ 	for i := range f.Filt {
+ 		if block {
+ 			f.Filt[i] = 0
+@@ -24,6 +24,6 @@
+ 	}
+ }
+ 
+-func (f *sysICMPv6Filter) willBlock(typ ICMPType) bool {
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
+ 	return f.Filt[typ>>5]&(1<<(uint32(typ)&31)) == 0
+ }
+diff -uNr go-net.old/ipv6/icmp.go go-net/ipv6/icmp.go
+--- go-net.old/ipv6/icmp.go	2018-05-31 12:15:35.475673913 +0200
++++ go-net/ipv6/icmp.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,10 +1,13 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv6
+ 
+-import "gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++import "golang.org/x/net/internal/iana"
++
++// BUG(mikio): On Windows, methods related to ICMPFilter are not
++// implemented.
+ 
+ // An ICMPType represents a type of ICMP message.
+ type ICMPType int
+@@ -26,12 +29,12 @@
+ // packets. The filter belongs to a packet delivery path on a host and
+ // it cannot interact with forwarding packets or tunnel-outer packets.
+ //
+-// Note: RFC 2460 defines a reasonable role model. A node means a
++// Note: RFC 8200 defines a reasonable role model. A node means a
+ // device that implements IP. A router means a node that forwards IP
+ // packets not explicitly addressed to itself, and a host means a node
+ // that is not a router.
+ type ICMPFilter struct {
+-	sysICMPv6Filter
++	icmpv6Filter
+ }
+ 
+ // Accept accepts incoming ICMP packets including the type field value
+diff -uNr go-net.old/ipv6/icmp_linux.go go-net/ipv6/icmp_linux.go
+--- go-net.old/ipv6/icmp_linux.go	2018-05-31 12:15:22.235955543 +0200
++++ go-net/ipv6/icmp_linux.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,18 +1,18 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv6
+ 
+-func (f *sysICMPv6Filter) accept(typ ICMPType) {
++func (f *icmpv6Filter) accept(typ ICMPType) {
+ 	f.Data[typ>>5] &^= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPv6Filter) block(typ ICMPType) {
++func (f *icmpv6Filter) block(typ ICMPType) {
+ 	f.Data[typ>>5] |= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPv6Filter) setAll(block bool) {
++func (f *icmpv6Filter) setAll(block bool) {
+ 	for i := range f.Data {
+ 		if block {
+ 			f.Data[i] = 1<<32 - 1
+@@ -22,6 +22,6 @@
+ 	}
+ }
+ 
+-func (f *sysICMPv6Filter) willBlock(typ ICMPType) bool {
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
+ 	return f.Data[typ>>5]&(1<<(uint32(typ)&31)) != 0
+ }
+diff -uNr go-net.old/ipv6/icmp_solaris.go go-net/ipv6/icmp_solaris.go
+--- go-net.old/ipv6/icmp_solaris.go	2018-05-31 12:15:22.235955543 +0200
++++ go-net/ipv6/icmp_solaris.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,24 +1,27 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build solaris
+-
+ package ipv6
+ 
+-func (f *sysICMPv6Filter) accept(typ ICMPType) {
+-	// TODO(mikio): implement this
++func (f *icmpv6Filter) accept(typ ICMPType) {
++	f.X__icmp6_filt[typ>>5] |= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPv6Filter) block(typ ICMPType) {
+-	// TODO(mikio): implement this
++func (f *icmpv6Filter) block(typ ICMPType) {
++	f.X__icmp6_filt[typ>>5] &^= 1 << (uint32(typ) & 31)
+ }
+ 
+-func (f *sysICMPv6Filter) setAll(block bool) {
+-	// TODO(mikio): implement this
++func (f *icmpv6Filter) setAll(block bool) {
++	for i := range f.X__icmp6_filt {
++		if block {
++			f.X__icmp6_filt[i] = 0
++		} else {
++			f.X__icmp6_filt[i] = 1<<32 - 1
++		}
++	}
+ }
+ 
+-func (f *sysICMPv6Filter) willBlock(typ ICMPType) bool {
+-	// TODO(mikio): implement this
+-	return false
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
++	return f.X__icmp6_filt[typ>>5]&(1<<(uint32(typ)&31)) == 0
+ }
+diff -uNr go-net.old/ipv6/icmp_stub.go go-net/ipv6/icmp_stub.go
+--- go-net.old/ipv6/icmp_stub.go	2018-05-31 12:15:22.235955543 +0200
++++ go-net/ipv6/icmp_stub.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,23 +1,23 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv6
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ }
+ 
+-func (f *sysICMPv6Filter) accept(typ ICMPType) {
++func (f *icmpv6Filter) accept(typ ICMPType) {
+ }
+ 
+-func (f *sysICMPv6Filter) block(typ ICMPType) {
++func (f *icmpv6Filter) block(typ ICMPType) {
+ }
+ 
+-func (f *sysICMPv6Filter) setAll(block bool) {
++func (f *icmpv6Filter) setAll(block bool) {
+ }
+ 
+-func (f *sysICMPv6Filter) willBlock(typ ICMPType) bool {
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
+ 	return false
+ }
+diff -uNr go-net.old/ipv6/icmp_test.go go-net/ipv6/icmp_test.go
+--- go-net.old/ipv6/icmp_test.go	2018-05-31 12:15:35.475673913 +0200
++++ go-net/ipv6/icmp_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -10,8 +10,8 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ var icmpStringTests = []struct {
+@@ -34,7 +34,7 @@
+ 
+ func TestICMPFilter(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 
+@@ -61,7 +61,7 @@
+ 
+ func TestSetICMPFilter(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+diff -uNr go-net.old/ipv6/icmp_windows.go go-net/ipv6/icmp_windows.go
+--- go-net.old/ipv6/icmp_windows.go	2018-05-31 12:15:22.235955543 +0200
++++ go-net/ipv6/icmp_windows.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,26 +1,22 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv6
+ 
+-type sysICMPv6Filter struct {
++func (f *icmpv6Filter) accept(typ ICMPType) {
+ 	// TODO(mikio): implement this
+ }
+ 
+-func (f *sysICMPv6Filter) accept(typ ICMPType) {
++func (f *icmpv6Filter) block(typ ICMPType) {
+ 	// TODO(mikio): implement this
+ }
+ 
+-func (f *sysICMPv6Filter) block(typ ICMPType) {
++func (f *icmpv6Filter) setAll(block bool) {
+ 	// TODO(mikio): implement this
+ }
+ 
+-func (f *sysICMPv6Filter) setAll(block bool) {
+-	// TODO(mikio): implement this
+-}
+-
+-func (f *sysICMPv6Filter) willBlock(typ ICMPType) bool {
++func (f *icmpv6Filter) willBlock(typ ICMPType) bool {
+ 	// TODO(mikio): implement this
+ 	return false
+ }
+diff -uNr go-net.old/ipv6/mocktransponder_test.go go-net/ipv6/mocktransponder_test.go
+--- go-net.old/ipv6/mocktransponder_test.go	2018-05-31 12:15:22.235955543 +0200
++++ go-net/ipv6/mocktransponder_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+diff -uNr go-net.old/ipv6/multicastlistener_test.go go-net/ipv6/multicastlistener_test.go
+--- go-net.old/ipv6/multicastlistener_test.go	2018-05-31 12:15:35.495673487 +0200
++++ go-net/ipv6/multicastlistener_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,17 +1,16 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv6_test
+ 
+ import (
+-	"fmt"
+ 	"net"
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ var udpMultipleGroupListenerTests = []net.Addr{
+@@ -22,7 +21,7 @@
+ 
+ func TestUDPSinglePacketConnWithMultipleGroupListeners(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -62,7 +61,7 @@
+ 
+ func TestUDPMultiplePacketConnWithMultipleGroupListeners(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -70,13 +69,16 @@
+ 	}
+ 
+ 	for _, gaddr := range udpMultipleGroupListenerTests {
+-		c1, err := net.ListenPacket("udp6", "[ff02::]:1024") // wildcard address with reusable port
++		c1, err := net.ListenPacket("udp6", "[ff02::]:0") // wildcard address with reusable port
+ 		if err != nil {
+ 			t.Fatal(err)
+ 		}
+ 		defer c1.Close()
+-
+-		c2, err := net.ListenPacket("udp6", "[ff02::]:1024") // wildcard address with reusable port
++		_, port, err := net.SplitHostPort(c1.LocalAddr().String())
++		if err != nil {
++			t.Fatal(err)
++		}
++		c2, err := net.ListenPacket("udp6", net.JoinHostPort("ff02::", port)) // wildcard address with reusable port
+ 		if err != nil {
+ 			t.Fatal(err)
+ 		}
+@@ -114,7 +116,7 @@
+ 
+ func TestUDPPerInterfaceSinglePacketConnWithSingleGroupListener(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -132,16 +134,29 @@
+ 	if err != nil {
+ 		t.Fatal(err)
+ 	}
++	port := "0"
+ 	for i, ifi := range ift {
+ 		ip, ok := nettest.IsMulticastCapable("ip6", &ifi)
+ 		if !ok {
+ 			continue
+ 		}
+-		c, err := net.ListenPacket("udp6", fmt.Sprintf("[%s%%%s]:1024", ip.String(), ifi.Name)) // unicast address with non-reusable port
++		c, err := net.ListenPacket("udp6", net.JoinHostPort(ip.String()+"%"+ifi.Name, port)) // unicast address with non-reusable port
+ 		if err != nil {
+-			t.Fatal(err)
++			// The listen may fail when the serivce is
++			// already in use, but it's fine because the
++			// purpose of this is not to test the
++			// bookkeeping of IP control block inside the
++			// kernel.
++			t.Log(err)
++			continue
+ 		}
+ 		defer c.Close()
++		if port == "0" {
++			_, port, err = net.SplitHostPort(c.LocalAddr().String())
++			if err != nil {
++				t.Fatal(err)
++			}
++		}
+ 		p := ipv6.NewPacketConn(c)
+ 		if err := p.JoinGroup(&ifi, &gaddr); err != nil {
+ 			t.Fatal(err)
+@@ -157,7 +172,7 @@
+ 
+ func TestIPSinglePacketConnWithSingleGroupListener(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -201,7 +216,7 @@
+ 	switch runtime.GOOS {
+ 	case "darwin", "dragonfly", "openbsd": // platforms that return fe80::1%lo0: bind: can't assign requested address
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -227,7 +242,7 @@
+ 		if !ok {
+ 			continue
+ 		}
+-		c, err := net.ListenPacket("ip6:ipv6-icmp", fmt.Sprintf("%s%%%s", ip.String(), ifi.Name)) // unicast address
++		c, err := net.ListenPacket("ip6:ipv6-icmp", ip.String()+"%"+ifi.Name) // unicast address
+ 		if err != nil {
+ 			t.Fatal(err)
+ 		}
+diff -uNr go-net.old/ipv6/multicastsockopt_test.go go-net/ipv6/multicastsockopt_test.go
+--- go-net.old/ipv6/multicastsockopt_test.go	2018-05-31 12:15:35.499673403 +0200
++++ go-net/ipv6/multicastsockopt_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -9,8 +9,8 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ var packetConnMulticastSocketOptionTests = []struct {
+@@ -26,7 +26,7 @@
+ 
+ func TestPacketConnMulticastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+diff -uNr go-net.old/ipv6/multicast_test.go go-net/ipv6/multicast_test.go
+--- go-net.old/ipv6/multicast_test.go	2018-05-31 12:15:35.487673658 +0200
++++ go-net/ipv6/multicast_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,10 +12,10 @@
+ 	"testing"
+ 	"time"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/icmp"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/icmp"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ var packetConnReadWriteMulticastUDPTests = []struct {
+@@ -29,15 +29,15 @@
+ 
+ func TestPacketConnReadWriteMulticastUDP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "freebsd": // due to a bug on loopback marking
+-		// See http://www.freebsd.org/cgi/query-pr.cgi?pr=180065.
+-		t.Skipf("not supported on %s", runtime.GOOS)
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+ 		t.Skip("ipv6 is not supported")
+ 	}
++	if !nettest.SupportsIPv6MulticastDeliveryOnLoopback() {
++		t.Skipf("multicast delivery doesn't work correctly on %s", runtime.GOOS)
++	}
+ 	ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagMulticast|net.FlagLoopback)
+ 	if ifi == nil {
+ 		t.Skipf("not available on %s", runtime.GOOS)
+@@ -129,15 +129,15 @@
+ 
+ func TestPacketConnReadWriteMulticastICMP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "freebsd": // due to a bug on loopback marking
+-		// See http://www.freebsd.org/cgi/query-pr.cgi?pr=180065.
+-		t.Skipf("not supported on %s", runtime.GOOS)
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+ 		t.Skip("ipv6 is not supported")
+ 	}
++	if !nettest.SupportsIPv6MulticastDeliveryOnLoopback() {
++		t.Skipf("multicast delivery doesn't work correctly on %s", runtime.GOOS)
++	}
+ 	if m, ok := nettest.SupportsRawIPSocket(); !ok {
+ 		t.Skip(m)
+ 	}
+@@ -205,7 +205,11 @@
+ 			if toggle {
+ 				psh = nil
+ 				if err := p.SetChecksum(true, 2); err != nil {
+-					t.Fatal(err)
++					// Solaris never allows to
++					// modify ICMP properties.
++					if runtime.GOOS != "solaris" {
++						t.Fatal(err)
++					}
+ 				}
+ 			} else {
+ 				psh = pshicmp
+diff -uNr go-net.old/ipv6/payload_cmsg.go go-net/ipv6/payload_cmsg.go
+--- go-net.old/ipv6/payload_cmsg.go	2018-05-31 12:15:22.239955460 +0200
++++ go-net/ipv6/payload_cmsg.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,59 +12,24 @@
+ )
+ 
+ // ReadFrom reads a payload of the received IPv6 datagram, from the
+-// endpoint c, copying the payload into b.  It returns the number of
++// endpoint c, copying the payload into b. It returns the number of
+ // bytes copied into b, the control message cm and the source address
+ // src of the received datagram.
+ func (c *payloadHandler) ReadFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error) {
+ 	if !c.ok() {
+ 		return 0, nil, nil, syscall.EINVAL
+ 	}
+-	oob := newControlMessage(&c.rawOpt)
+-	var oobn int
+-	switch c := c.PacketConn.(type) {
+-	case *net.UDPConn:
+-		if n, oobn, _, src, err = c.ReadMsgUDP(b, oob); err != nil {
+-			return 0, nil, nil, err
+-		}
+-	case *net.IPConn:
+-		if n, oobn, _, src, err = c.ReadMsgIP(b, oob); err != nil {
+-			return 0, nil, nil, err
+-		}
+-	default:
+-		return 0, nil, nil, errInvalidConnType
+-	}
+-	if cm, err = parseControlMessage(oob[:oobn]); err != nil {
+-		return 0, nil, nil, err
+-	}
+-	if cm != nil {
+-		cm.Src = netAddrToIP16(src)
+-	}
+-	return
++	return c.readFrom(b)
+ }
+ 
+ // WriteTo writes a payload of the IPv6 datagram, to the destination
+-// address dst through the endpoint c, copying the payload from b.  It
+-// returns the number of bytes written.  The control message cm allows
+-// the IPv6 header fields and the datagram path to be specified.  The
++// address dst through the endpoint c, copying the payload from b. It
++// returns the number of bytes written. The control message cm allows
++// the IPv6 header fields and the datagram path to be specified. The
+ // cm may be nil if control of the outgoing datagram is not required.
+ func (c *payloadHandler) WriteTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error) {
+ 	if !c.ok() {
+ 		return 0, syscall.EINVAL
+ 	}
+-	oob := marshalControlMessage(cm)
+-	if dst == nil {
+-		return 0, errMissingAddress
+-	}
+-	switch c := c.PacketConn.(type) {
+-	case *net.UDPConn:
+-		n, _, err = c.WriteMsgUDP(b, oob, dst.(*net.UDPAddr))
+-	case *net.IPConn:
+-		n, _, err = c.WriteMsgIP(b, oob, dst.(*net.IPAddr))
+-	default:
+-		return 0, errInvalidConnType
+-	}
+-	if err != nil {
+-		return 0, err
+-	}
+-	return
++	return c.writeTo(b, cm, dst)
+ }
+diff -uNr go-net.old/ipv6/payload_cmsg_go1_8.go go-net/ipv6/payload_cmsg_go1_8.go
+--- go-net.old/ipv6/payload_cmsg_go1_8.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/payload_cmsg_go1_8.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,55 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !go1.9
++// +build !nacl,!plan9,!windows
++
++package ipv6
++
++import "net"
++
++func (c *payloadHandler) readFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error) {
++	c.rawOpt.RLock()
++	oob := NewControlMessage(c.rawOpt.cflags)
++	c.rawOpt.RUnlock()
++	var nn int
++	switch c := c.PacketConn.(type) {
++	case *net.UDPConn:
++		if n, nn, _, src, err = c.ReadMsgUDP(b, oob); err != nil {
++			return 0, nil, nil, err
++		}
++	case *net.IPConn:
++		if n, nn, _, src, err = c.ReadMsgIP(b, oob); err != nil {
++			return 0, nil, nil, err
++		}
++	default:
++		return 0, nil, nil, &net.OpError{Op: "read", Net: c.LocalAddr().Network(), Source: c.LocalAddr(), Err: errInvalidConnType}
++	}
++	if nn > 0 {
++		cm = new(ControlMessage)
++		if err = cm.Parse(oob[:nn]); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++	}
++	if cm != nil {
++		cm.Src = netAddrToIP16(src)
++	}
++	return
++}
++
++func (c *payloadHandler) writeTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error) {
++	oob := cm.Marshal()
++	if dst == nil {
++		return 0, &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: errMissingAddress}
++	}
++	switch c := c.PacketConn.(type) {
++	case *net.UDPConn:
++		n, _, err = c.WriteMsgUDP(b, oob, dst.(*net.UDPAddr))
++	case *net.IPConn:
++		n, _, err = c.WriteMsgIP(b, oob, dst.(*net.IPAddr))
++	default:
++		return 0, &net.OpError{Op: "write", Net: c.LocalAddr().Network(), Source: c.LocalAddr(), Addr: opAddr(dst), Err: errInvalidConnType}
++	}
++	return
++}
+diff -uNr go-net.old/ipv6/payload_cmsg_go1_9.go go-net/ipv6/payload_cmsg_go1_9.go
+--- go-net.old/ipv6/payload_cmsg_go1_9.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/payload_cmsg_go1_9.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,57 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++// +build !nacl,!plan9,!windows
++
++package ipv6
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (c *payloadHandler) readFrom(b []byte) (int, *ControlMessage, net.Addr, error) {
++	c.rawOpt.RLock()
++	m := socket.Message{
++		Buffers: [][]byte{b},
++		OOB:     NewControlMessage(c.rawOpt.cflags),
++	}
++	c.rawOpt.RUnlock()
++	switch c.PacketConn.(type) {
++	case *net.UDPConn:
++		if err := c.RecvMsg(&m, 0); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++	case *net.IPConn:
++		if err := c.RecvMsg(&m, 0); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++	default:
++		return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: errInvalidConnType}
++	}
++	var cm *ControlMessage
++	if m.NN > 0 {
++		cm = new(ControlMessage)
++		if err := cm.Parse(m.OOB[:m.NN]); err != nil {
++			return 0, nil, nil, &net.OpError{Op: "read", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Err: err}
++		}
++		cm.Src = netAddrToIP16(m.Addr)
++	}
++	return m.N, cm, m.Addr, nil
++}
++
++func (c *payloadHandler) writeTo(b []byte, cm *ControlMessage, dst net.Addr) (int, error) {
++	m := socket.Message{
++		Buffers: [][]byte{b},
++		OOB:     cm.Marshal(),
++		Addr:    dst,
++	}
++	err := c.SendMsg(&m, 0)
++	if err != nil {
++		err = &net.OpError{Op: "write", Net: c.PacketConn.LocalAddr().Network(), Source: c.PacketConn.LocalAddr(), Addr: opAddr(dst), Err: err}
++	}
++	return m.N, err
++}
+diff -uNr go-net.old/ipv6/payload.go go-net/ipv6/payload.go
+--- go-net.old/ipv6/payload.go	2018-05-31 12:15:22.239955460 +0200
++++ go-net/ipv6/payload.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,15 +1,23 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+ package ipv6
+ 
+-import "net"
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++// BUG(mikio): On Windows, the ControlMessage for ReadFrom and WriteTo
++// methods of PacketConn is not implemented.
+ 
+ // A payloadHandler represents the IPv6 datagram payload handler.
+ type payloadHandler struct {
+ 	net.PacketConn
++	*socket.Conn
+ 	rawOpt
+ }
+ 
+-func (c *payloadHandler) ok() bool { return c != nil && c.PacketConn != nil }
++func (c *payloadHandler) ok() bool { return c != nil && c.PacketConn != nil && c.Conn != nil }
+diff -uNr go-net.old/ipv6/payload_nocmsg.go go-net/ipv6/payload_nocmsg.go
+--- go-net.old/ipv6/payload_nocmsg.go	2018-05-31 12:15:22.239955460 +0200
++++ go-net/ipv6/payload_nocmsg.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,7 +12,7 @@
+ )
+ 
+ // ReadFrom reads a payload of the received IPv6 datagram, from the
+-// endpoint c, copying the payload into b.  It returns the number of
++// endpoint c, copying the payload into b. It returns the number of
+ // bytes copied into b, the control message cm and the source address
+ // src of the received datagram.
+ func (c *payloadHandler) ReadFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error) {
+@@ -26,9 +26,9 @@
+ }
+ 
+ // WriteTo writes a payload of the IPv6 datagram, to the destination
+-// address dst through the endpoint c, copying the payload from b.  It
+-// returns the number of bytes written.  The control message cm allows
+-// the IPv6 header fields and the datagram path to be specified.  The
++// address dst through the endpoint c, copying the payload from b. It
++// returns the number of bytes written. The control message cm allows
++// the IPv6 header fields and the datagram path to be specified. The
+ // cm may be nil if control of the outgoing datagram is not required.
+ func (c *payloadHandler) WriteTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error) {
+ 	if !c.ok() {
+diff -uNr go-net.old/ipv6/readwrite_go1_8_test.go go-net/ipv6/readwrite_go1_8_test.go
+--- go-net.old/ipv6/readwrite_go1_8_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/readwrite_go1_8_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,242 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !go1.9
++
++package ipv6_test
++
++import (
++	"bytes"
++	"fmt"
++	"net"
++	"runtime"
++	"strings"
++	"sync"
++	"testing"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
++)
++
++func BenchmarkPacketConnReadWriteUnicast(b *testing.B) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		b.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph := []byte{
++		0x69, 0x8b, 0xee, 0xf1, 0xca, 0xfe, 0xff, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x01, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x02, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++	}
++	greh := []byte{0x00, 0x00, 0x86, 0xdd, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++	bb := make([]byte, 128)
++	cm := ipv6.ControlMessage{
++		TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
++		HopLimit:     1,
++		Src:          net.IPv6loopback,
++	}
++	if ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback); ifi != nil {
++		cm.IfIndex = ifi.Index
++	}
++
++	b.Run("UDP", func(b *testing.B) {
++		c, err := nettest.NewLocalPacketListener("udp6")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv6.FlagHopLimit | ipv6.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(payload, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(payload, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++	b.Run("IP", func(b *testing.B) {
++		switch runtime.GOOS {
++		case "netbsd":
++			b.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			b.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip6:%d", iana.ProtocolGRE), "::1")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(datagram, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(datagram, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++}
++
++func TestPacketConnConcurrentReadWriteUnicast(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph := []byte{
++		0x69, 0x8b, 0xee, 0xf1, 0xca, 0xfe, 0xff, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x01, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x02, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++	}
++	greh := []byte{0x00, 0x00, 0x86, 0xdd, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++
++	t.Run("UDP", func(t *testing.T) {
++		c, err := nettest.NewLocalPacketListener("udp6")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, payload, c.LocalAddr())
++		})
++	})
++	t.Run("IP", func(t *testing.T) {
++		switch runtime.GOOS {
++		case "netbsd":
++			t.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			t.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip6:%d", iana.ProtocolGRE), "::1")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, datagram, c.LocalAddr())
++		})
++	})
++}
++
++func testPacketConnConcurrentReadWriteUnicast(t *testing.T, p *ipv6.PacketConn, data []byte, dst net.Addr) {
++	ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback)
++	cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
++
++	if err := p.SetControlMessage(cf, true); err != nil { // probe before test
++		if nettest.ProtocolNotSupported(err) {
++			t.Skipf("not supported on %s", runtime.GOOS)
++		}
++		t.Fatal(err)
++	}
++
++	var wg sync.WaitGroup
++	reader := func() {
++		defer wg.Done()
++		b := make([]byte, 128)
++		n, cm, _, err := p.ReadFrom(b)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if !bytes.Equal(b[:n], data) {
++			t.Errorf("got %#v; want %#v", b[:n], data)
++			return
++		}
++		s := cm.String()
++		if strings.Contains(s, ",") {
++			t.Errorf("should be space-separated values: %s", s)
++			return
++		}
++	}
++	writer := func(toggle bool) {
++		defer wg.Done()
++		cm := ipv6.ControlMessage{
++			TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
++			HopLimit:     1,
++			Src:          net.IPv6loopback,
++		}
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
++		if err := p.SetControlMessage(cf, toggle); err != nil {
++			t.Error(err)
++			return
++		}
++		n, err := p.WriteTo(data, &cm, dst)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(data) {
++			t.Errorf("got %d; want %d", n, len(data))
++			return
++		}
++	}
++
++	const N = 10
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		go reader()
++	}
++	wg.Add(2 * N)
++	for i := 0; i < 2*N; i++ {
++		go writer(i%2 != 0)
++
++	}
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		go reader()
++	}
++	wg.Wait()
++}
+diff -uNr go-net.old/ipv6/readwrite_go1_9_test.go go-net/ipv6/readwrite_go1_9_test.go
+--- go-net.old/ipv6/readwrite_go1_9_test.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/readwrite_go1_9_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,373 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build go1.9
++
++package ipv6_test
++
++import (
++	"bytes"
++	"fmt"
++	"net"
++	"runtime"
++	"strings"
++	"sync"
++	"testing"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
++)
++
++func BenchmarkPacketConnReadWriteUnicast(b *testing.B) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		b.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph := []byte{
++		0x69, 0x8b, 0xee, 0xf1, 0xca, 0xfe, 0xff, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x01, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x02, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++	}
++	greh := []byte{0x00, 0x00, 0x86, 0xdd, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++	bb := make([]byte, 128)
++	cm := ipv6.ControlMessage{
++		TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
++		HopLimit:     1,
++		Src:          net.IPv6loopback,
++	}
++	if ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback); ifi != nil {
++		cm.IfIndex = ifi.Index
++	}
++
++	b.Run("UDP", func(b *testing.B) {
++		c, err := nettest.NewLocalPacketListener("udp6")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv6.FlagHopLimit | ipv6.FlagInterface
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		wms := []ipv6.Message{
++			{
++				Buffers: [][]byte{payload},
++				Addr:    dst,
++				OOB:     cm.Marshal(),
++			},
++		}
++		rms := []ipv6.Message{
++			{
++				Buffers: [][]byte{bb},
++				OOB:     ipv6.NewControlMessage(cf),
++			},
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(payload, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(payload, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("Batch", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteBatch(wms, 0); err != nil {
++					b.Fatal(err)
++				}
++				if _, err := p.ReadBatch(rms, 0); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++	b.Run("IP", func(b *testing.B) {
++		switch runtime.GOOS {
++		case "netbsd":
++			b.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			b.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip6:%d", iana.ProtocolGRE), "::1")
++		if err != nil {
++			b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		dst := c.LocalAddr()
++		cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		wms := []ipv6.Message{
++			{
++				Buffers: [][]byte{datagram},
++				Addr:    dst,
++				OOB:     cm.Marshal(),
++			},
++		}
++		rms := []ipv6.Message{
++			{
++				Buffers: [][]byte{bb},
++				OOB:     ipv6.NewControlMessage(cf),
++			},
++		}
++		b.Run("Net", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := c.WriteTo(datagram, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, err := c.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("ToFrom", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteTo(datagram, &cm, dst); err != nil {
++					b.Fatal(err)
++				}
++				if _, _, _, err := p.ReadFrom(bb); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++		b.Run("Batch", func(b *testing.B) {
++			for i := 0; i < b.N; i++ {
++				if _, err := p.WriteBatch(wms, 0); err != nil {
++					b.Fatal(err)
++				}
++				if _, err := p.ReadBatch(rms, 0); err != nil {
++					b.Fatal(err)
++				}
++			}
++		})
++	})
++}
++
++func TestPacketConnConcurrentReadWriteUnicast(t *testing.T) {
++	switch runtime.GOOS {
++	case "nacl", "plan9", "windows":
++		t.Skipf("not supported on %s", runtime.GOOS)
++	}
++
++	payload := []byte("HELLO-R-U-THERE")
++	iph := []byte{
++		0x69, 0x8b, 0xee, 0xf1, 0xca, 0xfe, 0xff, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x01, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++		0x20, 0x01, 0x0d, 0xb8, 0x00, 0x02, 0x00, 0x00,
++		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
++	}
++	greh := []byte{0x00, 0x00, 0x86, 0xdd, 0x00, 0x00, 0x00, 0x00}
++	datagram := append(greh, append(iph, payload...)...)
++
++	t.Run("UDP", func(t *testing.T) {
++		c, err := nettest.NewLocalPacketListener("udp6")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, payload, c.LocalAddr(), false)
++		})
++		t.Run("Batch", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, payload, c.LocalAddr(), true)
++		})
++	})
++	t.Run("IP", func(t *testing.T) {
++		switch runtime.GOOS {
++		case "netbsd":
++			t.Skip("need to configure gre on netbsd")
++		case "openbsd":
++			t.Skip("net.inet.gre.allow=0 by default on openbsd")
++		}
++
++		c, err := net.ListenPacket(fmt.Sprintf("ip6:%d", iana.ProtocolGRE), "::1")
++		if err != nil {
++			t.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
++		}
++		defer c.Close()
++		p := ipv6.NewPacketConn(c)
++		t.Run("ToFrom", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, datagram, c.LocalAddr(), false)
++		})
++		t.Run("Batch", func(t *testing.T) {
++			testPacketConnConcurrentReadWriteUnicast(t, p, datagram, c.LocalAddr(), true)
++		})
++	})
++}
++
++func testPacketConnConcurrentReadWriteUnicast(t *testing.T, p *ipv6.PacketConn, data []byte, dst net.Addr, batch bool) {
++	ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback)
++	cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
++
++	if err := p.SetControlMessage(cf, true); err != nil { // probe before test
++		if nettest.ProtocolNotSupported(err) {
++			t.Skipf("not supported on %s", runtime.GOOS)
++		}
++		t.Fatal(err)
++	}
++
++	var wg sync.WaitGroup
++	reader := func() {
++		defer wg.Done()
++		b := make([]byte, 128)
++		n, cm, _, err := p.ReadFrom(b)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if !bytes.Equal(b[:n], data) {
++			t.Errorf("got %#v; want %#v", b[:n], data)
++			return
++		}
++		s := cm.String()
++		if strings.Contains(s, ",") {
++			t.Errorf("should be space-separated values: %s", s)
++			return
++		}
++	}
++	batchReader := func() {
++		defer wg.Done()
++		ms := []ipv6.Message{
++			{
++				Buffers: [][]byte{make([]byte, 128)},
++				OOB:     ipv6.NewControlMessage(cf),
++			},
++		}
++		n, err := p.ReadBatch(ms, 0)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(ms) {
++			t.Errorf("got %d; want %d", n, len(ms))
++			return
++		}
++		var cm ipv6.ControlMessage
++		if err := cm.Parse(ms[0].OOB[:ms[0].NN]); err != nil {
++			t.Error(err)
++			return
++		}
++		b := ms[0].Buffers[0][:ms[0].N]
++		if !bytes.Equal(b, data) {
++			t.Errorf("got %#v; want %#v", b, data)
++			return
++		}
++		s := cm.String()
++		if strings.Contains(s, ",") {
++			t.Errorf("should be space-separated values: %s", s)
++			return
++		}
++	}
++	writer := func(toggle bool) {
++		defer wg.Done()
++		cm := ipv6.ControlMessage{
++			TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
++			HopLimit:     1,
++			Src:          net.IPv6loopback,
++		}
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
++		if err := p.SetControlMessage(cf, toggle); err != nil {
++			t.Error(err)
++			return
++		}
++		n, err := p.WriteTo(data, &cm, dst)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(data) {
++			t.Errorf("got %d; want %d", n, len(data))
++			return
++		}
++	}
++	batchWriter := func(toggle bool) {
++		defer wg.Done()
++		cm := ipv6.ControlMessage{
++			TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
++			HopLimit:     1,
++			Src:          net.IPv6loopback,
++		}
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
++		if err := p.SetControlMessage(cf, toggle); err != nil {
++			t.Error(err)
++			return
++		}
++		ms := []ipv6.Message{
++			{
++				Buffers: [][]byte{data},
++				OOB:     cm.Marshal(),
++				Addr:    dst,
++			},
++		}
++		n, err := p.WriteBatch(ms, 0)
++		if err != nil {
++			t.Error(err)
++			return
++		}
++		if n != len(ms) {
++			t.Errorf("got %d; want %d", n, len(ms))
++			return
++		}
++		if ms[0].N != len(data) {
++			t.Errorf("got %d; want %d", ms[0].N, len(data))
++			return
++		}
++	}
++
++	const N = 10
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		if batch {
++			go batchReader()
++		} else {
++			go reader()
++		}
++	}
++	wg.Add(2 * N)
++	for i := 0; i < 2*N; i++ {
++		if batch {
++			go batchWriter(i%2 != 0)
++		} else {
++			go writer(i%2 != 0)
++		}
++	}
++	wg.Add(N)
++	for i := 0; i < N; i++ {
++		if batch {
++			go batchReader()
++		} else {
++			go reader()
++		}
++	}
++	wg.Wait()
++}
+diff -uNr go-net.old/ipv6/readwrite_test.go go-net/ipv6/readwrite_test.go
+--- go-net.old/ipv6/readwrite_test.go	2018-05-31 12:15:35.507673232 +0200
++++ go-net/ipv6/readwrite_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -12,104 +12,67 @@
+ 	"sync"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+-func benchmarkUDPListener() (net.PacketConn, net.Addr, error) {
+-	c, err := net.ListenPacket("udp6", "[::1]:0")
++func BenchmarkReadWriteUnicast(b *testing.B) {
++	c, err := nettest.NewLocalPacketListener("udp6")
+ 	if err != nil {
+-		return nil, nil, err
+-	}
+-	dst, err := net.ResolveUDPAddr("udp6", c.LocalAddr().String())
+-	if err != nil {
+-		c.Close()
+-		return nil, nil, err
+-	}
+-	return c, dst, nil
+-}
+-
+-func BenchmarkReadWriteNetUDP(b *testing.B) {
+-	if !supportsIPv6 {
+-		b.Skip("ipv6 is not supported")
+-	}
+-
+-	c, dst, err := benchmarkUDPListener()
+-	if err != nil {
+-		b.Fatal(err)
++		b.Skipf("not supported on %s/%s: %v", runtime.GOOS, runtime.GOARCH, err)
+ 	}
+ 	defer c.Close()
+ 
++	dst := c.LocalAddr()
+ 	wb, rb := []byte("HELLO-R-U-THERE"), make([]byte, 128)
+-	b.ResetTimer()
+-	for i := 0; i < b.N; i++ {
+-		benchmarkReadWriteNetUDP(b, c, wb, rb, dst)
+-	}
+-}
+ 
+-func benchmarkReadWriteNetUDP(b *testing.B, c net.PacketConn, wb, rb []byte, dst net.Addr) {
+-	if _, err := c.WriteTo(wb, dst); err != nil {
+-		b.Fatal(err)
+-	}
+-	if _, _, err := c.ReadFrom(rb); err != nil {
+-		b.Fatal(err)
+-	}
+-}
+-
+-func BenchmarkReadWriteIPv6UDP(b *testing.B) {
+-	if !supportsIPv6 {
+-		b.Skip("ipv6 is not supported")
+-	}
+-
+-	c, dst, err := benchmarkUDPListener()
+-	if err != nil {
+-		b.Fatal(err)
+-	}
+-	defer c.Close()
+-
+-	p := ipv6.NewPacketConn(c)
+-	cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
+-	if err := p.SetControlMessage(cf, true); err != nil {
+-		b.Fatal(err)
+-	}
+-	ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback)
+-
+-	wb, rb := []byte("HELLO-R-U-THERE"), make([]byte, 128)
+-	b.ResetTimer()
+-	for i := 0; i < b.N; i++ {
+-		benchmarkReadWriteIPv6UDP(b, p, wb, rb, dst, ifi)
+-	}
+-}
++	b.Run("NetUDP", func(b *testing.B) {
++		for i := 0; i < b.N; i++ {
++			if _, err := c.WriteTo(wb, dst); err != nil {
++				b.Fatal(err)
++			}
++			if _, _, err := c.ReadFrom(rb); err != nil {
++				b.Fatal(err)
++			}
++		}
++	})
++	b.Run("IPv6UDP", func(b *testing.B) {
++		p := ipv6.NewPacketConn(c)
++		cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
++		if err := p.SetControlMessage(cf, true); err != nil {
++			b.Fatal(err)
++		}
++		cm := ipv6.ControlMessage{
++			TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
++			HopLimit:     1,
++		}
++		ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback)
++		if ifi != nil {
++			cm.IfIndex = ifi.Index
++		}
+ 
+-func benchmarkReadWriteIPv6UDP(b *testing.B, p *ipv6.PacketConn, wb, rb []byte, dst net.Addr, ifi *net.Interface) {
+-	cm := ipv6.ControlMessage{
+-		TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
+-		HopLimit:     1,
+-	}
+-	if ifi != nil {
+-		cm.IfIndex = ifi.Index
+-	}
+-	if n, err := p.WriteTo(wb, &cm, dst); err != nil {
+-		b.Fatal(err)
+-	} else if n != len(wb) {
+-		b.Fatalf("got %v; want %v", n, len(wb))
+-	}
+-	if _, _, _, err := p.ReadFrom(rb); err != nil {
+-		b.Fatal(err)
+-	}
++		for i := 0; i < b.N; i++ {
++			if _, err := p.WriteTo(wb, &cm, dst); err != nil {
++				b.Fatal(err)
++			}
++			if _, _, _, err := p.ReadFrom(rb); err != nil {
++				b.Fatal(err)
++			}
++		}
++	})
+ }
+ 
+ func TestPacketConnConcurrentReadWriteUnicastUDP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+ 		t.Skip("ipv6 is not supported")
+ 	}
+ 
+-	c, err := net.ListenPacket("udp6", "[::1]:0")
++	c, err := nettest.NewLocalPacketListener("udp6")
+ 	if err != nil {
+ 		t.Fatal(err)
+ 	}
+@@ -117,11 +80,7 @@
+ 	p := ipv6.NewPacketConn(c)
+ 	defer p.Close()
+ 
+-	dst, err := net.ResolveUDPAddr("udp6", c.LocalAddr().String())
+-	if err != nil {
+-		t.Fatal(err)
+-	}
+-
++	dst := c.LocalAddr()
+ 	ifi := nettest.RoutedInterface("ip6", net.FlagUp|net.FlagLoopback)
+ 	cf := ipv6.FlagTrafficClass | ipv6.FlagHopLimit | ipv6.FlagSrc | ipv6.FlagDst | ipv6.FlagInterface | ipv6.FlagPathMTU
+ 	wb := []byte("HELLO-R-U-THERE")
+@@ -167,7 +126,7 @@
+ 			t.Error(err)
+ 			return
+ 		} else if n != len(wb) {
+-			t.Errorf("got %v; want %v", n, len(wb))
++			t.Errorf("got %d; want %d", n, len(wb))
+ 			return
+ 		}
+ 	}
+diff -uNr go-net.old/ipv6/sockopt.go go-net/ipv6/sockopt.go
+--- go-net.old/ipv6/sockopt.go	2018-05-31 12:15:22.239955460 +0200
++++ go-net/ipv6/sockopt.go	2018-05-30 21:00:53.414376369 +0200
+@@ -4,6 +4,8 @@
+ 
+ package ipv6
+ 
++import "golang.org/x/net/internal/socket"
++
+ // Sticky socket options
+ const (
+ 	ssoTrafficClass        = iota // header field for unicast packet, RFC 3542
+@@ -24,23 +26,18 @@
+ 	ssoLeaveSourceGroup           // source-specific multicast
+ 	ssoBlockSourceGroup           // any-source or source-specific multicast
+ 	ssoUnblockSourceGroup         // any-source or source-specific multicast
+-	ssoMax
++	ssoAttachFilter               // attach BPF for filtering inbound traffic
+ )
+ 
+ // Sticky socket option value types
+ const (
+-	ssoTypeInt = iota + 1
+-	ssoTypeInterface
+-	ssoTypeICMPFilter
+-	ssoTypeMTUInfo
+-	ssoTypeIPMreq
++	ssoTypeIPMreq = iota + 1
+ 	ssoTypeGroupReq
+ 	ssoTypeGroupSourceReq
+ )
+ 
+ // A sockOpt represents a binding for sticky socket option.
+ type sockOpt struct {
+-	level int // option level
+-	name  int // option name, must be equal or greater than 1
+-	typ   int // option value type, must be equal or greater than 1
++	socket.Option
++	typ int // hint for option value type; optional
+ }
+diff -uNr go-net.old/ipv6/sockopt_posix.go go-net/ipv6/sockopt_posix.go
+--- go-net.old/ipv6/sockopt_posix.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sockopt_posix.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,87 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris windows
++
++package ipv6
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) getMulticastInterface(c *socket.Conn) (*net.Interface, error) {
++	n, err := so.GetInt(c)
++	if err != nil {
++		return nil, err
++	}
++	return net.InterfaceByIndex(n)
++}
++
++func (so *sockOpt) setMulticastInterface(c *socket.Conn, ifi *net.Interface) error {
++	var n int
++	if ifi != nil {
++		n = ifi.Index
++	}
++	return so.SetInt(c, n)
++}
++
++func (so *sockOpt) getICMPFilter(c *socket.Conn) (*ICMPFilter, error) {
++	b := make([]byte, so.Len)
++	n, err := so.Get(c, b)
++	if err != nil {
++		return nil, err
++	}
++	if n != sizeofICMPv6Filter {
++		return nil, errOpNoSupport
++	}
++	return (*ICMPFilter)(unsafe.Pointer(&b[0])), nil
++}
++
++func (so *sockOpt) setICMPFilter(c *socket.Conn, f *ICMPFilter) error {
++	b := (*[sizeofICMPv6Filter]byte)(unsafe.Pointer(f))[:sizeofICMPv6Filter]
++	return so.Set(c, b)
++}
++
++func (so *sockOpt) getMTUInfo(c *socket.Conn) (*net.Interface, int, error) {
++	b := make([]byte, so.Len)
++	n, err := so.Get(c, b)
++	if err != nil {
++		return nil, 0, err
++	}
++	if n != sizeofIPv6Mtuinfo {
++		return nil, 0, errOpNoSupport
++	}
++	mi := (*ipv6Mtuinfo)(unsafe.Pointer(&b[0]))
++	if mi.Addr.Scope_id == 0 {
++		return nil, int(mi.Mtu), nil
++	}
++	ifi, err := net.InterfaceByIndex(int(mi.Addr.Scope_id))
++	if err != nil {
++		return nil, 0, err
++	}
++	return ifi, int(mi.Mtu), nil
++}
++
++func (so *sockOpt) setGroup(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	switch so.typ {
++	case ssoTypeIPMreq:
++		return so.setIPMreq(c, ifi, grp)
++	case ssoTypeGroupReq:
++		return so.setGroupReq(c, ifi, grp)
++	default:
++		return errOpNoSupport
++	}
++}
++
++func (so *sockOpt) setSourceGroup(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	return so.setGroupSourceReq(c, ifi, grp, src)
++}
++
++func (so *sockOpt) setBPF(c *socket.Conn, f []bpf.RawInstruction) error {
++	return so.setAttachFilter(c, f)
++}
+diff -uNr go-net.old/ipv6/sockopt_stub.go go-net/ipv6/sockopt_stub.go
+--- go-net.old/ipv6/sockopt_stub.go	2018-05-31 12:15:22.243955374 +0200
++++ go-net/ipv6/sockopt_stub.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,13 +1,46 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9 solaris
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv6
+ 
+-import "net"
++import (
++	"net"
+ 
+-func getMTUInfo(fd int, opt *sockOpt) (*net.Interface, int, error) {
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) getMulticastInterface(c *socket.Conn) (*net.Interface, error) {
++	return nil, errOpNoSupport
++}
++
++func (so *sockOpt) setMulticastInterface(c *socket.Conn, ifi *net.Interface) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) getICMPFilter(c *socket.Conn) (*ICMPFilter, error) {
++	return nil, errOpNoSupport
++}
++
++func (so *sockOpt) setICMPFilter(c *socket.Conn, f *ICMPFilter) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) getMTUInfo(c *socket.Conn) (*net.Interface, int, error) {
+ 	return nil, 0, errOpNoSupport
+ }
++
++func (so *sockOpt) setGroup(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setSourceGroup(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setBPF(c *socket.Conn, f []bpf.RawInstruction) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv6/sockopt_test.go go-net/ipv6/sockopt_test.go
+--- go-net.old/ipv6/sockopt_test.go	2018-05-31 12:15:35.511673147 +0200
++++ go-net/ipv6/sockopt_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -10,16 +10,16 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ var supportsIPv6 bool = nettest.SupportsIPv6()
+ 
+ func TestConnInitiatorPathMTU(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -57,7 +57,7 @@
+ 
+ func TestConnResponderPathMTU(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -95,7 +95,7 @@
+ 
+ func TestPacketConnChecksum(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+diff -uNr go-net.old/ipv6/sys_asmreq.go go-net/ipv6/sys_asmreq.go
+--- go-net.old/ipv6/sys_asmreq.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_asmreq.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,24 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin dragonfly freebsd linux netbsd openbsd solaris windows
++
++package ipv6
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setIPMreq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	var mreq ipv6Mreq
++	copy(mreq.Multiaddr[:], grp)
++	if ifi != nil {
++		mreq.setIfindex(ifi.Index)
++	}
++	b := (*[sizeofIPv6Mreq]byte)(unsafe.Pointer(&mreq))[:sizeofIPv6Mreq]
++	return so.Set(c, b)
++}
+diff -uNr go-net.old/ipv6/sys_asmreq_stub.go go-net/ipv6/sys_asmreq_stub.go
+--- go-net.old/ipv6/sys_asmreq_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_asmreq_stub.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,17 @@
++// Copyright 2013 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
++
++package ipv6
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setIPMreq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv6/sys_bpf.go go-net/ipv6/sys_bpf.go
+--- go-net.old/ipv6/sys_bpf.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_bpf.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,23 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build linux
++
++package ipv6
++
++import (
++	"unsafe"
++
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setAttachFilter(c *socket.Conn, f []bpf.RawInstruction) error {
++	prog := sockFProg{
++		Len:    uint16(len(f)),
++		Filter: (*sockFilter)(unsafe.Pointer(&f[0])),
++	}
++	b := (*[sizeofSockFprog]byte)(unsafe.Pointer(&prog))[:sizeofSockFprog]
++	return so.Set(c, b)
++}
+diff -uNr go-net.old/ipv6/sys_bpf_stub.go go-net/ipv6/sys_bpf_stub.go
+--- go-net.old/ipv6/sys_bpf_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_bpf_stub.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,16 @@
++// Copyright 2017 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !linux
++
++package ipv6
++
++import (
++	"golang.org/x/net/bpf"
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setAttachFilter(c *socket.Conn, f []bpf.RawInstruction) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv6/sys_bsd.go go-net/ipv6/sys_bsd.go
+--- go-net.old/ipv6/sys_bsd.go	2018-05-31 12:15:35.515673061 +0200
++++ go-net/ipv6/sys_bsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -10,49 +10,48 @@
+ 	"net"
+ 	"syscall"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+-type sysSockoptLen int32
+-
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+ 		ctlTrafficClass: {sysIPV6_TCLASS, 4, marshalTrafficClass, parseTrafficClass},
+ 		ctlHopLimit:     {sysIPV6_HOPLIMIT, 4, marshalHopLimit, parseHopLimit},
+-		ctlPacketInfo:   {sysIPV6_PKTINFO, sysSizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
+-		ctlNextHop:      {sysIPV6_NEXTHOP, sysSizeofSockaddrInet6, marshalNextHop, parseNextHop},
+-		ctlPathMTU:      {sysIPV6_PATHMTU, sysSizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
++		ctlPacketInfo:   {sysIPV6_PKTINFO, sizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
++		ctlNextHop:      {sysIPV6_NEXTHOP, sizeofSockaddrInet6, marshalNextHop, parseNextHop},
++		ctlPathMTU:      {sysIPV6_PATHMTU, sizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTrafficClass:        {iana.ProtocolIPv6, sysIPV6_TCLASS, ssoTypeInt},
+-		ssoHopLimit:            {iana.ProtocolIPv6, sysIPV6_UNICAST_HOPS, ssoTypeInt},
+-		ssoMulticastInterface:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastHopLimit:   {iana.ProtocolIPv6, sysIPV6_MULTICAST_HOPS, ssoTypeInt},
+-		ssoMulticastLoopback:   {iana.ProtocolIPv6, sysIPV6_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTrafficClass: {iana.ProtocolIPv6, sysIPV6_RECVTCLASS, ssoTypeInt},
+-		ssoReceiveHopLimit:     {iana.ProtocolIPv6, sysIPV6_RECVHOPLIMIT, ssoTypeInt},
+-		ssoReceivePacketInfo:   {iana.ProtocolIPv6, sysIPV6_RECVPKTINFO, ssoTypeInt},
+-		ssoReceivePathMTU:      {iana.ProtocolIPv6, sysIPV6_RECVPATHMTU, ssoTypeInt},
+-		ssoPathMTU:             {iana.ProtocolIPv6, sysIPV6_PATHMTU, ssoTypeMTUInfo},
+-		ssoChecksum:            {iana.ProtocolIPv6, sysIPV6_CHECKSUM, ssoTypeInt},
+-		ssoICMPFilter:          {iana.ProtocolIPv6ICMP, sysICMP6_FILTER, ssoTypeICMPFilter},
+-		ssoJoinGroup:           {iana.ProtocolIPv6, sysIPV6_JOIN_GROUP, ssoTypeIPMreq},
+-		ssoLeaveGroup:          {iana.ProtocolIPv6, sysIPV6_LEAVE_GROUP, ssoTypeIPMreq},
++	sockOpts = map[int]*sockOpt{
++		ssoTrafficClass:        {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_TCLASS, Len: 4}},
++		ssoHopLimit:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_UNICAST_HOPS, Len: 4}},
++		ssoMulticastInterface:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_IF, Len: 4}},
++		ssoMulticastHopLimit:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_HOPS, Len: 4}},
++		ssoMulticastLoopback:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTrafficClass: {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVTCLASS, Len: 4}},
++		ssoReceiveHopLimit:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVHOPLIMIT, Len: 4}},
++		ssoReceivePacketInfo:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPKTINFO, Len: 4}},
++		ssoReceivePathMTU:      {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPATHMTU, Len: 4}},
++		ssoPathMTU:             {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_PATHMTU, Len: sizeofIPv6Mtuinfo}},
++		ssoChecksum:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_CHECKSUM, Len: 4}},
++		ssoICMPFilter:          {Option: socket.Option{Level: iana.ProtocolIPv6ICMP, Name: sysICMP6_FILTER, Len: sizeofICMPv6Filter}},
++		ssoJoinGroup:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_JOIN_GROUP, Len: sizeofIPv6Mreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:          {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_LEAVE_GROUP, Len: sizeofIPv6Mreq}, typ: ssoTypeIPMreq},
+ 	}
+ )
+ 
+-func (sa *sysSockaddrInet6) setSockaddr(ip net.IP, i int) {
+-	sa.Len = sysSizeofSockaddrInet6
++func (sa *sockaddrInet6) setSockaddr(ip net.IP, i int) {
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], ip)
+ 	sa.Scope_id = uint32(i)
+ }
+ 
+-func (pi *sysInet6Pktinfo) setIfindex(i int) {
++func (pi *inet6Pktinfo) setIfindex(i int) {
+ 	pi.Ifindex = uint32(i)
+ }
+ 
+-func (mreq *sysIPv6Mreq) setIfindex(i int) {
++func (mreq *ipv6Mreq) setIfindex(i int) {
+ 	mreq.Interface = uint32(i)
+ }
+diff -uNr go-net.old/ipv6/sys_darwin.go go-net/ipv6/sys_darwin.go
+--- go-net.old/ipv6/sys_darwin.go	2018-05-31 12:15:35.519672978 +0200
++++ go-net/ipv6/sys_darwin.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -6,130 +6,101 @@
+ 
+ import (
+ 	"net"
++	"strconv"
++	"strings"
+ 	"syscall"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+-type sysSockoptLen int32
+-
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+ 		ctlHopLimit:   {sysIPV6_2292HOPLIMIT, 4, marshal2292HopLimit, parseHopLimit},
+-		ctlPacketInfo: {sysIPV6_2292PKTINFO, sysSizeofInet6Pktinfo, marshal2292PacketInfo, parsePacketInfo},
++		ctlPacketInfo: {sysIPV6_2292PKTINFO, sizeofInet6Pktinfo, marshal2292PacketInfo, parsePacketInfo},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoHopLimit:           {iana.ProtocolIPv6, sysIPV6_UNICAST_HOPS, ssoTypeInt},
+-		ssoMulticastInterface: {iana.ProtocolIPv6, sysIPV6_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastHopLimit:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_HOPS, ssoTypeInt},
+-		ssoMulticastLoopback:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveHopLimit:    {iana.ProtocolIPv6, sysIPV6_2292HOPLIMIT, ssoTypeInt},
+-		ssoReceivePacketInfo:  {iana.ProtocolIPv6, sysIPV6_2292PKTINFO, ssoTypeInt},
+-		ssoChecksum:           {iana.ProtocolIPv6, sysIPV6_CHECKSUM, ssoTypeInt},
+-		ssoICMPFilter:         {iana.ProtocolIPv6ICMP, sysICMP6_FILTER, ssoTypeICMPFilter},
+-		ssoJoinGroup:          {iana.ProtocolIPv6, sysIPV6_JOIN_GROUP, ssoTypeIPMreq},
+-		ssoLeaveGroup:         {iana.ProtocolIPv6, sysIPV6_LEAVE_GROUP, ssoTypeIPMreq},
++	sockOpts = map[int]*sockOpt{
++		ssoHopLimit:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_UNICAST_HOPS, Len: 4}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_IF, Len: 4}},
++		ssoMulticastHopLimit:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_HOPS, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveHopLimit:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_2292HOPLIMIT, Len: 4}},
++		ssoReceivePacketInfo:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_2292PKTINFO, Len: 4}},
++		ssoChecksum:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_CHECKSUM, Len: 4}},
++		ssoICMPFilter:         {Option: socket.Option{Level: iana.ProtocolIPv6ICMP, Name: sysICMP6_FILTER, Len: sizeofICMPv6Filter}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_JOIN_GROUP, Len: sizeofIPv6Mreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_LEAVE_GROUP, Len: sizeofIPv6Mreq}, typ: ssoTypeIPMreq},
+ 	}
+ )
+ 
+ func init() {
+ 	// Seems like kern.osreldate is veiled on latest OS X. We use
+ 	// kern.osrelease instead.
+-	osver, err := syscall.Sysctl("kern.osrelease")
++	s, err := syscall.Sysctl("kern.osrelease")
+ 	if err != nil {
+ 		return
+ 	}
+-	var i int
+-	for i = range osver {
+-		if osver[i] == '.' {
+-			break
+-		}
++	ss := strings.Split(s, ".")
++	if len(ss) == 0 {
++		return
+ 	}
+ 	// The IP_PKTINFO and protocol-independent multicast API were
+-	// introduced in OS X 10.7 (Darwin 11.0.0). But it looks like
+-	// those features require OS X 10.8 (Darwin 12.0.0) and above.
++	// introduced in OS X 10.7 (Darwin 11). But it looks like
++	// those features require OS X 10.8 (Darwin 12) or above.
+ 	// See http://support.apple.com/kb/HT1633.
+-	if i > 2 || i == 2 && osver[0] >= '1' && osver[1] >= '2' {
+-		ctlOpts[ctlTrafficClass].name = sysIPV6_TCLASS
+-		ctlOpts[ctlTrafficClass].length = 4
+-		ctlOpts[ctlTrafficClass].marshal = marshalTrafficClass
+-		ctlOpts[ctlTrafficClass].parse = parseTrafficClass
+-		ctlOpts[ctlHopLimit].name = sysIPV6_HOPLIMIT
+-		ctlOpts[ctlHopLimit].marshal = marshalHopLimit
+-		ctlOpts[ctlPacketInfo].name = sysIPV6_PKTINFO
+-		ctlOpts[ctlPacketInfo].marshal = marshalPacketInfo
+-		ctlOpts[ctlNextHop].name = sysIPV6_NEXTHOP
+-		ctlOpts[ctlNextHop].length = sysSizeofSockaddrInet6
+-		ctlOpts[ctlNextHop].marshal = marshalNextHop
+-		ctlOpts[ctlNextHop].parse = parseNextHop
+-		ctlOpts[ctlPathMTU].name = sysIPV6_PATHMTU
+-		ctlOpts[ctlPathMTU].length = sysSizeofIPv6Mtuinfo
+-		ctlOpts[ctlPathMTU].marshal = marshalPathMTU
+-		ctlOpts[ctlPathMTU].parse = parsePathMTU
+-		sockOpts[ssoTrafficClass].level = iana.ProtocolIPv6
+-		sockOpts[ssoTrafficClass].name = sysIPV6_TCLASS
+-		sockOpts[ssoTrafficClass].typ = ssoTypeInt
+-		sockOpts[ssoReceiveTrafficClass].level = iana.ProtocolIPv6
+-		sockOpts[ssoReceiveTrafficClass].name = sysIPV6_RECVTCLASS
+-		sockOpts[ssoReceiveTrafficClass].typ = ssoTypeInt
+-		sockOpts[ssoReceiveHopLimit].name = sysIPV6_RECVHOPLIMIT
+-		sockOpts[ssoReceivePacketInfo].name = sysIPV6_RECVPKTINFO
+-		sockOpts[ssoReceivePathMTU].level = iana.ProtocolIPv6
+-		sockOpts[ssoReceivePathMTU].name = sysIPV6_RECVPATHMTU
+-		sockOpts[ssoReceivePathMTU].typ = ssoTypeInt
+-		sockOpts[ssoPathMTU].level = iana.ProtocolIPv6
+-		sockOpts[ssoPathMTU].name = sysIPV6_PATHMTU
+-		sockOpts[ssoPathMTU].typ = ssoTypeMTUInfo
+-		sockOpts[ssoJoinGroup].name = sysMCAST_JOIN_GROUP
+-		sockOpts[ssoJoinGroup].typ = ssoTypeGroupReq
+-		sockOpts[ssoLeaveGroup].name = sysMCAST_LEAVE_GROUP
+-		sockOpts[ssoLeaveGroup].typ = ssoTypeGroupReq
+-		sockOpts[ssoJoinSourceGroup].level = iana.ProtocolIPv6
+-		sockOpts[ssoJoinSourceGroup].name = sysMCAST_JOIN_SOURCE_GROUP
+-		sockOpts[ssoJoinSourceGroup].typ = ssoTypeGroupSourceReq
+-		sockOpts[ssoLeaveSourceGroup].level = iana.ProtocolIPv6
+-		sockOpts[ssoLeaveSourceGroup].name = sysMCAST_LEAVE_SOURCE_GROUP
+-		sockOpts[ssoLeaveSourceGroup].typ = ssoTypeGroupSourceReq
+-		sockOpts[ssoBlockSourceGroup].level = iana.ProtocolIPv6
+-		sockOpts[ssoBlockSourceGroup].name = sysMCAST_BLOCK_SOURCE
+-		sockOpts[ssoBlockSourceGroup].typ = ssoTypeGroupSourceReq
+-		sockOpts[ssoUnblockSourceGroup].level = iana.ProtocolIPv6
+-		sockOpts[ssoUnblockSourceGroup].name = sysMCAST_UNBLOCK_SOURCE
+-		sockOpts[ssoUnblockSourceGroup].typ = ssoTypeGroupSourceReq
++	if mjver, err := strconv.Atoi(ss[0]); err != nil || mjver < 12 {
++		return
+ 	}
++	ctlOpts[ctlTrafficClass] = ctlOpt{sysIPV6_TCLASS, 4, marshalTrafficClass, parseTrafficClass}
++	ctlOpts[ctlHopLimit] = ctlOpt{sysIPV6_HOPLIMIT, 4, marshalHopLimit, parseHopLimit}
++	ctlOpts[ctlPacketInfo] = ctlOpt{sysIPV6_PKTINFO, sizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo}
++	ctlOpts[ctlNextHop] = ctlOpt{sysIPV6_NEXTHOP, sizeofSockaddrInet6, marshalNextHop, parseNextHop}
++	ctlOpts[ctlPathMTU] = ctlOpt{sysIPV6_PATHMTU, sizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU}
++	sockOpts[ssoTrafficClass] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_TCLASS, Len: 4}}
++	sockOpts[ssoReceiveTrafficClass] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVTCLASS, Len: 4}}
++	sockOpts[ssoReceiveHopLimit] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVHOPLIMIT, Len: 4}}
++	sockOpts[ssoReceivePacketInfo] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPKTINFO, Len: 4}}
++	sockOpts[ssoReceivePathMTU] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPATHMTU, Len: 4}}
++	sockOpts[ssoPathMTU] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_PATHMTU, Len: sizeofIPv6Mtuinfo}}
++	sockOpts[ssoJoinGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq}
++	sockOpts[ssoLeaveGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq}
++	sockOpts[ssoJoinSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
++	sockOpts[ssoLeaveSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
++	sockOpts[ssoBlockSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
++	sockOpts[ssoUnblockSourceGroup] = &sockOpt{Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq}
+ }
+ 
+-func (sa *sysSockaddrInet6) setSockaddr(ip net.IP, i int) {
+-	sa.Len = sysSizeofSockaddrInet6
++func (sa *sockaddrInet6) setSockaddr(ip net.IP, i int) {
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], ip)
+ 	sa.Scope_id = uint32(i)
+ }
+ 
+-func (pi *sysInet6Pktinfo) setIfindex(i int) {
++func (pi *inet6Pktinfo) setIfindex(i int) {
+ 	pi.Ifindex = uint32(i)
+ }
+ 
+-func (mreq *sysIPv6Mreq) setIfindex(i int) {
++func (mreq *ipv6Mreq) setIfindex(i int) {
+ 	mreq.Interface = uint32(i)
+ }
+ 
+-func (gr *sysGroupReq) setGroup(grp net.IP) {
+-	sa := (*sysSockaddrInet6)(unsafe.Pointer(&gr.Pad_cgo_0[0]))
+-	sa.Len = sysSizeofSockaddrInet6
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(uintptr(unsafe.Pointer(gr)) + 4))
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], grp)
+ }
+ 
+-func (gsr *sysGroupSourceReq) setSourceGroup(grp, src net.IP) {
+-	sa := (*sysSockaddrInet6)(unsafe.Pointer(&gsr.Pad_cgo_0[0]))
+-	sa.Len = sysSizeofSockaddrInet6
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 4))
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], grp)
+-	sa = (*sysSockaddrInet6)(unsafe.Pointer(&gsr.Pad_cgo_1[0]))
+-	sa.Len = sysSizeofSockaddrInet6
++	sa = (*sockaddrInet6)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 132))
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], src)
+ }
+diff -uNr go-net.old/ipv6/sys_freebsd.go go-net/ipv6/sys_freebsd.go
+--- go-net.old/ipv6/sys_freebsd.go	2018-05-31 12:15:35.523672892 +0200
++++ go-net/ipv6/sys_freebsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -11,39 +11,38 @@
+ 	"syscall"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+-type sysSockoptLen int32
+-
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+ 		ctlTrafficClass: {sysIPV6_TCLASS, 4, marshalTrafficClass, parseTrafficClass},
+ 		ctlHopLimit:     {sysIPV6_HOPLIMIT, 4, marshalHopLimit, parseHopLimit},
+-		ctlPacketInfo:   {sysIPV6_PKTINFO, sysSizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
+-		ctlNextHop:      {sysIPV6_NEXTHOP, sysSizeofSockaddrInet6, marshalNextHop, parseNextHop},
+-		ctlPathMTU:      {sysIPV6_PATHMTU, sysSizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
++		ctlPacketInfo:   {sysIPV6_PKTINFO, sizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
++		ctlNextHop:      {sysIPV6_NEXTHOP, sizeofSockaddrInet6, marshalNextHop, parseNextHop},
++		ctlPathMTU:      {sysIPV6_PATHMTU, sizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTrafficClass:        {iana.ProtocolIPv6, sysIPV6_TCLASS, ssoTypeInt},
+-		ssoHopLimit:            {iana.ProtocolIPv6, sysIPV6_UNICAST_HOPS, ssoTypeInt},
+-		ssoMulticastInterface:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastHopLimit:   {iana.ProtocolIPv6, sysIPV6_MULTICAST_HOPS, ssoTypeInt},
+-		ssoMulticastLoopback:   {iana.ProtocolIPv6, sysIPV6_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTrafficClass: {iana.ProtocolIPv6, sysIPV6_RECVTCLASS, ssoTypeInt},
+-		ssoReceiveHopLimit:     {iana.ProtocolIPv6, sysIPV6_RECVHOPLIMIT, ssoTypeInt},
+-		ssoReceivePacketInfo:   {iana.ProtocolIPv6, sysIPV6_RECVPKTINFO, ssoTypeInt},
+-		ssoReceivePathMTU:      {iana.ProtocolIPv6, sysIPV6_RECVPATHMTU, ssoTypeInt},
+-		ssoPathMTU:             {iana.ProtocolIPv6, sysIPV6_PATHMTU, ssoTypeMTUInfo},
+-		ssoChecksum:            {iana.ProtocolIPv6, sysIPV6_CHECKSUM, ssoTypeInt},
+-		ssoICMPFilter:          {iana.ProtocolIPv6ICMP, sysICMP6_FILTER, ssoTypeICMPFilter},
+-		ssoJoinGroup:           {iana.ProtocolIPv6, sysMCAST_JOIN_GROUP, ssoTypeGroupReq},
+-		ssoLeaveGroup:          {iana.ProtocolIPv6, sysMCAST_LEAVE_GROUP, ssoTypeGroupReq},
+-		ssoJoinSourceGroup:     {iana.ProtocolIPv6, sysMCAST_JOIN_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoLeaveSourceGroup:    {iana.ProtocolIPv6, sysMCAST_LEAVE_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoBlockSourceGroup:    {iana.ProtocolIPv6, sysMCAST_BLOCK_SOURCE, ssoTypeGroupSourceReq},
+-		ssoUnblockSourceGroup:  {iana.ProtocolIPv6, sysMCAST_UNBLOCK_SOURCE, ssoTypeGroupSourceReq},
++	sockOpts = map[int]sockOpt{
++		ssoTrafficClass:        {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_TCLASS, Len: 4}},
++		ssoHopLimit:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_UNICAST_HOPS, Len: 4}},
++		ssoMulticastInterface:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_IF, Len: 4}},
++		ssoMulticastHopLimit:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_HOPS, Len: 4}},
++		ssoMulticastLoopback:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTrafficClass: {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVTCLASS, Len: 4}},
++		ssoReceiveHopLimit:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVHOPLIMIT, Len: 4}},
++		ssoReceivePacketInfo:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPKTINFO, Len: 4}},
++		ssoReceivePathMTU:      {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPATHMTU, Len: 4}},
++		ssoPathMTU:             {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_PATHMTU, Len: sizeofIPv6Mtuinfo}},
++		ssoChecksum:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_CHECKSUM, Len: 4}},
++		ssoICMPFilter:          {Option: socket.Option{Level: iana.ProtocolIPv6ICMP, Name: sysICMP6_FILTER, Len: sizeofICMPv6Filter}},
++		ssoJoinGroup:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoLeaveGroup:          {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoJoinSourceGroup:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoLeaveSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoBlockSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoUnblockSourceGroup:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
+ 	}
+ )
+ 
+@@ -59,35 +58,35 @@
+ 	}
+ }
+ 
+-func (sa *sysSockaddrInet6) setSockaddr(ip net.IP, i int) {
+-	sa.Len = sysSizeofSockaddrInet6
++func (sa *sockaddrInet6) setSockaddr(ip net.IP, i int) {
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], ip)
+ 	sa.Scope_id = uint32(i)
+ }
+ 
+-func (pi *sysInet6Pktinfo) setIfindex(i int) {
++func (pi *inet6Pktinfo) setIfindex(i int) {
+ 	pi.Ifindex = uint32(i)
+ }
+ 
+-func (mreq *sysIPv6Mreq) setIfindex(i int) {
++func (mreq *ipv6Mreq) setIfindex(i int) {
+ 	mreq.Interface = uint32(i)
+ }
+ 
+-func (gr *sysGroupReq) setGroup(grp net.IP) {
+-	sa := (*sysSockaddrInet6)(unsafe.Pointer(&gr.Group))
+-	sa.Len = sysSizeofSockaddrInet6
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(&gr.Group))
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], grp)
+ }
+ 
+-func (gsr *sysGroupSourceReq) setSourceGroup(grp, src net.IP) {
+-	sa := (*sysSockaddrInet6)(unsafe.Pointer(&gsr.Group))
+-	sa.Len = sysSizeofSockaddrInet6
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(&gsr.Group))
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], grp)
+-	sa = (*sysSockaddrInet6)(unsafe.Pointer(&gsr.Source))
+-	sa.Len = sysSizeofSockaddrInet6
++	sa = (*sockaddrInet6)(unsafe.Pointer(&gsr.Source))
++	sa.Len = sizeofSockaddrInet6
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], src)
+ }
+diff -uNr go-net.old/ipv6/sys_linux.go go-net/ipv6/sys_linux.go
+--- go-net.old/ipv6/sys_linux.go	2018-05-31 12:15:35.527672807 +0200
++++ go-net/ipv6/sys_linux.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -9,66 +9,66 @@
+ 	"syscall"
+ 	"unsafe"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+-type sysSockoptLen int32
+-
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{
+ 		ctlTrafficClass: {sysIPV6_TCLASS, 4, marshalTrafficClass, parseTrafficClass},
+ 		ctlHopLimit:     {sysIPV6_HOPLIMIT, 4, marshalHopLimit, parseHopLimit},
+-		ctlPacketInfo:   {sysIPV6_PKTINFO, sysSizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
+-		ctlPathMTU:      {sysIPV6_PATHMTU, sysSizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
++		ctlPacketInfo:   {sysIPV6_PKTINFO, sizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
++		ctlPathMTU:      {sysIPV6_PATHMTU, sizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
+ 	}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoTrafficClass:        {iana.ProtocolIPv6, sysIPV6_TCLASS, ssoTypeInt},
+-		ssoHopLimit:            {iana.ProtocolIPv6, sysIPV6_UNICAST_HOPS, ssoTypeInt},
+-		ssoMulticastInterface:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastHopLimit:   {iana.ProtocolIPv6, sysIPV6_MULTICAST_HOPS, ssoTypeInt},
+-		ssoMulticastLoopback:   {iana.ProtocolIPv6, sysIPV6_MULTICAST_LOOP, ssoTypeInt},
+-		ssoReceiveTrafficClass: {iana.ProtocolIPv6, sysIPV6_RECVTCLASS, ssoTypeInt},
+-		ssoReceiveHopLimit:     {iana.ProtocolIPv6, sysIPV6_RECVHOPLIMIT, ssoTypeInt},
+-		ssoReceivePacketInfo:   {iana.ProtocolIPv6, sysIPV6_RECVPKTINFO, ssoTypeInt},
+-		ssoReceivePathMTU:      {iana.ProtocolIPv6, sysIPV6_RECVPATHMTU, ssoTypeInt},
+-		ssoPathMTU:             {iana.ProtocolIPv6, sysIPV6_PATHMTU, ssoTypeMTUInfo},
+-		ssoChecksum:            {iana.ProtocolReserved, sysIPV6_CHECKSUM, ssoTypeInt},
+-		ssoICMPFilter:          {iana.ProtocolIPv6ICMP, sysICMPV6_FILTER, ssoTypeICMPFilter},
+-		ssoJoinGroup:           {iana.ProtocolIPv6, sysMCAST_JOIN_GROUP, ssoTypeGroupReq},
+-		ssoLeaveGroup:          {iana.ProtocolIPv6, sysMCAST_LEAVE_GROUP, ssoTypeGroupReq},
+-		ssoJoinSourceGroup:     {iana.ProtocolIPv6, sysMCAST_JOIN_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoLeaveSourceGroup:    {iana.ProtocolIPv6, sysMCAST_LEAVE_SOURCE_GROUP, ssoTypeGroupSourceReq},
+-		ssoBlockSourceGroup:    {iana.ProtocolIPv6, sysMCAST_BLOCK_SOURCE, ssoTypeGroupSourceReq},
+-		ssoUnblockSourceGroup:  {iana.ProtocolIPv6, sysMCAST_UNBLOCK_SOURCE, ssoTypeGroupSourceReq},
++	sockOpts = map[int]*sockOpt{
++		ssoTrafficClass:        {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_TCLASS, Len: 4}},
++		ssoHopLimit:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_UNICAST_HOPS, Len: 4}},
++		ssoMulticastInterface:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_IF, Len: 4}},
++		ssoMulticastHopLimit:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_HOPS, Len: 4}},
++		ssoMulticastLoopback:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTrafficClass: {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVTCLASS, Len: 4}},
++		ssoReceiveHopLimit:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVHOPLIMIT, Len: 4}},
++		ssoReceivePacketInfo:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPKTINFO, Len: 4}},
++		ssoReceivePathMTU:      {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPATHMTU, Len: 4}},
++		ssoPathMTU:             {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_PATHMTU, Len: sizeofIPv6Mtuinfo}},
++		ssoChecksum:            {Option: socket.Option{Level: iana.ProtocolReserved, Name: sysIPV6_CHECKSUM, Len: 4}},
++		ssoICMPFilter:          {Option: socket.Option{Level: iana.ProtocolIPv6ICMP, Name: sysICMPV6_FILTER, Len: sizeofICMPv6Filter}},
++		ssoJoinGroup:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoLeaveGroup:          {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoJoinSourceGroup:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoLeaveSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoBlockSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoUnblockSourceGroup:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoAttachFilter:        {Option: socket.Option{Level: sysSOL_SOCKET, Name: sysSO_ATTACH_FILTER, Len: sizeofSockFprog}},
+ 	}
+ )
+ 
+-func (sa *sysSockaddrInet6) setSockaddr(ip net.IP, i int) {
++func (sa *sockaddrInet6) setSockaddr(ip net.IP, i int) {
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], ip)
+ 	sa.Scope_id = uint32(i)
+ }
+ 
+-func (pi *sysInet6Pktinfo) setIfindex(i int) {
++func (pi *inet6Pktinfo) setIfindex(i int) {
+ 	pi.Ifindex = int32(i)
+ }
+ 
+-func (mreq *sysIPv6Mreq) setIfindex(i int) {
++func (mreq *ipv6Mreq) setIfindex(i int) {
+ 	mreq.Ifindex = int32(i)
+ }
+ 
+-func (gr *sysGroupReq) setGroup(grp net.IP) {
+-	sa := (*sysSockaddrInet6)(unsafe.Pointer(&gr.Group))
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(&gr.Group))
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], grp)
+ }
+ 
+-func (gsr *sysGroupSourceReq) setSourceGroup(grp, src net.IP) {
+-	sa := (*sysSockaddrInet6)(unsafe.Pointer(&gsr.Group))
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(&gsr.Group))
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], grp)
+-	sa = (*sysSockaddrInet6)(unsafe.Pointer(&gsr.Source))
++	sa = (*sockaddrInet6)(unsafe.Pointer(&gsr.Source))
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], src)
+ }
+diff -uNr go-net.old/ipv6/sys_solaris.go go-net/ipv6/sys_solaris.go
+--- go-net.old/ipv6/sys_solaris.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_solaris.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,74 @@
++// Copyright 2016 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++package ipv6
++
++import (
++	"net"
++	"syscall"
++	"unsafe"
++
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
++)
++
++var (
++	ctlOpts = [ctlMax]ctlOpt{
++		ctlTrafficClass: {sysIPV6_TCLASS, 4, marshalTrafficClass, parseTrafficClass},
++		ctlHopLimit:     {sysIPV6_HOPLIMIT, 4, marshalHopLimit, parseHopLimit},
++		ctlPacketInfo:   {sysIPV6_PKTINFO, sizeofInet6Pktinfo, marshalPacketInfo, parsePacketInfo},
++		ctlNextHop:      {sysIPV6_NEXTHOP, sizeofSockaddrInet6, marshalNextHop, parseNextHop},
++		ctlPathMTU:      {sysIPV6_PATHMTU, sizeofIPv6Mtuinfo, marshalPathMTU, parsePathMTU},
++	}
++
++	sockOpts = map[int]*sockOpt{
++		ssoTrafficClass:        {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_TCLASS, Len: 4}},
++		ssoHopLimit:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_UNICAST_HOPS, Len: 4}},
++		ssoMulticastInterface:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_IF, Len: 4}},
++		ssoMulticastHopLimit:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_HOPS, Len: 4}},
++		ssoMulticastLoopback:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_LOOP, Len: 4}},
++		ssoReceiveTrafficClass: {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVTCLASS, Len: 4}},
++		ssoReceiveHopLimit:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVHOPLIMIT, Len: 4}},
++		ssoReceivePacketInfo:   {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPKTINFO, Len: 4}},
++		ssoReceivePathMTU:      {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_RECVPATHMTU, Len: 4}},
++		ssoPathMTU:             {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_PATHMTU, Len: sizeofIPv6Mtuinfo}},
++		ssoChecksum:            {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_CHECKSUM, Len: 4}},
++		ssoICMPFilter:          {Option: socket.Option{Level: iana.ProtocolIPv6ICMP, Name: sysICMP6_FILTER, Len: sizeofICMPv6Filter}},
++		ssoJoinGroup:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoLeaveGroup:          {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_GROUP, Len: sizeofGroupReq}, typ: ssoTypeGroupReq},
++		ssoJoinSourceGroup:     {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_JOIN_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoLeaveSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_LEAVE_SOURCE_GROUP, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoBlockSourceGroup:    {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_BLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++		ssoUnblockSourceGroup:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysMCAST_UNBLOCK_SOURCE, Len: sizeofGroupSourceReq}, typ: ssoTypeGroupSourceReq},
++	}
++)
++
++func (sa *sockaddrInet6) setSockaddr(ip net.IP, i int) {
++	sa.Family = syscall.AF_INET6
++	copy(sa.Addr[:], ip)
++	sa.Scope_id = uint32(i)
++}
++
++func (pi *inet6Pktinfo) setIfindex(i int) {
++	pi.Ifindex = uint32(i)
++}
++
++func (mreq *ipv6Mreq) setIfindex(i int) {
++	mreq.Interface = uint32(i)
++}
++
++func (gr *groupReq) setGroup(grp net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(uintptr(unsafe.Pointer(gr)) + 4))
++	sa.Family = syscall.AF_INET6
++	copy(sa.Addr[:], grp)
++}
++
++func (gsr *groupSourceReq) setSourceGroup(grp, src net.IP) {
++	sa := (*sockaddrInet6)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 4))
++	sa.Family = syscall.AF_INET6
++	copy(sa.Addr[:], grp)
++	sa = (*sockaddrInet6)(unsafe.Pointer(uintptr(unsafe.Pointer(gsr)) + 260))
++	sa.Family = syscall.AF_INET6
++	copy(sa.Addr[:], src)
++}
+diff -uNr go-net.old/ipv6/sys_ssmreq.go go-net/ipv6/sys_ssmreq.go
+--- go-net.old/ipv6/sys_ssmreq.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_ssmreq.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,54 @@
++// Copyright 2014 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build darwin freebsd linux solaris
++
++package ipv6
++
++import (
++	"net"
++	"unsafe"
++
++	"golang.org/x/net/internal/socket"
++)
++
++var freebsd32o64 bool
++
++func (so *sockOpt) setGroupReq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	var gr groupReq
++	if ifi != nil {
++		gr.Interface = uint32(ifi.Index)
++	}
++	gr.setGroup(grp)
++	var b []byte
++	if freebsd32o64 {
++		var d [sizeofGroupReq + 4]byte
++		s := (*[sizeofGroupReq]byte)(unsafe.Pointer(&gr))
++		copy(d[:4], s[:4])
++		copy(d[8:], s[4:])
++		b = d[:]
++	} else {
++		b = (*[sizeofGroupReq]byte)(unsafe.Pointer(&gr))[:sizeofGroupReq]
++	}
++	return so.Set(c, b)
++}
++
++func (so *sockOpt) setGroupSourceReq(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	var gsr groupSourceReq
++	if ifi != nil {
++		gsr.Interface = uint32(ifi.Index)
++	}
++	gsr.setSourceGroup(grp, src)
++	var b []byte
++	if freebsd32o64 {
++		var d [sizeofGroupSourceReq + 4]byte
++		s := (*[sizeofGroupSourceReq]byte)(unsafe.Pointer(&gsr))
++		copy(d[:4], s[:4])
++		copy(d[8:], s[4:])
++		b = d[:]
++	} else {
++		b = (*[sizeofGroupSourceReq]byte)(unsafe.Pointer(&gsr))[:sizeofGroupSourceReq]
++	}
++	return so.Set(c, b)
++}
+diff -uNr go-net.old/ipv6/sys_ssmreq_stub.go go-net/ipv6/sys_ssmreq_stub.go
+--- go-net.old/ipv6/sys_ssmreq_stub.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/sys_ssmreq_stub.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,21 @@
++// Copyright 2014 The Go Authors. All rights reserved.
++// Use of this source code is governed by a BSD-style
++// license that can be found in the LICENSE file.
++
++// +build !darwin,!freebsd,!linux,!solaris
++
++package ipv6
++
++import (
++	"net"
++
++	"golang.org/x/net/internal/socket"
++)
++
++func (so *sockOpt) setGroupReq(c *socket.Conn, ifi *net.Interface, grp net.IP) error {
++	return errOpNoSupport
++}
++
++func (so *sockOpt) setGroupSourceReq(c *socket.Conn, ifi *net.Interface, grp, src net.IP) error {
++	return errOpNoSupport
++}
+diff -uNr go-net.old/ipv6/sys_stub.go go-net/ipv6/sys_stub.go
+--- go-net.old/ipv6/sys_stub.go	2018-05-31 12:15:22.243955374 +0200
++++ go-net/ipv6/sys_stub.go	2018-05-30 21:00:53.414376369 +0200
+@@ -2,14 +2,12 @@
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+-// +build nacl plan9 solaris
++// +build !darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!solaris,!windows
+ 
+ package ipv6
+ 
+-type sysSockoptLen int32
+-
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{}
+ 
+-	sockOpts = [ssoMax]sockOpt{}
++	sockOpts = map[int]*sockOpt{}
+ )
+diff -uNr go-net.old/ipv6/sys_windows.go go-net/ipv6/sys_windows.go
+--- go-net.old/ipv6/sys_windows.go	2018-05-31 12:15:35.527672807 +0200
++++ go-net/ipv6/sys_windows.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -8,7 +8,8 @@
+ 	"net"
+ 	"syscall"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/socket"
+ )
+ 
+ const (
+@@ -21,12 +22,14 @@
+ 	sysIPV6_LEAVE_GROUP    = 0xd
+ 	sysIPV6_PKTINFO        = 0x13
+ 
+-	sysSizeofSockaddrInet6 = 0x1c
++	sizeofSockaddrInet6 = 0x1c
+ 
+-	sysSizeofIPv6Mreq = 0x14
++	sizeofIPv6Mreq     = 0x14
++	sizeofIPv6Mtuinfo  = 0x20
++	sizeofICMPv6Filter = 0
+ )
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -34,30 +37,39 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type icmpv6Filter struct {
++	// TODO(mikio): implement this
++}
++
+ var (
+ 	ctlOpts = [ctlMax]ctlOpt{}
+ 
+-	sockOpts = [ssoMax]sockOpt{
+-		ssoHopLimit:           {iana.ProtocolIPv6, sysIPV6_UNICAST_HOPS, ssoTypeInt},
+-		ssoMulticastInterface: {iana.ProtocolIPv6, sysIPV6_MULTICAST_IF, ssoTypeInterface},
+-		ssoMulticastHopLimit:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_HOPS, ssoTypeInt},
+-		ssoMulticastLoopback:  {iana.ProtocolIPv6, sysIPV6_MULTICAST_LOOP, ssoTypeInt},
+-		ssoJoinGroup:          {iana.ProtocolIPv6, sysIPV6_JOIN_GROUP, ssoTypeIPMreq},
+-		ssoLeaveGroup:         {iana.ProtocolIPv6, sysIPV6_LEAVE_GROUP, ssoTypeIPMreq},
++	sockOpts = map[int]*sockOpt{
++		ssoHopLimit:           {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_UNICAST_HOPS, Len: 4}},
++		ssoMulticastInterface: {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_IF, Len: 4}},
++		ssoMulticastHopLimit:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_HOPS, Len: 4}},
++		ssoMulticastLoopback:  {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_MULTICAST_LOOP, Len: 4}},
++		ssoJoinGroup:          {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_JOIN_GROUP, Len: sizeofIPv6Mreq}, typ: ssoTypeIPMreq},
++		ssoLeaveGroup:         {Option: socket.Option{Level: iana.ProtocolIPv6, Name: sysIPV6_LEAVE_GROUP, Len: sizeofIPv6Mreq}, typ: ssoTypeIPMreq},
+ 	}
+ )
+ 
+-func (sa *sysSockaddrInet6) setSockaddr(ip net.IP, i int) {
++func (sa *sockaddrInet6) setSockaddr(ip net.IP, i int) {
+ 	sa.Family = syscall.AF_INET6
+ 	copy(sa.Addr[:], ip)
+ 	sa.Scope_id = uint32(i)
+ }
+ 
+-func (mreq *sysIPv6Mreq) setIfindex(i int) {
++func (mreq *ipv6Mreq) setIfindex(i int) {
+ 	mreq.Interface = uint32(i)
+ }
+diff -uNr go-net.old/ipv6/unicastsockopt_test.go go-net/ipv6/unicastsockopt_test.go
+--- go-net.old/ipv6/unicastsockopt_test.go	2018-05-31 12:15:35.539672552 +0200
++++ go-net/ipv6/unicastsockopt_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -9,14 +9,14 @@
+ 	"runtime"
+ 	"testing"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ func TestConnUnicastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -29,8 +29,15 @@
+ 	}
+ 	defer ln.Close()
+ 
+-	done := make(chan bool)
+-	go acceptor(t, ln, done)
++	errc := make(chan error, 1)
++	go func() {
++		c, err := ln.Accept()
++		if err != nil {
++			errc <- err
++			return
++		}
++		errc <- c.Close()
++	}()
+ 
+ 	c, err := net.Dial("tcp6", ln.Addr().String())
+ 	if err != nil {
+@@ -40,7 +47,9 @@
+ 
+ 	testUnicastSocketOptions(t, ipv6.NewConn(c))
+ 
+-	<-done
++	if err := <-errc; err != nil {
++		t.Errorf("server: %v", err)
++	}
+ }
+ 
+ var packetConnUnicastSocketOptionTests = []struct {
+@@ -52,7 +61,7 @@
+ 
+ func TestPacketConnUnicastSocketOptions(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+diff -uNr go-net.old/ipv6/unicast_test.go go-net/ipv6/unicast_test.go
+--- go-net.old/ipv6/unicast_test.go	2018-05-31 12:15:35.535672637 +0200
++++ go-net/ipv6/unicast_test.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,4 +1,4 @@
+-// Copyright 2013 The Go Authors.  All rights reserved.
++// Copyright 2013 The Go Authors. All rights reserved.
+ // Use of this source code is governed by a BSD-style
+ // license that can be found in the LICENSE file.
+ 
+@@ -12,22 +12,22 @@
+ 	"testing"
+ 	"time"
+ 
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/icmp"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/iana"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/internal/nettest"
+-	"gx/ipfs/QmTEmsyNnckEq8rEfALfdhLHjrEHGoSGFDrAYReuetn7MC/go-net/ipv6"
++	"golang.org/x/net/icmp"
++	"golang.org/x/net/internal/iana"
++	"golang.org/x/net/internal/nettest"
++	"golang.org/x/net/ipv6"
+ )
+ 
+ func TestPacketConnReadWriteUnicastUDP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+ 		t.Skip("ipv6 is not supported")
+ 	}
+ 
+-	c, err := net.ListenPacket("udp6", "[::1]:0")
++	c, err := nettest.NewLocalPacketListener("udp6")
+ 	if err != nil {
+ 		t.Fatal(err)
+ 	}
+@@ -35,11 +35,7 @@
+ 	p := ipv6.NewPacketConn(c)
+ 	defer p.Close()
+ 
+-	dst, err := net.ResolveUDPAddr("udp6", c.LocalAddr().String())
+-	if err != nil {
+-		t.Fatal(err)
+-	}
+-
++	dst := c.LocalAddr()
+ 	cm := ipv6.ControlMessage{
+ 		TrafficClass: iana.DiffServAF11 | iana.CongestionExperienced,
+ 		Src:          net.IPv6loopback,
+@@ -54,7 +50,8 @@
+ 	for i, toggle := range []bool{true, false, true} {
+ 		if err := p.SetControlMessage(cf, toggle); err != nil {
+ 			if nettest.ProtocolNotSupported(err) {
+-				t.Skipf("not supported on %s", runtime.GOOS)
++				t.Logf("not supported on %s", runtime.GOOS)
++				continue
+ 			}
+ 			t.Fatal(err)
+ 		}
+@@ -81,7 +78,7 @@
+ 
+ func TestPacketConnReadWriteUnicastICMP(t *testing.T) {
+ 	switch runtime.GOOS {
+-	case "nacl", "plan9", "solaris", "windows":
++	case "nacl", "plan9", "windows":
+ 		t.Skipf("not supported on %s", runtime.GOOS)
+ 	}
+ 	if !supportsIPv6 {
+@@ -127,7 +124,11 @@
+ 		if toggle {
+ 			psh = nil
+ 			if err := p.SetChecksum(true, 2); err != nil {
+-				t.Fatal(err)
++				// Solaris never allows to modify
++				// ICMP properties.
++				if runtime.GOOS != "solaris" {
++					t.Fatal(err)
++				}
+ 			}
+ 		} else {
+ 			psh = pshicmp
+@@ -147,7 +148,8 @@
+ 		}
+ 		if err := p.SetControlMessage(cf, toggle); err != nil {
+ 			if nettest.ProtocolNotSupported(err) {
+-				t.Skipf("not supported on %s", runtime.GOOS)
++				t.Logf("not supported on %s", runtime.GOOS)
++				continue
+ 			}
+ 			t.Fatal(err)
+ 		}
+diff -uNr go-net.old/ipv6/zsys_darwin.go go-net/ipv6/zsys_darwin.go
+--- go-net.old/ipv6/zsys_darwin.go	2018-05-31 12:15:22.247955289 +0200
++++ go-net/ipv6/zsys_darwin.go	2018-05-30 21:00:53.414376369 +0200
+@@ -71,19 +71,19 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6   = 0x1c
+-	sysSizeofInet6Pktinfo    = 0x14
+-	sysSizeofIPv6Mtuinfo     = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet6   = 0x1c
++	sizeofInet6Pktinfo    = 0x14
++	sizeofIPv6Mtuinfo     = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -91,7 +91,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -100,31 +100,31 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [128]byte
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [128]byte
+ 	Pad_cgo_1 [128]byte
+diff -uNr go-net.old/ipv6/zsys_dragonfly.go go-net/ipv6/zsys_dragonfly.go
+--- go-net.old/ipv6/zsys_dragonfly.go	2018-05-31 12:15:22.247955289 +0200
++++ go-net/ipv6/zsys_dragonfly.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_dragonfly.go
+ 
+-// +build dragonfly
+-
+ package ipv6
+ 
+ const (
+@@ -52,16 +50,16 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrInet6 = 0x1c
+-	sysSizeofInet6Pktinfo  = 0x14
+-	sysSizeofIPv6Mtuinfo   = 0x20
++	sizeofSockaddrInet6 = 0x1c
++	sizeofInet6Pktinfo  = 0x14
++	sizeofIPv6Mtuinfo   = 0x20
+ 
+-	sysSizeofIPv6Mreq = 0x14
++	sizeofIPv6Mreq = 0x14
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -70,21 +68,21 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+diff -uNr go-net.old/ipv6/zsys_freebsd_386.go go-net/ipv6/zsys_freebsd_386.go
+--- go-net.old/ipv6/zsys_freebsd_386.go	2018-05-31 12:15:22.247955289 +0200
++++ go-net/ipv6/zsys_freebsd_386.go	2018-05-30 21:00:53.414376369 +0200
+@@ -62,19 +62,19 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6   = 0x1c
+-	sysSizeofInet6Pktinfo    = 0x14
+-	sysSizeofIPv6Mtuinfo     = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet6   = 0x1c
++	sizeofInet6Pktinfo    = 0x14
++	sizeofIPv6Mtuinfo     = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -82,7 +82,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -91,32 +91,32 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+-	Group     sysSockaddrStorage
++	Group     sockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+-	Group     sysSockaddrStorage
+-	Source    sysSockaddrStorage
++	Group     sockaddrStorage
++	Source    sockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+diff -uNr go-net.old/ipv6/zsys_freebsd_amd64.go go-net/ipv6/zsys_freebsd_amd64.go
+--- go-net.old/ipv6/zsys_freebsd_amd64.go	2018-05-31 12:15:22.247955289 +0200
++++ go-net/ipv6/zsys_freebsd_amd64.go	2018-05-30 21:00:53.414376369 +0200
+@@ -62,19 +62,19 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6   = 0x1c
+-	sysSizeofInet6Pktinfo    = 0x14
+-	sysSizeofIPv6Mtuinfo     = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet6   = 0x1c
++	sizeofInet6Pktinfo    = 0x14
++	sizeofIPv6Mtuinfo     = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -82,7 +82,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -91,34 +91,34 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
++	Group     sockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
+-	Source    sysSockaddrStorage
++	Group     sockaddrStorage
++	Source    sockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+diff -uNr go-net.old/ipv6/zsys_freebsd_arm.go go-net/ipv6/zsys_freebsd_arm.go
+--- go-net.old/ipv6/zsys_freebsd_arm.go	2018-05-31 12:15:22.247955289 +0200
++++ go-net/ipv6/zsys_freebsd_arm.go	2018-05-30 21:00:53.414376369 +0200
+@@ -62,19 +62,19 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6   = 0x1c
+-	sysSizeofInet6Pktinfo    = 0x14
+-	sysSizeofIPv6Mtuinfo     = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sizeofSockaddrStorage = 0x80
++	sizeofSockaddrInet6   = 0x1c
++	sizeofInet6Pktinfo    = 0x14
++	sizeofIPv6Mtuinfo     = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrStorage struct {
++type sockaddrStorage struct {
+ 	Len         uint8
+ 	Family      uint8
+ 	X__ss_pad1  [6]int8
+@@ -82,7 +82,7 @@
+ 	X__ss_pad2  [112]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -91,34 +91,34 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
++	Group     sockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysSockaddrStorage
+-	Source    sysSockaddrStorage
++	Group     sockaddrStorage
++	Source    sockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+diff -uNr go-net.old/ipv6/zsys_linux_386.go go-net/ipv6/zsys_linux_386.go
+--- go-net.old/ipv6/zsys_linux_386.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_linux_386.go	2018-05-30 21:00:53.414376369 +0200
+@@ -84,25 +84,30 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
+ 	sysICMPV6_FILTER_PASSONLY    = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6         = 0x1c
+-	sysSizeofInet6Pktinfo          = 0x14
+-	sysSizeofIPv6Mtuinfo           = 0x20
+-	sysSizeofIPv6FlowlabelReq      = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x8
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -110,17 +115,17 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex int32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6FlowlabelReq struct {
++type ipv6FlowlabelReq struct {
+ 	Dst        [16]byte /* in6_addr */
+ 	Label      uint32
+ 	Action     uint8
+@@ -131,22 +136,35 @@
+ 	X__flr_pad uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Data [8]uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_amd64.go go-net/ipv6/zsys_linux_amd64.go
+--- go-net.old/ipv6/zsys_linux_amd64.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_linux_amd64.go	2018-05-30 21:00:53.414376369 +0200
+@@ -84,25 +84,30 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
+ 	sysICMPV6_FILTER_PASSONLY    = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6         = 0x1c
+-	sysSizeofInet6Pktinfo          = 0x14
+-	sysSizeofIPv6Mtuinfo           = 0x20
+-	sysSizeofIPv6FlowlabelReq      = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -110,17 +115,17 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex int32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6FlowlabelReq struct {
++type ipv6FlowlabelReq struct {
+ 	Dst        [16]byte /* in6_addr */
+ 	Label      uint32
+ 	Action     uint8
+@@ -131,24 +136,37 @@
+ 	X__flr_pad uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Data [8]uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_arm64.go go-net/ipv6/zsys_linux_arm64.go
+--- go-net.old/ipv6/zsys_linux_arm64.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_linux_arm64.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_linux.go
+ 
+-// +build linux,arm64
+-
+ package ipv6
+ 
+ const (
+@@ -86,25 +84,30 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
+ 	sysICMPV6_FILTER_PASSONLY    = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6         = 0x1c
+-	sysSizeofInet6Pktinfo          = 0x14
+-	sysSizeofIPv6Mtuinfo           = 0x20
+-	sysSizeofIPv6FlowlabelReq      = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -112,17 +115,17 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex int32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6FlowlabelReq struct {
++type ipv6FlowlabelReq struct {
+ 	Dst        [16]byte /* in6_addr */
+ 	Label      uint32
+ 	Action     uint8
+@@ -133,24 +136,37 @@
+ 	X__flr_pad uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Data [8]uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_arm.go go-net/ipv6/zsys_linux_arm.go
+--- go-net.old/ipv6/zsys_linux_arm.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_linux_arm.go	2018-05-30 21:00:53.414376369 +0200
+@@ -84,25 +84,30 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
+ 	sysICMPV6_FILTER_PASSONLY    = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6         = 0x1c
+-	sysSizeofInet6Pktinfo          = 0x14
+-	sysSizeofIPv6Mtuinfo           = 0x20
+-	sysSizeofIPv6FlowlabelReq      = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x84
+-	sysSizeofGroupSourceReq = 0x104
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x8
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -110,17 +115,17 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex int32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6FlowlabelReq struct {
++type ipv6FlowlabelReq struct {
+ 	Dst        [16]byte /* in6_addr */
+ 	Label      uint32
+ 	Action     uint8
+@@ -131,22 +136,35 @@
+ 	X__flr_pad uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Data [8]uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_mips64.go go-net/ipv6/zsys_linux_mips64.go
+--- go-net.old/ipv6/zsys_linux_mips64.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/zsys_linux_mips64.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,172 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv6
++
++const (
++	sysIPV6_ADDRFORM       = 0x1
++	sysIPV6_2292PKTINFO    = 0x2
++	sysIPV6_2292HOPOPTS    = 0x3
++	sysIPV6_2292DSTOPTS    = 0x4
++	sysIPV6_2292RTHDR      = 0x5
++	sysIPV6_2292PKTOPTIONS = 0x6
++	sysIPV6_CHECKSUM       = 0x7
++	sysIPV6_2292HOPLIMIT   = 0x8
++	sysIPV6_NEXTHOP        = 0x9
++	sysIPV6_FLOWINFO       = 0xb
++
++	sysIPV6_UNICAST_HOPS        = 0x10
++	sysIPV6_MULTICAST_IF        = 0x11
++	sysIPV6_MULTICAST_HOPS      = 0x12
++	sysIPV6_MULTICAST_LOOP      = 0x13
++	sysIPV6_ADD_MEMBERSHIP      = 0x14
++	sysIPV6_DROP_MEMBERSHIP     = 0x15
++	sysMCAST_JOIN_GROUP         = 0x2a
++	sysMCAST_LEAVE_GROUP        = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2f
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_MSFILTER           = 0x30
++	sysIPV6_ROUTER_ALERT        = 0x16
++	sysIPV6_MTU_DISCOVER        = 0x17
++	sysIPV6_MTU                 = 0x18
++	sysIPV6_RECVERR             = 0x19
++	sysIPV6_V6ONLY              = 0x1a
++	sysIPV6_JOIN_ANYCAST        = 0x1b
++	sysIPV6_LEAVE_ANYCAST       = 0x1c
++
++	sysIPV6_FLOWLABEL_MGR = 0x20
++	sysIPV6_FLOWINFO_SEND = 0x21
++
++	sysIPV6_IPSEC_POLICY = 0x22
++	sysIPV6_XFRM_POLICY  = 0x23
++
++	sysIPV6_RECVPKTINFO  = 0x31
++	sysIPV6_PKTINFO      = 0x32
++	sysIPV6_RECVHOPLIMIT = 0x33
++	sysIPV6_HOPLIMIT     = 0x34
++	sysIPV6_RECVHOPOPTS  = 0x35
++	sysIPV6_HOPOPTS      = 0x36
++	sysIPV6_RTHDRDSTOPTS = 0x37
++	sysIPV6_RECVRTHDR    = 0x38
++	sysIPV6_RTHDR        = 0x39
++	sysIPV6_RECVDSTOPTS  = 0x3a
++	sysIPV6_DSTOPTS      = 0x3b
++	sysIPV6_RECVPATHMTU  = 0x3c
++	sysIPV6_PATHMTU      = 0x3d
++	sysIPV6_DONTFRAG     = 0x3e
++
++	sysIPV6_RECVTCLASS = 0x42
++	sysIPV6_TCLASS     = 0x43
++
++	sysIPV6_ADDR_PREFERENCES = 0x48
++
++	sysIPV6_PREFER_SRC_TMP            = 0x1
++	sysIPV6_PREFER_SRC_PUBLIC         = 0x2
++	sysIPV6_PREFER_SRC_PUBTMP_DEFAULT = 0x100
++	sysIPV6_PREFER_SRC_COA            = 0x4
++	sysIPV6_PREFER_SRC_HOME           = 0x400
++	sysIPV6_PREFER_SRC_CGA            = 0x8
++	sysIPV6_PREFER_SRC_NONCGA         = 0x800
++
++	sysIPV6_MINHOPCOUNT = 0x49
++
++	sysIPV6_ORIGDSTADDR     = 0x4a
++	sysIPV6_RECVORIGDSTADDR = 0x4a
++	sysIPV6_TRANSPARENT     = 0x4b
++	sysIPV6_UNICAST_IF      = 0x4c
++
++	sysICMPV6_FILTER = 0x1
++
++	sysICMPV6_FILTER_BLOCK       = 0x1
++	sysICMPV6_FILTER_PASS        = 0x2
++	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
++	sysICMPV6_FILTER_PASSONLY    = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet6 struct {
++	Family   uint16
++	Port     uint16
++	Flowinfo uint32
++	Addr     [16]byte /* in6_addr */
++	Scope_id uint32
++}
++
++type inet6Pktinfo struct {
++	Addr    [16]byte /* in6_addr */
++	Ifindex int32
++}
++
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type ipv6FlowlabelReq struct {
++	Dst        [16]byte /* in6_addr */
++	Label      uint32
++	Action     uint8
++	Share      uint8
++	Flags      uint16
++	Expires    uint16
++	Linger     uint16
++	X__flr_pad uint32
++}
++
++type ipv6Mreq struct {
++	Multiaddr [16]byte /* in6_addr */
++	Ifindex   int32
++}
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpv6Filter struct {
++	Data [8]uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_mips64le.go go-net/ipv6/zsys_linux_mips64le.go
+--- go-net.old/ipv6/zsys_linux_mips64le.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/zsys_linux_mips64le.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,172 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv6
++
++const (
++	sysIPV6_ADDRFORM       = 0x1
++	sysIPV6_2292PKTINFO    = 0x2
++	sysIPV6_2292HOPOPTS    = 0x3
++	sysIPV6_2292DSTOPTS    = 0x4
++	sysIPV6_2292RTHDR      = 0x5
++	sysIPV6_2292PKTOPTIONS = 0x6
++	sysIPV6_CHECKSUM       = 0x7
++	sysIPV6_2292HOPLIMIT   = 0x8
++	sysIPV6_NEXTHOP        = 0x9
++	sysIPV6_FLOWINFO       = 0xb
++
++	sysIPV6_UNICAST_HOPS        = 0x10
++	sysIPV6_MULTICAST_IF        = 0x11
++	sysIPV6_MULTICAST_HOPS      = 0x12
++	sysIPV6_MULTICAST_LOOP      = 0x13
++	sysIPV6_ADD_MEMBERSHIP      = 0x14
++	sysIPV6_DROP_MEMBERSHIP     = 0x15
++	sysMCAST_JOIN_GROUP         = 0x2a
++	sysMCAST_LEAVE_GROUP        = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2f
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_MSFILTER           = 0x30
++	sysIPV6_ROUTER_ALERT        = 0x16
++	sysIPV6_MTU_DISCOVER        = 0x17
++	sysIPV6_MTU                 = 0x18
++	sysIPV6_RECVERR             = 0x19
++	sysIPV6_V6ONLY              = 0x1a
++	sysIPV6_JOIN_ANYCAST        = 0x1b
++	sysIPV6_LEAVE_ANYCAST       = 0x1c
++
++	sysIPV6_FLOWLABEL_MGR = 0x20
++	sysIPV6_FLOWINFO_SEND = 0x21
++
++	sysIPV6_IPSEC_POLICY = 0x22
++	sysIPV6_XFRM_POLICY  = 0x23
++
++	sysIPV6_RECVPKTINFO  = 0x31
++	sysIPV6_PKTINFO      = 0x32
++	sysIPV6_RECVHOPLIMIT = 0x33
++	sysIPV6_HOPLIMIT     = 0x34
++	sysIPV6_RECVHOPOPTS  = 0x35
++	sysIPV6_HOPOPTS      = 0x36
++	sysIPV6_RTHDRDSTOPTS = 0x37
++	sysIPV6_RECVRTHDR    = 0x38
++	sysIPV6_RTHDR        = 0x39
++	sysIPV6_RECVDSTOPTS  = 0x3a
++	sysIPV6_DSTOPTS      = 0x3b
++	sysIPV6_RECVPATHMTU  = 0x3c
++	sysIPV6_PATHMTU      = 0x3d
++	sysIPV6_DONTFRAG     = 0x3e
++
++	sysIPV6_RECVTCLASS = 0x42
++	sysIPV6_TCLASS     = 0x43
++
++	sysIPV6_ADDR_PREFERENCES = 0x48
++
++	sysIPV6_PREFER_SRC_TMP            = 0x1
++	sysIPV6_PREFER_SRC_PUBLIC         = 0x2
++	sysIPV6_PREFER_SRC_PUBTMP_DEFAULT = 0x100
++	sysIPV6_PREFER_SRC_COA            = 0x4
++	sysIPV6_PREFER_SRC_HOME           = 0x400
++	sysIPV6_PREFER_SRC_CGA            = 0x8
++	sysIPV6_PREFER_SRC_NONCGA         = 0x800
++
++	sysIPV6_MINHOPCOUNT = 0x49
++
++	sysIPV6_ORIGDSTADDR     = 0x4a
++	sysIPV6_RECVORIGDSTADDR = 0x4a
++	sysIPV6_TRANSPARENT     = 0x4b
++	sysIPV6_UNICAST_IF      = 0x4c
++
++	sysICMPV6_FILTER = 0x1
++
++	sysICMPV6_FILTER_BLOCK       = 0x1
++	sysICMPV6_FILTER_PASS        = 0x2
++	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
++	sysICMPV6_FILTER_PASSONLY    = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet6 struct {
++	Family   uint16
++	Port     uint16
++	Flowinfo uint32
++	Addr     [16]byte /* in6_addr */
++	Scope_id uint32
++}
++
++type inet6Pktinfo struct {
++	Addr    [16]byte /* in6_addr */
++	Ifindex int32
++}
++
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type ipv6FlowlabelReq struct {
++	Dst        [16]byte /* in6_addr */
++	Label      uint32
++	Action     uint8
++	Share      uint8
++	Flags      uint16
++	Expires    uint16
++	Linger     uint16
++	X__flr_pad uint32
++}
++
++type ipv6Mreq struct {
++	Multiaddr [16]byte /* in6_addr */
++	Ifindex   int32
++}
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpv6Filter struct {
++	Data [8]uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_mips.go go-net/ipv6/zsys_linux_mips.go
+--- go-net.old/ipv6/zsys_linux_mips.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/zsys_linux_mips.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,170 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv6
++
++const (
++	sysIPV6_ADDRFORM       = 0x1
++	sysIPV6_2292PKTINFO    = 0x2
++	sysIPV6_2292HOPOPTS    = 0x3
++	sysIPV6_2292DSTOPTS    = 0x4
++	sysIPV6_2292RTHDR      = 0x5
++	sysIPV6_2292PKTOPTIONS = 0x6
++	sysIPV6_CHECKSUM       = 0x7
++	sysIPV6_2292HOPLIMIT   = 0x8
++	sysIPV6_NEXTHOP        = 0x9
++	sysIPV6_FLOWINFO       = 0xb
++
++	sysIPV6_UNICAST_HOPS        = 0x10
++	sysIPV6_MULTICAST_IF        = 0x11
++	sysIPV6_MULTICAST_HOPS      = 0x12
++	sysIPV6_MULTICAST_LOOP      = 0x13
++	sysIPV6_ADD_MEMBERSHIP      = 0x14
++	sysIPV6_DROP_MEMBERSHIP     = 0x15
++	sysMCAST_JOIN_GROUP         = 0x2a
++	sysMCAST_LEAVE_GROUP        = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2f
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_MSFILTER           = 0x30
++	sysIPV6_ROUTER_ALERT        = 0x16
++	sysIPV6_MTU_DISCOVER        = 0x17
++	sysIPV6_MTU                 = 0x18
++	sysIPV6_RECVERR             = 0x19
++	sysIPV6_V6ONLY              = 0x1a
++	sysIPV6_JOIN_ANYCAST        = 0x1b
++	sysIPV6_LEAVE_ANYCAST       = 0x1c
++
++	sysIPV6_FLOWLABEL_MGR = 0x20
++	sysIPV6_FLOWINFO_SEND = 0x21
++
++	sysIPV6_IPSEC_POLICY = 0x22
++	sysIPV6_XFRM_POLICY  = 0x23
++
++	sysIPV6_RECVPKTINFO  = 0x31
++	sysIPV6_PKTINFO      = 0x32
++	sysIPV6_RECVHOPLIMIT = 0x33
++	sysIPV6_HOPLIMIT     = 0x34
++	sysIPV6_RECVHOPOPTS  = 0x35
++	sysIPV6_HOPOPTS      = 0x36
++	sysIPV6_RTHDRDSTOPTS = 0x37
++	sysIPV6_RECVRTHDR    = 0x38
++	sysIPV6_RTHDR        = 0x39
++	sysIPV6_RECVDSTOPTS  = 0x3a
++	sysIPV6_DSTOPTS      = 0x3b
++	sysIPV6_RECVPATHMTU  = 0x3c
++	sysIPV6_PATHMTU      = 0x3d
++	sysIPV6_DONTFRAG     = 0x3e
++
++	sysIPV6_RECVTCLASS = 0x42
++	sysIPV6_TCLASS     = 0x43
++
++	sysIPV6_ADDR_PREFERENCES = 0x48
++
++	sysIPV6_PREFER_SRC_TMP            = 0x1
++	sysIPV6_PREFER_SRC_PUBLIC         = 0x2
++	sysIPV6_PREFER_SRC_PUBTMP_DEFAULT = 0x100
++	sysIPV6_PREFER_SRC_COA            = 0x4
++	sysIPV6_PREFER_SRC_HOME           = 0x400
++	sysIPV6_PREFER_SRC_CGA            = 0x8
++	sysIPV6_PREFER_SRC_NONCGA         = 0x800
++
++	sysIPV6_MINHOPCOUNT = 0x49
++
++	sysIPV6_ORIGDSTADDR     = 0x4a
++	sysIPV6_RECVORIGDSTADDR = 0x4a
++	sysIPV6_TRANSPARENT     = 0x4b
++	sysIPV6_UNICAST_IF      = 0x4c
++
++	sysICMPV6_FILTER = 0x1
++
++	sysICMPV6_FILTER_BLOCK       = 0x1
++	sysICMPV6_FILTER_PASS        = 0x2
++	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
++	sysICMPV6_FILTER_PASSONLY    = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x8
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet6 struct {
++	Family   uint16
++	Port     uint16
++	Flowinfo uint32
++	Addr     [16]byte /* in6_addr */
++	Scope_id uint32
++}
++
++type inet6Pktinfo struct {
++	Addr    [16]byte /* in6_addr */
++	Ifindex int32
++}
++
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type ipv6FlowlabelReq struct {
++	Dst        [16]byte /* in6_addr */
++	Label      uint32
++	Action     uint8
++	Share      uint8
++	Flags      uint16
++	Expires    uint16
++	Linger     uint16
++	X__flr_pad uint32
++}
++
++type ipv6Mreq struct {
++	Multiaddr [16]byte /* in6_addr */
++	Ifindex   int32
++}
++
++type groupReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpv6Filter struct {
++	Data [8]uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_mipsle.go go-net/ipv6/zsys_linux_mipsle.go
+--- go-net.old/ipv6/zsys_linux_mipsle.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/zsys_linux_mipsle.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,170 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv6
++
++const (
++	sysIPV6_ADDRFORM       = 0x1
++	sysIPV6_2292PKTINFO    = 0x2
++	sysIPV6_2292HOPOPTS    = 0x3
++	sysIPV6_2292DSTOPTS    = 0x4
++	sysIPV6_2292RTHDR      = 0x5
++	sysIPV6_2292PKTOPTIONS = 0x6
++	sysIPV6_CHECKSUM       = 0x7
++	sysIPV6_2292HOPLIMIT   = 0x8
++	sysIPV6_NEXTHOP        = 0x9
++	sysIPV6_FLOWINFO       = 0xb
++
++	sysIPV6_UNICAST_HOPS        = 0x10
++	sysIPV6_MULTICAST_IF        = 0x11
++	sysIPV6_MULTICAST_HOPS      = 0x12
++	sysIPV6_MULTICAST_LOOP      = 0x13
++	sysIPV6_ADD_MEMBERSHIP      = 0x14
++	sysIPV6_DROP_MEMBERSHIP     = 0x15
++	sysMCAST_JOIN_GROUP         = 0x2a
++	sysMCAST_LEAVE_GROUP        = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2f
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_MSFILTER           = 0x30
++	sysIPV6_ROUTER_ALERT        = 0x16
++	sysIPV6_MTU_DISCOVER        = 0x17
++	sysIPV6_MTU                 = 0x18
++	sysIPV6_RECVERR             = 0x19
++	sysIPV6_V6ONLY              = 0x1a
++	sysIPV6_JOIN_ANYCAST        = 0x1b
++	sysIPV6_LEAVE_ANYCAST       = 0x1c
++
++	sysIPV6_FLOWLABEL_MGR = 0x20
++	sysIPV6_FLOWINFO_SEND = 0x21
++
++	sysIPV6_IPSEC_POLICY = 0x22
++	sysIPV6_XFRM_POLICY  = 0x23
++
++	sysIPV6_RECVPKTINFO  = 0x31
++	sysIPV6_PKTINFO      = 0x32
++	sysIPV6_RECVHOPLIMIT = 0x33
++	sysIPV6_HOPLIMIT     = 0x34
++	sysIPV6_RECVHOPOPTS  = 0x35
++	sysIPV6_HOPOPTS      = 0x36
++	sysIPV6_RTHDRDSTOPTS = 0x37
++	sysIPV6_RECVRTHDR    = 0x38
++	sysIPV6_RTHDR        = 0x39
++	sysIPV6_RECVDSTOPTS  = 0x3a
++	sysIPV6_DSTOPTS      = 0x3b
++	sysIPV6_RECVPATHMTU  = 0x3c
++	sysIPV6_PATHMTU      = 0x3d
++	sysIPV6_DONTFRAG     = 0x3e
++
++	sysIPV6_RECVTCLASS = 0x42
++	sysIPV6_TCLASS     = 0x43
++
++	sysIPV6_ADDR_PREFERENCES = 0x48
++
++	sysIPV6_PREFER_SRC_TMP            = 0x1
++	sysIPV6_PREFER_SRC_PUBLIC         = 0x2
++	sysIPV6_PREFER_SRC_PUBTMP_DEFAULT = 0x100
++	sysIPV6_PREFER_SRC_COA            = 0x4
++	sysIPV6_PREFER_SRC_HOME           = 0x400
++	sysIPV6_PREFER_SRC_CGA            = 0x8
++	sysIPV6_PREFER_SRC_NONCGA         = 0x800
++
++	sysIPV6_MINHOPCOUNT = 0x49
++
++	sysIPV6_ORIGDSTADDR     = 0x4a
++	sysIPV6_RECVORIGDSTADDR = 0x4a
++	sysIPV6_TRANSPARENT     = 0x4b
++	sysIPV6_UNICAST_IF      = 0x4c
++
++	sysICMPV6_FILTER = 0x1
++
++	sysICMPV6_FILTER_BLOCK       = 0x1
++	sysICMPV6_FILTER_PASS        = 0x2
++	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
++	sysICMPV6_FILTER_PASSONLY    = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x8
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet6 struct {
++	Family   uint16
++	Port     uint16
++	Flowinfo uint32
++	Addr     [16]byte /* in6_addr */
++	Scope_id uint32
++}
++
++type inet6Pktinfo struct {
++	Addr    [16]byte /* in6_addr */
++	Ifindex int32
++}
++
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type ipv6FlowlabelReq struct {
++	Dst        [16]byte /* in6_addr */
++	Label      uint32
++	Action     uint8
++	Share      uint8
++	Flags      uint16
++	Expires    uint16
++	Linger     uint16
++	X__flr_pad uint32
++}
++
++type ipv6Mreq struct {
++	Multiaddr [16]byte /* in6_addr */
++	Ifindex   int32
++}
++
++type groupReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpv6Filter struct {
++	Data [8]uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_ppc64.go go-net/ipv6/zsys_linux_ppc64.go
+--- go-net.old/ipv6/zsys_linux_ppc64.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_linux_ppc64.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_linux.go
+ 
+-// +build linux,ppc64
+-
+ package ipv6
+ 
+ const (
+@@ -86,25 +84,30 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
+ 	sysICMPV6_FILTER_PASSONLY    = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6         = 0x1c
+-	sysSizeofInet6Pktinfo          = 0x14
+-	sysSizeofIPv6Mtuinfo           = 0x20
+-	sysSizeofIPv6FlowlabelReq      = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -112,17 +115,17 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex int32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6FlowlabelReq struct {
++type ipv6FlowlabelReq struct {
+ 	Dst        [16]byte /* in6_addr */
+ 	Label      uint32
+ 	Action     uint8
+@@ -133,24 +136,37 @@
+ 	X__flr_pad uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Data [8]uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_ppc64le.go go-net/ipv6/zsys_linux_ppc64le.go
+--- go-net.old/ipv6/zsys_linux_ppc64le.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_linux_ppc64le.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_linux.go
+ 
+-// +build linux,ppc64le
+-
+ package ipv6
+ 
+ const (
+@@ -86,25 +84,30 @@
+ 	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
+ 	sysICMPV6_FILTER_PASSONLY    = 0x4
+ 
+-	sysSizeofKernelSockaddrStorage = 0x80
+-	sysSizeofSockaddrInet6         = 0x1c
+-	sysSizeofInet6Pktinfo          = 0x14
+-	sysSizeofIPv6Mtuinfo           = 0x20
+-	sysSizeofIPv6FlowlabelReq      = 0x20
+-
+-	sysSizeofIPv6Mreq       = 0x14
+-	sysSizeofGroupReq       = 0x88
+-	sysSizeofGroupSourceReq = 0x108
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
+ )
+ 
+-type sysKernelSockaddrStorage struct {
++type kernelSockaddrStorage struct {
+ 	Family  uint16
+ 	X__data [126]int8
+ }
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Family   uint16
+ 	Port     uint16
+ 	Flowinfo uint32
+@@ -112,17 +115,17 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex int32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6FlowlabelReq struct {
++type ipv6FlowlabelReq struct {
+ 	Dst        [16]byte /* in6_addr */
+ 	Label      uint32
+ 	Action     uint8
+@@ -133,24 +136,37 @@
+ 	X__flr_pad uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Ifindex   int32
+ }
+ 
+-type sysGroupReq struct {
++type groupReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
+ }
+ 
+-type sysGroupSourceReq struct {
++type groupSourceReq struct {
+ 	Interface uint32
+ 	Pad_cgo_0 [4]byte
+-	Group     sysKernelSockaddrStorage
+-	Source    sysKernelSockaddrStorage
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Data [8]uint32
+ }
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_ppc.go go-net/ipv6/zsys_linux_ppc.go
+--- go-net.old/ipv6/zsys_linux_ppc.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/zsys_linux_ppc.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,170 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv6
++
++const (
++	sysIPV6_ADDRFORM       = 0x1
++	sysIPV6_2292PKTINFO    = 0x2
++	sysIPV6_2292HOPOPTS    = 0x3
++	sysIPV6_2292DSTOPTS    = 0x4
++	sysIPV6_2292RTHDR      = 0x5
++	sysIPV6_2292PKTOPTIONS = 0x6
++	sysIPV6_CHECKSUM       = 0x7
++	sysIPV6_2292HOPLIMIT   = 0x8
++	sysIPV6_NEXTHOP        = 0x9
++	sysIPV6_FLOWINFO       = 0xb
++
++	sysIPV6_UNICAST_HOPS        = 0x10
++	sysIPV6_MULTICAST_IF        = 0x11
++	sysIPV6_MULTICAST_HOPS      = 0x12
++	sysIPV6_MULTICAST_LOOP      = 0x13
++	sysIPV6_ADD_MEMBERSHIP      = 0x14
++	sysIPV6_DROP_MEMBERSHIP     = 0x15
++	sysMCAST_JOIN_GROUP         = 0x2a
++	sysMCAST_LEAVE_GROUP        = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2f
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_MSFILTER           = 0x30
++	sysIPV6_ROUTER_ALERT        = 0x16
++	sysIPV6_MTU_DISCOVER        = 0x17
++	sysIPV6_MTU                 = 0x18
++	sysIPV6_RECVERR             = 0x19
++	sysIPV6_V6ONLY              = 0x1a
++	sysIPV6_JOIN_ANYCAST        = 0x1b
++	sysIPV6_LEAVE_ANYCAST       = 0x1c
++
++	sysIPV6_FLOWLABEL_MGR = 0x20
++	sysIPV6_FLOWINFO_SEND = 0x21
++
++	sysIPV6_IPSEC_POLICY = 0x22
++	sysIPV6_XFRM_POLICY  = 0x23
++
++	sysIPV6_RECVPKTINFO  = 0x31
++	sysIPV6_PKTINFO      = 0x32
++	sysIPV6_RECVHOPLIMIT = 0x33
++	sysIPV6_HOPLIMIT     = 0x34
++	sysIPV6_RECVHOPOPTS  = 0x35
++	sysIPV6_HOPOPTS      = 0x36
++	sysIPV6_RTHDRDSTOPTS = 0x37
++	sysIPV6_RECVRTHDR    = 0x38
++	sysIPV6_RTHDR        = 0x39
++	sysIPV6_RECVDSTOPTS  = 0x3a
++	sysIPV6_DSTOPTS      = 0x3b
++	sysIPV6_RECVPATHMTU  = 0x3c
++	sysIPV6_PATHMTU      = 0x3d
++	sysIPV6_DONTFRAG     = 0x3e
++
++	sysIPV6_RECVTCLASS = 0x42
++	sysIPV6_TCLASS     = 0x43
++
++	sysIPV6_ADDR_PREFERENCES = 0x48
++
++	sysIPV6_PREFER_SRC_TMP            = 0x1
++	sysIPV6_PREFER_SRC_PUBLIC         = 0x2
++	sysIPV6_PREFER_SRC_PUBTMP_DEFAULT = 0x100
++	sysIPV6_PREFER_SRC_COA            = 0x4
++	sysIPV6_PREFER_SRC_HOME           = 0x400
++	sysIPV6_PREFER_SRC_CGA            = 0x8
++	sysIPV6_PREFER_SRC_NONCGA         = 0x800
++
++	sysIPV6_MINHOPCOUNT = 0x49
++
++	sysIPV6_ORIGDSTADDR     = 0x4a
++	sysIPV6_RECVORIGDSTADDR = 0x4a
++	sysIPV6_TRANSPARENT     = 0x4b
++	sysIPV6_UNICAST_IF      = 0x4c
++
++	sysICMPV6_FILTER = 0x1
++
++	sysICMPV6_FILTER_BLOCK       = 0x1
++	sysICMPV6_FILTER_PASS        = 0x2
++	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
++	sysICMPV6_FILTER_PASSONLY    = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x84
++	sizeofGroupSourceReq = 0x104
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x8
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]uint8
++}
++
++type sockaddrInet6 struct {
++	Family   uint16
++	Port     uint16
++	Flowinfo uint32
++	Addr     [16]byte /* in6_addr */
++	Scope_id uint32
++}
++
++type inet6Pktinfo struct {
++	Addr    [16]byte /* in6_addr */
++	Ifindex int32
++}
++
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type ipv6FlowlabelReq struct {
++	Dst        [16]byte /* in6_addr */
++	Label      uint32
++	Action     uint8
++	Share      uint8
++	Flags      uint16
++	Expires    uint16
++	Linger     uint16
++	X__flr_pad uint32
++}
++
++type ipv6Mreq struct {
++	Multiaddr [16]byte /* in6_addr */
++	Ifindex   int32
++}
++
++type groupReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpv6Filter struct {
++	Data [8]uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [2]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_linux_s390x.go go-net/ipv6/zsys_linux_s390x.go
+--- go-net.old/ipv6/zsys_linux_s390x.go	1970-01-01 01:00:00.000000000 +0100
++++ go-net/ipv6/zsys_linux_s390x.go	2018-05-30 21:00:53.414376369 +0200
+@@ -0,0 +1,172 @@
++// Created by cgo -godefs - DO NOT EDIT
++// cgo -godefs defs_linux.go
++
++package ipv6
++
++const (
++	sysIPV6_ADDRFORM       = 0x1
++	sysIPV6_2292PKTINFO    = 0x2
++	sysIPV6_2292HOPOPTS    = 0x3
++	sysIPV6_2292DSTOPTS    = 0x4
++	sysIPV6_2292RTHDR      = 0x5
++	sysIPV6_2292PKTOPTIONS = 0x6
++	sysIPV6_CHECKSUM       = 0x7
++	sysIPV6_2292HOPLIMIT   = 0x8
++	sysIPV6_NEXTHOP        = 0x9
++	sysIPV6_FLOWINFO       = 0xb
++
++	sysIPV6_UNICAST_HOPS        = 0x10
++	sysIPV6_MULTICAST_IF        = 0x11
++	sysIPV6_MULTICAST_HOPS      = 0x12
++	sysIPV6_MULTICAST_LOOP      = 0x13
++	sysIPV6_ADD_MEMBERSHIP      = 0x14
++	sysIPV6_DROP_MEMBERSHIP     = 0x15
++	sysMCAST_JOIN_GROUP         = 0x2a
++	sysMCAST_LEAVE_GROUP        = 0x2d
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2e
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2f
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_MSFILTER           = 0x30
++	sysIPV6_ROUTER_ALERT        = 0x16
++	sysIPV6_MTU_DISCOVER        = 0x17
++	sysIPV6_MTU                 = 0x18
++	sysIPV6_RECVERR             = 0x19
++	sysIPV6_V6ONLY              = 0x1a
++	sysIPV6_JOIN_ANYCAST        = 0x1b
++	sysIPV6_LEAVE_ANYCAST       = 0x1c
++
++	sysIPV6_FLOWLABEL_MGR = 0x20
++	sysIPV6_FLOWINFO_SEND = 0x21
++
++	sysIPV6_IPSEC_POLICY = 0x22
++	sysIPV6_XFRM_POLICY  = 0x23
++
++	sysIPV6_RECVPKTINFO  = 0x31
++	sysIPV6_PKTINFO      = 0x32
++	sysIPV6_RECVHOPLIMIT = 0x33
++	sysIPV6_HOPLIMIT     = 0x34
++	sysIPV6_RECVHOPOPTS  = 0x35
++	sysIPV6_HOPOPTS      = 0x36
++	sysIPV6_RTHDRDSTOPTS = 0x37
++	sysIPV6_RECVRTHDR    = 0x38
++	sysIPV6_RTHDR        = 0x39
++	sysIPV6_RECVDSTOPTS  = 0x3a
++	sysIPV6_DSTOPTS      = 0x3b
++	sysIPV6_RECVPATHMTU  = 0x3c
++	sysIPV6_PATHMTU      = 0x3d
++	sysIPV6_DONTFRAG     = 0x3e
++
++	sysIPV6_RECVTCLASS = 0x42
++	sysIPV6_TCLASS     = 0x43
++
++	sysIPV6_ADDR_PREFERENCES = 0x48
++
++	sysIPV6_PREFER_SRC_TMP            = 0x1
++	sysIPV6_PREFER_SRC_PUBLIC         = 0x2
++	sysIPV6_PREFER_SRC_PUBTMP_DEFAULT = 0x100
++	sysIPV6_PREFER_SRC_COA            = 0x4
++	sysIPV6_PREFER_SRC_HOME           = 0x400
++	sysIPV6_PREFER_SRC_CGA            = 0x8
++	sysIPV6_PREFER_SRC_NONCGA         = 0x800
++
++	sysIPV6_MINHOPCOUNT = 0x49
++
++	sysIPV6_ORIGDSTADDR     = 0x4a
++	sysIPV6_RECVORIGDSTADDR = 0x4a
++	sysIPV6_TRANSPARENT     = 0x4b
++	sysIPV6_UNICAST_IF      = 0x4c
++
++	sysICMPV6_FILTER = 0x1
++
++	sysICMPV6_FILTER_BLOCK       = 0x1
++	sysICMPV6_FILTER_PASS        = 0x2
++	sysICMPV6_FILTER_BLOCKOTHERS = 0x3
++	sysICMPV6_FILTER_PASSONLY    = 0x4
++
++	sysSOL_SOCKET       = 0x1
++	sysSO_ATTACH_FILTER = 0x1a
++
++	sizeofKernelSockaddrStorage = 0x80
++	sizeofSockaddrInet6         = 0x1c
++	sizeofInet6Pktinfo          = 0x14
++	sizeofIPv6Mtuinfo           = 0x20
++	sizeofIPv6FlowlabelReq      = 0x20
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x88
++	sizeofGroupSourceReq = 0x108
++
++	sizeofICMPv6Filter = 0x20
++
++	sizeofSockFprog = 0x10
++)
++
++type kernelSockaddrStorage struct {
++	Family  uint16
++	X__data [126]int8
++}
++
++type sockaddrInet6 struct {
++	Family   uint16
++	Port     uint16
++	Flowinfo uint32
++	Addr     [16]byte /* in6_addr */
++	Scope_id uint32
++}
++
++type inet6Pktinfo struct {
++	Addr    [16]byte /* in6_addr */
++	Ifindex int32
++}
++
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
++	Mtu  uint32
++}
++
++type ipv6FlowlabelReq struct {
++	Dst        [16]byte /* in6_addr */
++	Label      uint32
++	Action     uint8
++	Share      uint8
++	Flags      uint16
++	Expires    uint16
++	Linger     uint16
++	X__flr_pad uint32
++}
++
++type ipv6Mreq struct {
++	Multiaddr [16]byte /* in6_addr */
++	Ifindex   int32
++}
++
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [4]byte
++	Group     kernelSockaddrStorage
++	Source    kernelSockaddrStorage
++}
++
++type icmpv6Filter struct {
++	Data [8]uint32
++}
++
++type sockFProg struct {
++	Len       uint16
++	Pad_cgo_0 [6]byte
++	Filter    *sockFilter
++}
++
++type sockFilter struct {
++	Code uint16
++	Jt   uint8
++	Jf   uint8
++	K    uint32
++}
+diff -uNr go-net.old/ipv6/zsys_netbsd.go go-net/ipv6/zsys_netbsd.go
+--- go-net.old/ipv6/zsys_netbsd.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_netbsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -46,16 +46,16 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrInet6 = 0x1c
+-	sysSizeofInet6Pktinfo  = 0x14
+-	sysSizeofIPv6Mtuinfo   = 0x20
++	sizeofSockaddrInet6 = 0x1c
++	sizeofInet6Pktinfo  = 0x14
++	sizeofIPv6Mtuinfo   = 0x20
+ 
+-	sysSizeofIPv6Mreq = 0x14
++	sizeofIPv6Mreq = 0x14
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -64,21 +64,21 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+diff -uNr go-net.old/ipv6/zsys_openbsd.go go-net/ipv6/zsys_openbsd.go
+--- go-net.old/ipv6/zsys_openbsd.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_openbsd.go	2018-05-30 21:00:53.414376369 +0200
+@@ -55,16 +55,16 @@
+ 	sysIPV6_PORTRANGE_HIGH    = 0x1
+ 	sysIPV6_PORTRANGE_LOW     = 0x2
+ 
+-	sysSizeofSockaddrInet6 = 0x1c
+-	sysSizeofInet6Pktinfo  = 0x14
+-	sysSizeofIPv6Mtuinfo   = 0x20
++	sizeofSockaddrInet6 = 0x1c
++	sizeofInet6Pktinfo  = 0x14
++	sizeofIPv6Mtuinfo   = 0x20
+ 
+-	sysSizeofIPv6Mreq = 0x14
++	sizeofIPv6Mreq = 0x14
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrInet6 struct {
+ 	Len      uint8
+ 	Family   uint8
+ 	Port     uint16
+@@ -73,21 +73,21 @@
+ 	Scope_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysICMPv6Filter struct {
++type icmpv6Filter struct {
+ 	Filt [8]uint32
+ }
+diff -uNr go-net.old/ipv6/zsys_solaris.go go-net/ipv6/zsys_solaris.go
+--- go-net.old/ipv6/zsys_solaris.go	2018-05-31 12:15:22.251955203 +0200
++++ go-net/ipv6/zsys_solaris.go	2018-05-30 21:00:53.414376369 +0200
+@@ -1,8 +1,6 @@
+ // Created by cgo -godefs - DO NOT EDIT
+ // cgo -godefs defs_solaris.go
+ 
+-// +build solaris
+-
+ package ipv6
+ 
+ const (
+@@ -44,6 +42,13 @@
+ 
+ 	sysIPV6_RECVDSTOPTS = 0x28
+ 
++	sysMCAST_JOIN_GROUP         = 0x29
++	sysMCAST_LEAVE_GROUP        = 0x2a
++	sysMCAST_BLOCK_SOURCE       = 0x2b
++	sysMCAST_UNBLOCK_SOURCE     = 0x2c
++	sysMCAST_JOIN_SOURCE_GROUP  = 0x2d
++	sysMCAST_LEAVE_SOURCE_GROUP = 0x2e
++
+ 	sysIPV6_PREFER_SRC_HOME   = 0x1
+ 	sysIPV6_PREFER_SRC_COA    = 0x2
+ 	sysIPV6_PREFER_SRC_PUBLIC = 0x4
+@@ -67,16 +72,26 @@
+ 
+ 	sysICMP6_FILTER = 0x1
+ 
+-	sysSizeofSockaddrInet6 = 0x20
+-	sysSizeofInet6Pktinfo  = 0x14
+-	sysSizeofIPv6Mtuinfo   = 0x24
+-
+-	sysSizeofIPv6Mreq = 0x14
++	sizeofSockaddrStorage = 0x100
++	sizeofSockaddrInet6   = 0x20
++	sizeofInet6Pktinfo    = 0x14
++	sizeofIPv6Mtuinfo     = 0x24
++
++	sizeofIPv6Mreq       = 0x14
++	sizeofGroupReq       = 0x104
++	sizeofGroupSourceReq = 0x204
+ 
+-	sysSizeofICMPv6Filter = 0x20
++	sizeofICMPv6Filter = 0x20
+ )
+ 
+-type sysSockaddrInet6 struct {
++type sockaddrStorage struct {
++	Family     uint16
++	X_ss_pad1  [6]int8
++	X_ss_align float64
++	X_ss_pad2  [240]int8
++}
++
++type sockaddrInet6 struct {
+ 	Family         uint16
+ 	Port           uint16
+ 	Flowinfo       uint32
+@@ -85,21 +100,32 @@
+ 	X__sin6_src_id uint32
+ }
+ 
+-type sysInet6Pktinfo struct {
++type inet6Pktinfo struct {
+ 	Addr    [16]byte /* in6_addr */
+ 	Ifindex uint32
+ }
+ 
+-type sysIPv6Mtuinfo struct {
+-	Addr sysSockaddrInet6
++type ipv6Mtuinfo struct {
++	Addr sockaddrInet6
+ 	Mtu  uint32
+ }
+ 
+-type sysIPv6Mreq struct {
++type ipv6Mreq struct {
+ 	Multiaddr [16]byte /* in6_addr */
+ 	Interface uint32
+ }
+ 
+-type sysICMPv6Filter struct {
++type groupReq struct {
++	Interface uint32
++	Pad_cgo_0 [256]byte
++}
++
++type groupSourceReq struct {
++	Interface uint32
++	Pad_cgo_0 [256]byte
++	Pad_cgo_1 [256]byte
++}
++
++type icmpv6Filter struct {
+ 	X__icmp6_filt [8]uint32
+ }
