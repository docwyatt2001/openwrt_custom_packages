--- a/shared/cert.go
+++ b/shared/cert.go
@@ -22,7 +22,11 @@ import (
 	"os/user"
 	"path"
 	"path/filepath"
+	"reflect"
+	"runtime"
 	"time"
+
+	"github.com/lxc/lxd/shared/logger"
 )
 
 // KeyPairAndCA returns a CertInfo object with a reference to the key pair and
@@ -43,6 +47,7 @@ import (
 func KeyPairAndCA(dir, prefix string, kind CertKind) (*CertInfo, error) {
 	certFilename := filepath.Join(dir, prefix+".crt")
 	keyFilename := filepath.Join(dir, prefix+".key")
+	templateFilename = filepath.Join(dir, prefix+".tpl")
 
 	// Ensure that the certificate exists, or create a new one if it does
 	// not.
@@ -247,10 +252,57 @@ func GenCert(certf string, keyf string,
 	return nil
 }
 
+// Necessary for extension
+type Certificate x509.Certificate
+
+// Write certificate template to disk
+var templateFilename string
+
+func (c *Certificate) writeToDisk() error {
+	filename := templateFilename
+	file, err := os.Create(filename)
+	if err != nil {
+		logger.Warnf("Could not create key / certificate template: %v", filename)
+		return err
+	}
+	defer file.Close()
+
+	val := reflect.ValueOf(c).Elem()
+	for i := 0; i < val.NumField(); i++ {
+		vF := val.Field(i)
+		tF := val.Type().Field(i)
+
+		switch vF.Interface().(type) {
+		case string:
+			_, err = file.WriteString(fmt.Sprintf("%s = \"%v\"\n", tF.Name, vF.Interface()))
+		default:
+			_, err = file.WriteString(fmt.Sprintf("%s = %v\n", tF.Name, vF.Interface()))
+		}
+		if err != nil {
+			logger.Warnf("Error writing to file: %v", filename)
+			return err
+		}
+	}
+	file.Sync()
+	logger.Infof("Wrote key / certificate template: %v", filename)
+	return nil
+}
+
 // GenerateMemCert creates client or server certificate and key pair,
 // returning them as byte arrays in memory.
 func GenerateMemCert(client bool) ([]byte, []byte, error) {
-	privk, err := rsa.GenerateKey(rand.Reader, 4096)
+	var keySize int = 4096
+	var generateCertTemplateServer bool = false
+	if runtime.GOARCH == "mips" || runtime.GOARCH == "mipsle" {
+		keySize = 2048
+		logger.Infof("Reduced key size (%v) for generated keys / certificate "+
+			"due to platform problems (%v) with package 'crypto/rsa'->'GenerateKey'",
+			keySize, runtime.GOARCH)
+		if !client {
+			generateCertTemplateServer = true
+		}
+	}
+	privk, err := rsa.GenerateKey(rand.Reader, keySize)
 	if err != nil {
 		return nil, nil, fmt.Errorf("Failed to generate key: %v", err)
 	}
@@ -285,7 +337,7 @@ func GenerateMemCert(client bool) ([]byt
 		hostname = "UNKNOWN"
 	}
 
-	template := x509.Certificate{
+	template := Certificate{
 		SerialNumber: serialNumber,
 		Subject: pkix.Name{
 			Organization: []string{"linuxcontainers.org"},
@@ -314,7 +366,11 @@ func GenerateMemCert(client bool) ([]byt
 		}
 	}
 
-	derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privk.PublicKey, privk)
+	if generateCertTemplateServer {
+		template.writeToDisk()
+	}
+
+	derBytes, err := x509.CreateCertificate(rand.Reader, (*x509.Certificate)(&template), (*x509.Certificate)(&template), &privk.PublicKey, privk)
 	if err != nil {
 		return nil, nil, fmt.Errorf("Failed to create certificate: %v", err)
 	}
