--- /dev/null
+++ b/vendor-patches/netns.patch
@@ -0,0 +1,946 @@
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/config vendor/github.com/vishvananda/netns/.git/config
+--- vendor/github.com/vishvananda/netns.old/.git/config	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/config	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1,11 @@
++[core]
++	repositoryformatversion = 0
++	filemode = true
++	bare = false
++	logallrefupdates = true
++[remote "origin"]
++	url = https://github.com/vishvananda/netns
++	fetch = +refs/heads/*:refs/remotes/origin/*
++[branch "master"]
++	remote = origin
++	merge = refs/heads/master
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/description vendor/github.com/vishvananda/netns/.git/description
+--- vendor/github.com/vishvananda/netns.old/.git/description	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/description	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1 @@
++Unnamed repository; edit this file 'description' to name the repository.
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/HEAD vendor/github.com/vishvananda/netns/.git/HEAD
+--- vendor/github.com/vishvananda/netns.old/.git/HEAD	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/HEAD	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1 @@
++ref: refs/heads/master
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/applypatch-msg.sample vendor/github.com/vishvananda/netns/.git/hooks/applypatch-msg.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/applypatch-msg.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/applypatch-msg.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,15 @@
++#!/bin/sh
++#
++# An example hook script to check the commit log message taken by
++# applypatch from an e-mail message.
++#
++# The hook should exit with non-zero status after issuing an
++# appropriate message if it wants to stop the commit.  The hook is
++# allowed to edit the commit message file.
++#
++# To enable this hook, rename this file to "applypatch-msg".
++
++. git-sh-setup
++commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
++test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
++:
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/commit-msg.sample vendor/github.com/vishvananda/netns/.git/hooks/commit-msg.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/commit-msg.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,24 @@
++#!/bin/sh
++#
++# An example hook script to check the commit log message.
++# Called by "git commit" with one argument, the name of the file
++# that has the commit message.  The hook should exit with non-zero
++# status after issuing an appropriate message if it wants to stop the
++# commit.  The hook is allowed to edit the commit message file.
++#
++# To enable this hook, rename this file to "commit-msg".
++
++# Uncomment the below to add a Signed-off-by line to the message.
++# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
++# hook is more suited to it.
++#
++# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
++# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
++
++# This example catches duplicate Signed-off-by lines.
++
++test "" = "$(grep '^Signed-off-by: ' "$1" |
++	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
++	echo >&2 Duplicate Signed-off-by lines.
++	exit 1
++}
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/post-update.sample vendor/github.com/vishvananda/netns/.git/hooks/post-update.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/post-update.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/post-update.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,8 @@
++#!/bin/sh
++#
++# An example hook script to prepare a packed repository for use over
++# dumb transports.
++#
++# To enable this hook, rename this file to "post-update".
++
++exec git update-server-info
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/pre-applypatch.sample vendor/github.com/vishvananda/netns/.git/hooks/pre-applypatch.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/pre-applypatch.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/pre-applypatch.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,14 @@
++#!/bin/sh
++#
++# An example hook script to verify what is about to be committed
++# by applypatch from an e-mail message.
++#
++# The hook should exit with non-zero status after issuing an
++# appropriate message if it wants to stop the commit.
++#
++# To enable this hook, rename this file to "pre-applypatch".
++
++. git-sh-setup
++precommit="$(git rev-parse --git-path hooks/pre-commit)"
++test -x "$precommit" && exec "$precommit" ${1+"$@"}
++:
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/pre-commit.sample vendor/github.com/vishvananda/netns/.git/hooks/pre-commit.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/pre-commit.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/pre-commit.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,49 @@
++#!/bin/sh
++#
++# An example hook script to verify what is about to be committed.
++# Called by "git commit" with no arguments.  The hook should
++# exit with non-zero status after issuing an appropriate message if
++# it wants to stop the commit.
++#
++# To enable this hook, rename this file to "pre-commit".
++
++if git rev-parse --verify HEAD >/dev/null 2>&1
++then
++	against=HEAD
++else
++	# Initial commit: diff against an empty tree object
++	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
++fi
++
++# If you want to allow non-ASCII filenames set this variable to true.
++allownonascii=$(git config --bool hooks.allownonascii)
++
++# Redirect output to stderr.
++exec 1>&2
++
++# Cross platform projects tend to avoid non-ASCII filenames; prevent
++# them from being added to the repository. We exploit the fact that the
++# printable range starts at the space character and ends with tilde.
++if [ "$allownonascii" != "true" ] &&
++	# Note that the use of brackets around a tr range is ok here, (it's
++	# even required, for portability to Solaris 10's /usr/bin/tr), since
++	# the square bracket bytes happen to fall in the designated range.
++	test $(git diff --cached --name-only --diff-filter=A -z $against |
++	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
++then
++	cat <<\EOF
++Error: Attempt to add a non-ASCII file name.
++
++This can cause problems if you want to work with people on other platforms.
++
++To be portable it is advisable to rename the file.
++
++If you know what you are doing you can disable this check using:
++
++  git config hooks.allownonascii true
++EOF
++	exit 1
++fi
++
++# If there are whitespace errors, print the offending file names and fail.
++exec git diff-index --check --cached $against --
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/prepare-commit-msg.sample vendor/github.com/vishvananda/netns/.git/hooks/prepare-commit-msg.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/prepare-commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/prepare-commit-msg.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,36 @@
++#!/bin/sh
++#
++# An example hook script to prepare the commit log message.
++# Called by "git commit" with the name of the file that has the
++# commit message, followed by the description of the commit
++# message's source.  The hook's purpose is to edit the commit
++# message file.  If the hook fails with a non-zero status,
++# the commit is aborted.
++#
++# To enable this hook, rename this file to "prepare-commit-msg".
++
++# This hook includes three examples.  The first comments out the
++# "Conflicts:" part of a merge commit.
++#
++# The second includes the output of "git diff --name-status -r"
++# into the message, just before the "git status" output.  It is
++# commented because it doesn't cope with --amend or with squashed
++# commits.
++#
++# The third example adds a Signed-off-by line to the message, that can
++# still be edited.  This is rarely a good idea.
++
++case "$2,$3" in
++  merge,)
++    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
++
++# ,|template,)
++#   /usr/bin/perl -i.bak -pe '
++#      print "\n" . `git diff --cached --name-status -r`
++#	 if /^#/ && $first++ == 0' "$1" ;;
++
++  *) ;;
++esac
++
++# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
++# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/pre-push.sample vendor/github.com/vishvananda/netns/.git/hooks/pre-push.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/pre-push.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/pre-push.sample	2018-06-02 18:21:18.423520804 +0200
+@@ -0,0 +1,53 @@
++#!/bin/sh
++
++# An example hook script to verify what is about to be pushed.  Called by "git
++# push" after it has checked the remote status, but before anything has been
++# pushed.  If this script exits with a non-zero status nothing will be pushed.
++#
++# This hook is called with the following parameters:
++#
++# $1 -- Name of the remote to which the push is being done
++# $2 -- URL to which the push is being done
++#
++# If pushing without using a named remote those arguments will be equal.
++#
++# Information about the commits which are being pushed is supplied as lines to
++# the standard input in the form:
++#
++#   <local ref> <local sha1> <remote ref> <remote sha1>
++#
++# This sample shows how to prevent push of commits where the log message starts
++# with "WIP" (work in progress).
++
++remote="$1"
++url="$2"
++
++z40=0000000000000000000000000000000000000000
++
++while read local_ref local_sha remote_ref remote_sha
++do
++	if [ "$local_sha" = $z40 ]
++	then
++		# Handle delete
++		:
++	else
++		if [ "$remote_sha" = $z40 ]
++		then
++			# New branch, examine all commits
++			range="$local_sha"
++		else
++			# Update to existing branch, examine new commits
++			range="$remote_sha..$local_sha"
++		fi
++
++		# Check for WIP commit
++		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
++		if [ -n "$commit" ]
++		then
++			echo >&2 "Found WIP commit in $local_ref, not pushing"
++			exit 1
++		fi
++	fi
++done
++
++exit 0
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/pre-rebase.sample vendor/github.com/vishvananda/netns/.git/hooks/pre-rebase.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/pre-rebase.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/pre-rebase.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,169 @@
++#!/bin/sh
++#
++# Copyright (c) 2006, 2008 Junio C Hamano
++#
++# The "pre-rebase" hook is run just before "git rebase" starts doing
++# its job, and can prevent the command from running by exiting with
++# non-zero status.
++#
++# The hook is called with the following parameters:
++#
++# $1 -- the upstream the series was forked from.
++# $2 -- the branch being rebased (or empty when rebasing the current branch).
++#
++# This sample shows how to prevent topic branches that are already
++# merged to 'next' branch from getting rebased, because allowing it
++# would result in rebasing already published history.
++
++publish=next
++basebranch="$1"
++if test "$#" = 2
++then
++	topic="refs/heads/$2"
++else
++	topic=`git symbolic-ref HEAD` ||
++	exit 0 ;# we do not interrupt rebasing detached HEAD
++fi
++
++case "$topic" in
++refs/heads/??/*)
++	;;
++*)
++	exit 0 ;# we do not interrupt others.
++	;;
++esac
++
++# Now we are dealing with a topic branch being rebased
++# on top of master.  Is it OK to rebase it?
++
++# Does the topic really exist?
++git show-ref -q "$topic" || {
++	echo >&2 "No such branch $topic"
++	exit 1
++}
++
++# Is topic fully merged to master?
++not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
++if test -z "$not_in_master"
++then
++	echo >&2 "$topic is fully merged to master; better remove it."
++	exit 1 ;# we could allow it, but there is no point.
++fi
++
++# Is topic ever merged to next?  If so you should not be rebasing it.
++only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
++only_next_2=`git rev-list ^master           ${publish} | sort`
++if test "$only_next_1" = "$only_next_2"
++then
++	not_in_topic=`git rev-list "^$topic" master`
++	if test -z "$not_in_topic"
++	then
++		echo >&2 "$topic is already up-to-date with master"
++		exit 1 ;# we could allow it, but there is no point.
++	else
++		exit 0
++	fi
++else
++	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
++	/usr/bin/perl -e '
++		my $topic = $ARGV[0];
++		my $msg = "* $topic has commits already merged to public branch:\n";
++		my (%not_in_next) = map {
++			/^([0-9a-f]+) /;
++			($1 => 1);
++		} split(/\n/, $ARGV[1]);
++		for my $elem (map {
++				/^([0-9a-f]+) (.*)$/;
++				[$1 => $2];
++			} split(/\n/, $ARGV[2])) {
++			if (!exists $not_in_next{$elem->[0]}) {
++				if ($msg) {
++					print STDERR $msg;
++					undef $msg;
++				}
++				print STDERR " $elem->[1]\n";
++			}
++		}
++	' "$topic" "$not_in_next" "$not_in_master"
++	exit 1
++fi
++
++<<\DOC_END
++
++This sample hook safeguards topic branches that have been
++published from being rewound.
++
++The workflow assumed here is:
++
++ * Once a topic branch forks from "master", "master" is never
++   merged into it again (either directly or indirectly).
++
++ * Once a topic branch is fully cooked and merged into "master",
++   it is deleted.  If you need to build on top of it to correct
++   earlier mistakes, a new topic branch is created by forking at
++   the tip of the "master".  This is not strictly necessary, but
++   it makes it easier to keep your history simple.
++
++ * Whenever you need to test or publish your changes to topic
++   branches, merge them into "next" branch.
++
++The script, being an example, hardcodes the publish branch name
++to be "next", but it is trivial to make it configurable via
++$GIT_DIR/config mechanism.
++
++With this workflow, you would want to know:
++
++(1) ... if a topic branch has ever been merged to "next".  Young
++    topic branches can have stupid mistakes you would rather
++    clean up before publishing, and things that have not been
++    merged into other branches can be easily rebased without
++    affecting other people.  But once it is published, you would
++    not want to rewind it.
++
++(2) ... if a topic branch has been fully merged to "master".
++    Then you can delete it.  More importantly, you should not
++    build on top of it -- other people may already want to
++    change things related to the topic as patches against your
++    "master", so if you need further changes, it is better to
++    fork the topic (perhaps with the same name) afresh from the
++    tip of "master".
++
++Let's look at this example:
++
++		   o---o---o---o---o---o---o---o---o---o "next"
++		  /       /           /           /
++		 /   a---a---b A     /           /
++		/   /               /           /
++	       /   /   c---c---c---c B         /
++	      /   /   /             \         /
++	     /   /   /   b---b C     \       /
++	    /   /   /   /             \     /
++    ---o---o---o---o---o---o---o---o---o---o---o "master"
++
++
++A, B and C are topic branches.
++
++ * A has one fix since it was merged up to "next".
++
++ * B has finished.  It has been fully merged up to "master" and "next",
++   and is ready to be deleted.
++
++ * C has not merged to "next" at all.
++
++We would want to allow C to be rebased, refuse A, and encourage
++B to be deleted.
++
++To compute (1):
++
++	git rev-list ^master ^topic next
++	git rev-list ^master        next
++
++	if these match, topic has not merged in next at all.
++
++To compute (2):
++
++	git rev-list master..topic
++
++	if this is empty, it is fully merged to "master".
++
++DOC_END
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/pre-receive.sample vendor/github.com/vishvananda/netns/.git/hooks/pre-receive.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/pre-receive.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/pre-receive.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,24 @@
++#!/bin/sh
++#
++# An example hook script to make use of push options.
++# The example simply echoes all push options that start with 'echoback='
++# and rejects all pushes when the "reject" push option is used.
++#
++# To enable this hook, rename this file to "pre-receive".
++
++if test -n "$GIT_PUSH_OPTION_COUNT"
++then
++	i=0
++	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
++	do
++		eval "value=\$GIT_PUSH_OPTION_$i"
++		case "$value" in
++		echoback=*)
++			echo "echo from the pre-receive-hook: ${value#*=}" >&2
++			;;
++		reject)
++			exit 1
++		esac
++		i=$((i + 1))
++	done
++fi
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/hooks/update.sample vendor/github.com/vishvananda/netns/.git/hooks/update.sample
+--- vendor/github.com/vishvananda/netns.old/.git/hooks/update.sample	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/hooks/update.sample	2018-06-02 18:21:18.427520723 +0200
+@@ -0,0 +1,128 @@
++#!/bin/sh
++#
++# An example hook script to block unannotated tags from entering.
++# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
++#
++# To enable this hook, rename this file to "update".
++#
++# Config
++# ------
++# hooks.allowunannotated
++#   This boolean sets whether unannotated tags will be allowed into the
++#   repository.  By default they won't be.
++# hooks.allowdeletetag
++#   This boolean sets whether deleting tags will be allowed in the
++#   repository.  By default they won't be.
++# hooks.allowmodifytag
++#   This boolean sets whether a tag may be modified after creation. By default
++#   it won't be.
++# hooks.allowdeletebranch
++#   This boolean sets whether deleting branches will be allowed in the
++#   repository.  By default they won't be.
++# hooks.denycreatebranch
++#   This boolean sets whether remotely creating branches will be denied
++#   in the repository.  By default this is allowed.
++#
++
++# --- Command line
++refname="$1"
++oldrev="$2"
++newrev="$3"
++
++# --- Safety check
++if [ -z "$GIT_DIR" ]; then
++	echo "Don't run this script from the command line." >&2
++	echo " (if you want, you could supply GIT_DIR then run" >&2
++	echo "  $0 <ref> <oldrev> <newrev>)" >&2
++	exit 1
++fi
++
++if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
++	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
++	exit 1
++fi
++
++# --- Config
++allowunannotated=$(git config --bool hooks.allowunannotated)
++allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
++denycreatebranch=$(git config --bool hooks.denycreatebranch)
++allowdeletetag=$(git config --bool hooks.allowdeletetag)
++allowmodifytag=$(git config --bool hooks.allowmodifytag)
++
++# check for no description
++projectdesc=$(sed -e '1q' "$GIT_DIR/description")
++case "$projectdesc" in
++"Unnamed repository"* | "")
++	echo "*** Project description file hasn't been set" >&2
++	exit 1
++	;;
++esac
++
++# --- Check types
++# if $newrev is 0000...0000, it's a commit to delete a ref.
++zero="0000000000000000000000000000000000000000"
++if [ "$newrev" = "$zero" ]; then
++	newrev_type=delete
++else
++	newrev_type=$(git cat-file -t $newrev)
++fi
++
++case "$refname","$newrev_type" in
++	refs/tags/*,commit)
++		# un-annotated tag
++		short_refname=${refname##refs/tags/}
++		if [ "$allowunannotated" != "true" ]; then
++			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
++			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
++			exit 1
++		fi
++		;;
++	refs/tags/*,delete)
++		# delete tag
++		if [ "$allowdeletetag" != "true" ]; then
++			echo "*** Deleting a tag is not allowed in this repository" >&2
++			exit 1
++		fi
++		;;
++	refs/tags/*,tag)
++		# annotated tag
++		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
++		then
++			echo "*** Tag '$refname' already exists." >&2
++			echo "*** Modifying a tag is not allowed in this repository." >&2
++			exit 1
++		fi
++		;;
++	refs/heads/*,commit)
++		# branch
++		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
++			echo "*** Creating a branch is not allowed in this repository" >&2
++			exit 1
++		fi
++		;;
++	refs/heads/*,delete)
++		# delete branch
++		if [ "$allowdeletebranch" != "true" ]; then
++			echo "*** Deleting a branch is not allowed in this repository" >&2
++			exit 1
++		fi
++		;;
++	refs/remotes/*,commit)
++		# tracking branch
++		;;
++	refs/remotes/*,delete)
++		# delete tracking branch
++		if [ "$allowdeletebranch" != "true" ]; then
++			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
++			exit 1
++		fi
++		;;
++	*)
++		# Anything else (is there anything else?)
++		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
++		exit 1
++		;;
++esac
++
++# --- Finished
++exit 0
+Binärdateien vendor/github.com/vishvananda/netns.old/.git/index und vendor/github.com/vishvananda/netns/.git/index sind verschieden.
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/info/exclude vendor/github.com/vishvananda/netns/.git/info/exclude
+--- vendor/github.com/vishvananda/netns.old/.git/info/exclude	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/info/exclude	2018-06-02 18:21:18.423520804 +0200
+@@ -0,0 +1,6 @@
++# git ls-files --others --exclude-from=.git/info/exclude
++# Lines that start with '#' are comments.
++# For a project mostly in C, the following would be a good set of
++# exclude patterns (uncomment them if you want to use them):
++# *.[oa]
++# *~
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/logs/HEAD vendor/github.com/vishvananda/netns/.git/logs/HEAD
+--- vendor/github.com/vishvananda/netns.old/.git/logs/HEAD	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/logs/HEAD	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1 @@
++0000000000000000000000000000000000000000 be1fbeda19366dea804f00efff2dd73a1642fdcc Manfred Gschweidl <m.gschweidl@gmail.com> 1527956479 +0200	clone: from https://github.com/vishvananda/netns
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/logs/refs/heads/master vendor/github.com/vishvananda/netns/.git/logs/refs/heads/master
+--- vendor/github.com/vishvananda/netns.old/.git/logs/refs/heads/master	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/logs/refs/heads/master	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1 @@
++0000000000000000000000000000000000000000 be1fbeda19366dea804f00efff2dd73a1642fdcc Manfred Gschweidl <m.gschweidl@gmail.com> 1527956479 +0200	clone: from https://github.com/vishvananda/netns
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/logs/refs/remotes/origin/HEAD vendor/github.com/vishvananda/netns/.git/logs/refs/remotes/origin/HEAD
+--- vendor/github.com/vishvananda/netns.old/.git/logs/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/logs/refs/remotes/origin/HEAD	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1 @@
++0000000000000000000000000000000000000000 be1fbeda19366dea804f00efff2dd73a1642fdcc Manfred Gschweidl <m.gschweidl@gmail.com> 1527956479 +0200	clone: from https://github.com/vishvananda/netns
+Binärdateien vendor/github.com/vishvananda/netns.old/.git/objects/pack/pack-7f364eb4f7ca070b3557fe1b9614209211bb70cb.idx und vendor/github.com/vishvananda/netns/.git/objects/pack/pack-7f364eb4f7ca070b3557fe1b9614209211bb70cb.idx sind verschieden.
+Binärdateien vendor/github.com/vishvananda/netns.old/.git/objects/pack/pack-7f364eb4f7ca070b3557fe1b9614209211bb70cb.pack und vendor/github.com/vishvananda/netns/.git/objects/pack/pack-7f364eb4f7ca070b3557fe1b9614209211bb70cb.pack sind verschieden.
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/packed-refs vendor/github.com/vishvananda/netns/.git/packed-refs
+--- vendor/github.com/vishvananda/netns.old/.git/packed-refs	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/packed-refs	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1,2 @@
++# pack-refs with: peeled fully-peeled 
++be1fbeda19366dea804f00efff2dd73a1642fdcc refs/remotes/origin/master
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/refs/heads/master vendor/github.com/vishvananda/netns/.git/refs/heads/master
+--- vendor/github.com/vishvananda/netns.old/.git/refs/heads/master	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/refs/heads/master	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1 @@
++be1fbeda19366dea804f00efff2dd73a1642fdcc
+diff -uNr vendor/github.com/vishvananda/netns.old/.git/refs/remotes/origin/HEAD vendor/github.com/vishvananda/netns/.git/refs/remotes/origin/HEAD
+--- vendor/github.com/vishvananda/netns.old/.git/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/.git/refs/remotes/origin/HEAD	2018-06-02 18:21:19.323502194 +0200
+@@ -0,0 +1 @@
++ref: refs/remotes/origin/master
+diff -uNr vendor/github.com/vishvananda/netns.old/netns.go vendor/github.com/vishvananda/netns/netns.go
+--- vendor/github.com/vishvananda/netns.old/netns.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns.go	2018-06-02 18:21:19.335501944 +0200
+@@ -19,7 +19,7 @@
+ 
+ // Equal determines if two network handles refer to the same network
+ // namespace. This is done by comparing the device and inode that the
+-// file descripors point to.
++// file descriptors point to.
+ func (ns NsHandle) Equal(other NsHandle) bool {
+ 	if ns == other {
+ 		return true
+@@ -46,6 +46,19 @@
+ 	return fmt.Sprintf("NS(%d: %d, %d)", ns, s.Dev, s.Ino)
+ }
+ 
++// UniqueId returns a string which uniquely identifies the namespace
++// associated with the network handle.
++func (ns NsHandle) UniqueId() string {
++	var s syscall.Stat_t
++	if ns == -1 {
++		return "NS(none)"
++	}
++	if err := syscall.Fstat(int(ns), &s); err != nil {
++		return "NS(unknown)"
++	}
++	return fmt.Sprintf("NS(%d:%d)", s.Dev, s.Ino)
++}
++
+ // IsOpen returns true if Close() has not been called.
+ func (ns NsHandle) IsOpen() bool {
+ 	return ns != -1
+@@ -61,7 +74,7 @@
+ 	return nil
+ }
+ 
+-// Get an empty (closed) NsHandle
++// None gets an empty (closed) NsHandle.
+ func None() NsHandle {
+ 	return NsHandle(-1)
+ }
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux_386.go vendor/github.com/vishvananda/netns/netns_linux_386.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux_386.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux_386.go	1970-01-01 01:00:00.000000000 +0100
+@@ -1,7 +0,0 @@
+-// +build linux,386
+-
+-package netns
+-
+-const (
+-	SYS_SETNS = 346
+-)
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux_amd64.go vendor/github.com/vishvananda/netns/netns_linux_amd64.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux_amd64.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux_amd64.go	1970-01-01 01:00:00.000000000 +0100
+@@ -1,7 +0,0 @@
+-// +build linux,amd64
+-
+-package netns
+-
+-const (
+-	SYS_SETNS = 308
+-)
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux_arm64.go vendor/github.com/vishvananda/netns/netns_linux_arm64.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux_arm64.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux_arm64.go	1970-01-01 01:00:00.000000000 +0100
+@@ -1,7 +0,0 @@
+-// +build linux,arm64
+-
+-package netns
+-
+-const (
+-	SYS_SETNS = 268
+-)
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux_arm.go vendor/github.com/vishvananda/netns/netns_linux_arm.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux_arm.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux_arm.go	1970-01-01 01:00:00.000000000 +0100
+@@ -1,7 +0,0 @@
+-// +build linux,arm
+-
+-package netns
+-
+-const (
+-	SYS_SETNS = 375
+-)
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux.go vendor/github.com/vishvananda/netns/netns_linux.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux.go	2018-06-02 18:21:19.335501944 +0200
+@@ -7,14 +7,27 @@
+ 	"io/ioutil"
+ 	"os"
+ 	"path/filepath"
++	"runtime"
+ 	"strconv"
+ 	"strings"
+ 	"syscall"
+ )
+ 
++// SYS_SETNS syscall allows changing the namespace of the current process.
++var SYS_SETNS = map[string]uintptr{
++	"386":     346,
++	"amd64":   308,
++	"arm64":   268,
++	"arm":     375,
++	"mips":    4344,
++	"mipsle":  4344,
++	"ppc64":   350,
++	"ppc64le": 350,
++	"s390x":   339,
++}[runtime.GOARCH]
++
++// Deprecated: use syscall pkg instead (go >= 1.5 needed).
+ const (
+-	// These constants belong in the syscall library but have not been
+-	// added yet.
+ 	CLONE_NEWUTS  = 0x04000000 /* New utsname group? */
+ 	CLONE_NEWIPC  = 0x08000000 /* New ipcs */
+ 	CLONE_NEWUSER = 0x10000000 /* New user namespace */
+@@ -125,7 +138,9 @@
+ 		return "", fmt.Errorf("docker pid not found in /var/run/docker.pid")
+ 	}
+ 	pid, err := strconv.Atoi(result[0])
+-
++	if err != nil {
++		return "", err
++	}
+ 	output, err := ioutil.ReadFile(fmt.Sprintf("/proc/%d/cgroup", pid))
+ 	if err != nil {
+ 		return "", err
+@@ -167,8 +182,14 @@
+ 		filepath.Join(cgroupRoot, cgroupThis, id, "tasks"),
+ 		// With more recent lxc versions use, cgroup will be in lxc/
+ 		filepath.Join(cgroupRoot, cgroupThis, "lxc", id, "tasks"),
+-		// With more recent dockee, cgroup will be in docker/
++		// With more recent docker, cgroup will be in docker/
+ 		filepath.Join(cgroupRoot, cgroupThis, "docker", id, "tasks"),
++		// Even more recent docker versions under systemd use docker-<id>.scope/
++		filepath.Join(cgroupRoot, "system.slice", "docker-"+id+".scope", "tasks"),
++		// Even more recent docker versions under cgroup/systemd/docker/<id>/
++		filepath.Join(cgroupRoot, "..", "systemd", "docker", id, "tasks"),
++		// Kubernetes with docker and CNI is even more different
++		filepath.Join(cgroupRoot, "..", "systemd", "kubepods", "*", "pod*", id, "tasks"),
+ 	}
+ 
+ 	var filename string
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux_ppc64le.go vendor/github.com/vishvananda/netns/netns_linux_ppc64le.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux_ppc64le.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux_ppc64le.go	1970-01-01 01:00:00.000000000 +0100
+@@ -1,7 +0,0 @@
+-// +build linux,ppc64le
+-
+-package netns
+-
+-const (
+-	SYS_SETNS = 350
+-)
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_linux_s390x.go vendor/github.com/vishvananda/netns/netns_linux_s390x.go
+--- vendor/github.com/vishvananda/netns.old/netns_linux_s390x.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_linux_s390x.go	1970-01-01 01:00:00.000000000 +0100
+@@ -1,7 +0,0 @@
+-// +build linux,s390x
+-
+-package netns
+-
+-const (
+-	SYS_SETNS = 339
+-)
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_test.go vendor/github.com/vishvananda/netns/netns_test.go
+--- vendor/github.com/vishvananda/netns.old/netns_test.go	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/netns_test.go	2018-06-02 18:21:19.335501944 +0200
+@@ -0,0 +1,66 @@
++package netns
++
++import (
++	"runtime"
++	"sync"
++	"testing"
++)
++
++func TestGetNewSetDelete(t *testing.T) {
++	runtime.LockOSThread()
++	defer runtime.UnlockOSThread()
++
++	origns, err := Get()
++	if err != nil {
++		t.Fatal(err)
++	}
++	newns, err := New()
++	if err != nil {
++		t.Fatal(err)
++	}
++	if origns.Equal(newns) {
++		t.Fatal("New ns failed")
++	}
++	if err := Set(origns); err != nil {
++		t.Fatal(err)
++	}
++	newns.Close()
++	if newns.IsOpen() {
++		t.Fatal("newns still open after close", newns)
++	}
++	ns, err := Get()
++	if err != nil {
++		t.Fatal(err)
++	}
++	if !ns.Equal(origns) {
++		t.Fatal("Reset ns failed", origns, newns, ns)
++	}
++}
++
++func TestNone(t *testing.T) {
++	ns := None()
++	if ns.IsOpen() {
++		t.Fatal("None ns is open", ns)
++	}
++}
++
++func TestThreaded(t *testing.T) {
++	ncpu := runtime.GOMAXPROCS(-1)
++	if ncpu < 2 {
++		t.Skip("-cpu=2 or larger required")
++	}
++
++	// Lock this thread simply to ensure other threads get used.
++	runtime.LockOSThread()
++	defer runtime.UnlockOSThread()
++
++	wg := &sync.WaitGroup{}
++	for i := 0; i < ncpu; i++ {
++		wg.Add(1)
++		go func() {
++			defer wg.Done()
++			TestGetNewSetDelete(t)
++		}()
++	}
++	wg.Wait()
++}
+diff -uNr vendor/github.com/vishvananda/netns.old/netns_unspecified.go vendor/github.com/vishvananda/netns/netns_unspecified.go
+--- vendor/github.com/vishvananda/netns.old/netns_unspecified.go	2017-06-01 23:14:48.000000000 +0200
++++ vendor/github.com/vishvananda/netns/netns_unspecified.go	2018-06-02 18:21:19.335501944 +0200
+@@ -22,6 +22,10 @@
+ 	return -1, ErrNotImplemented
+ }
+ 
++func GetFromPath(path string) (NsHandle, error) {
++	return -1, ErrNotImplemented
++}
++
+ func GetFromName(name string) (NsHandle, error) {
+ 	return -1, ErrNotImplemented
+ }
+@@ -30,6 +34,10 @@
+ 	return -1, ErrNotImplemented
+ }
+ 
++func GetFromThread(pid, tid int) (NsHandle, error) {
++	return -1, ErrNotImplemented
++}
++
+ func GetFromDocker(id string) (NsHandle, error) {
+ 	return -1, ErrNotImplemented
+ }
+diff -uNr vendor/github.com/vishvananda/netns.old/README.md vendor/github.com/vishvananda/netns/README.md
+--- vendor/github.com/vishvananda/netns.old/README.md	1970-01-01 01:00:00.000000000 +0100
++++ vendor/github.com/vishvananda/netns/README.md	2018-06-02 18:21:19.335501944 +0200
+@@ -0,0 +1,51 @@
++# netns - network namespaces in go #
++
++The netns package provides an ultra-simple interface for handling
++network namespaces in go. Changing namespaces requires elevated
++privileges, so in most cases this code needs to be run as root.
++
++## Local Build and Test ##
++
++You can use go get command:
++
++    go get github.com/vishvananda/netns
++
++Testing (requires root):
++
++    sudo -E go test github.com/vishvananda/netns
++
++## Example ##
++
++```go
++package main
++
++import (
++    "fmt"
++    "net"
++    "runtime"
++    "github.com/vishvananda/netns"
++)
++
++func main() {
++    // Lock the OS Thread so we don't accidentally switch namespaces
++    runtime.LockOSThread()
++    defer runtime.UnlockOSThread()
++
++    // Save the current network namespace
++    origns, _ := netns.Get()
++    defer origns.Close()
++
++    // Create a new network namespace
++    newns, _ := netns.New()
++    netns.Set(newns)
++    defer newns.Close()
++
++    // Do something with the network namespace
++    ifaces, _ := net.Interfaces()
++    fmt.Printf("Interfaces: %v\n", ifaces)
++
++    // Switch back to the original namespace
++    netns.Set(origns)
++}
++
++```
